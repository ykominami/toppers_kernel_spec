<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<title>主要な概念と共通定義</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
body{-webkit-font-smoothing:antialiased}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
body{tab-size:4}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="ch2_concepts_and_Common_definision">1. 主要な概念と共通定義</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_仕様の位置付け">1.1. 仕様の位置付け</h3>
<div class="paragraph">
<p>この仕様は，TOPPERS新世代カーネルに属する各カーネルの仕様を，統合的に記
述することを目標としている．また，TOPPERS新世代カーネル上で動作する各種
のシステムサービスに共通に適用される事項についても規定する．</p>
</div>
<div class="sect3">
<h4 id="_カーネルの機能セット">1.1.1. カーネルの機能セット</h4>
<div class="paragraph">
<p>TOPPERS新世代カーネルは，ASPカーネルをベースとして，保護機能，マルチプ
ロセッサ，カーネルオブジェクトの動的生成，機能安全などに対応した一連の
カーネルで構成される．</p>
</div>
<div class="paragraph">
<p>この仕様では，TOPPERS新世代カーネルを構成する一連のカーネルの仕様を統合
的に記述するが，言うまでもなく，カーネルの種類によってサポートする機能
は異なる．サポートする機能をカーネルの種類毎に記述する方法もあるが，カー
ネルの種類はユーザ要求に対応して増える可能性もあり，その度に仕様書を修
正するのは得策ではない．</p>
</div>
<div class="paragraph">
<p>そこでこの仕様では，サポートする機能を，カーネルの種類毎ではなく，カー
ネルの対応する機能セット毎に記述する．具体的には，保護機能を持ったカー
ネルを保護機能対応カーネル，マルチプロセッサに対応したカーネルをマルチ
プロセッサ対応カーネル，カーネルオブジェクトの動的生成機能を持ったカー
ネルを動的生成対応カーネルと呼ぶことにする．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/ASPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>ASPカーネルは，保護機能対応カーネル，マルチプロセッサ対応カーネル，動的
生成対応カーネルのいずれでもない【ASPS0001】．ただし，動的生成機能拡張
パッケージを用いると，動的生成対応カーネルの機能の一部がサポートされる
【ASPS0002】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/FMPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>FMPカーネルは，マルチプロセッサ対応カーネルであり，保護機能対応カーネル，
動的生成対応カーネルではない【FMPS0001】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/HRP2カーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>HRP2カーネルは，保護機能対応カーネルであり，マルチプロセッサ対応カーネ
ル，動的生成対応カーネルではない【HRPS0001】．ただし，動的生成機能拡張
パッケージを用いると，動的生成対応カーネルの機能の一部がサポートされる
【HRPS0009】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/SSPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>SSPカーネルは，保護機能対応カーネル，マルチプロセッサ対応カーネル，動的
生成対応カーネルのいずれでもない【SSPS0001】．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様，μITRON4.0/PX仕様との関係】</p>
</div>
<div class="paragraph">
<p>μITRON4.0仕様は，カーネルオブジェクトの動的生成機能を持っているが，保
護機能を持っておらず，マルチプロセッサにも対応していない．μITRON4.0/PX
仕様は，μITRON4.0仕様に対して保護機能を追加するための仕様であり，カー
ネルオブジェクトの動的生成機能と保護機能を持っているが，マルチプロセッ
サには対応していない．</p>
</div>
</div>
<div class="sect3">
<h4 id="_ターゲット非依存の規定とターゲット定義の規定">1.1.2. ターゲット非依存の規定とターゲット定義の規定</h4>
<div class="paragraph">
<p>TOPPERS新世代カーネルは，アプリケーションプログラムの再利用性を向上させ
るために，ターゲットハードウェアや開発環境の違いをできる限り隠蔽するこ
とを目指している．ただし，ターゲットハードウェアや開発環境の制限によっ
て実現できない機能が生じたり，逆にターゲットハードウェアの特徴を活かす
ためには機能拡張が不可欠になる場合がある．また，同一のターゲットハード
ウェアであっても，アプリケーションシステムによって使用方法が異なる場合
があり，ターゲットシステム毎に仕様の細部に違いが生じることは避けられな
い．</p>
</div>
<div class="paragraph">
<p>そこで，TOPPERS新世代カーネルの仕様は，ターゲットシステムによらずに定め
るターゲット非依存（target-independent）の規定と，ターゲットシステム毎
に定めるターゲット定義（target-defined）の規定に分けて記述する．この仕
様書は，ターゲット非依存の規定について記述するものであり，この仕様書で
「ターゲット定義」とした事項は，ターゲットシステム毎に用意するドキュメ
ントにおいて規定する．</p>
</div>
<div class="paragraph">
<p>また，この仕様書でターゲット非依存に規定した事項であっても，ターゲット
ハードウェアや開発環境の制限によって実現できない場合や，実現するための
オーバヘッドが大きくなる場合には，この仕様書の規定を逸脱する場合がある．
このような場合には，ターゲットシステム毎に用意するドキュメントでその旨
を明記する．</p>
</div>
</div>
<div class="sect3">
<h4 id="_想定するソフトウェア構成">1.1.3. 想定するソフトウェア構成</h4>
<div class="paragraph">
<p>この仕様では，アプリケーションシステムを構成するソフトウェアを，アプリ
ケーションプログラム（以下，単にアプリケーションと呼ぶ），システムサー
ビス，カーネルの3階層に分けて考える（図2-1）．カーネルとシステムサービ
スをあわせて，ソフトウェアプラットフォームと呼ぶ．</p>
</div>
<div class="paragraph">
<p>カーネルは，コンピュータの持つ最も基本的なハードウェア資源であるプロセッ
サ，メモリ，タイマを抽象化し，上位階層のソフトウェア（アプリケーション
およびシステムサービス）に論理的なプログラム実行環境を提供するソフトウェ
アである．</p>
</div>
<div class="paragraph">
<p>システムサービスは，各種の周辺デバイスを抽象化するソフトウェアで，ファ
イルシステムやネットワークプロトコルスタック，各種のデバイスドライバな
どが含まれる．</p>
</div>
<div class="paragraph">
<p>また，この仕様では，プロセッサと各種の周辺デバイスの接続方法を隠蔽する
ためのソフトウェア階層として，システムインタフェースレイヤ（SIL）を規定
する．</p>
</div>
<div class="paragraph">
<p>システムインタフェースレイヤ，カーネル，各種のシステムサービス（これら
をモジュールと呼ぶ）を，上位階層のソフトウェアから使うためのインタフェー
スを，API（Application Programming Interface）と呼ぶ．</p>
</div>
<div class="paragraph">
<p>この仕様書では，第3章においてシステムインタフェースレイヤのAPI仕様を，
第4章においてカーネルのAPI仕様を規定する．システムサービスのAPI仕様は，
システムサービス毎の仕様書で規定される．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>μITRON4.0仕様では，カーネルとアプリケーションの中間にあるソフトウェア
をソフトウェア部品と呼んでいたが，TOPPERS組込みコンポーネントシステム
（TECS）においてはカーネルもソフトウェア部品の1つと捉えることから，この
仕様ではシステムサービスと呼ぶことにした．</p>
</div>
</div>
<div class="sect3">
<h4 id="_想定するハードウェア構成">1.1.4. 想定するハードウェア構成</h4>
<div class="paragraph">
<p>この仕様では，カーネルがサポートするハードウェア構成として，以下のこと
を想定している．これらに合致しないターゲットハードウェアでカーネルを動
作させることは可能であるが，合致しない部分への適応はアプリケーションの
責任になる．</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>メモリ番地は，常に同一のメモリを指すこと（オーバレイのように，異な
るメモリを同一のメモリ番地でアクセスすることがないこと）【NGKI0001】．
マルチプロセッサ対応カーネルにおいては，同一のメモリに対しては，各プロ
セッサから同一の番地でアクセスできること【NGKI0002】．</p>
</li>
<li>
<p>マルチプロセッサ対応カーネルにおいては，各プロセッサが同一の機械語
命令を実行できること【NGKI0003】．</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_想定するプログラミング言語">1.1.5. 想定するプログラミング言語</h4>
<div class="paragraph">
<p>この仕様におけるAPI仕様は，ISO/IEC 9899:1990（以下，C90と呼ぶ）または
ISO/IEC 9899:1999（以下，C99と呼ぶ）に準拠したC言語を，フリースタンディ
ング環境で用いることを想定して規定している【NGKI0004】．</p>
</div>
<div class="paragraph">
<p>ただし，C90の規定に加えて，以下のことを仮定している．</p>
</div>
<div class="ulist">
<ul>
<li>
<p>16ビットおよび32ビットの整数型があること【NGKI0005】</p>
</li>
<li>
<p>ポインタが格納できるサイズの整数型があること【NGKI0006】</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_apiの構成要素とコンベンション">1.2. APIの構成要素とコンベンション</h3>
<div class="sect3">
<h4 id="_apiの構成要素">1.2.1. APIの構成要素</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>サービスコール<br></p>
<div class="paragraph">
<p>上位階層のソフトウェアから，下位階層のソフトウェアを呼び出すインタフェー
スをサービスコール（service call）と呼ぶ．カーネルのサービスコールを，
システムコール（system call）と呼ぶ場合もある．</p>
</div>
</li>
<li>
<p>コールバック<br></p>
<div class="paragraph">
<p>下位階層のソフトウェアから，上位階層のソフトウェアを呼び出すインタフェー
スをコールバック（callback）と呼ぶ．</p>
</div>
</li>
<li>
<p>静的API<br></p>
<div class="paragraph">
<p>オブジェクトの生成情報や初期状態などを定義するために，システムコンフィ
ギュレーションファイル中に記述するインタフェースを，静的API（static
API）と呼ぶ．</p>
</div>
</li>
<li>
<p>構成マクロ<br></p>
<div class="paragraph">
<p>下位階層のソフトウェアに関する各種の情報を取り出すために，上位階層のソ
フトウェアが用いるマクロを，構成マクロ（configuration macro）と呼ぶ．</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_パラメータとリターンパラメータ">1.2.2. パラメータとリターンパラメータ</h4>
<div class="paragraph">
<p>サービスコールやコールバックに渡すデータをパラメータ（parameter），それ
らが返すデータをリターンパラメータ（return parameter）と呼ぶ．また，静
的APIに渡すデータもパラメータと呼ぶ．</p>
</div>
<div class="paragraph">
<p>オブジェクトを生成するサービスコールなど，パラメータの数が多い場合やター
ゲット定義のパラメータを追加する可能性がある場合には，複数のパラメータ
を1つの構造体に入れ，その領域へのポインタをパラメータとして渡す
【NGKI0007】．また，パラメータのサイズが大きい場合にも，パラメータを入
れた領域へのポインタをパラメータとして渡す場合がある【NGKI0008】．</p>
</div>
<div class="paragraph">
<p>C言語APIでは，リターンパラメータは，関数の返値とするか，リターンパラメー
タを入れる領域へのポインタをパラメータとして渡すことで実現する
【NGKI0009】．オブジェクトの状態を参照するサービスコールなど，リターン
パラメータの数が多い場合やターゲット定義のリターンパラメータを追加する
可能性がある場合には，複数のリターンパラメータを1つの構造体に入れて返す
こととし，その領域へのポインタをパラメータとして渡す【NGKI0010】．</p>
</div>
<div class="paragraph">
<p>複数のパラメータまたはリターンパラメータを入れるための構造体を，パケッ
ト（packet）と呼ぶ．</p>
</div>
<div class="paragraph">
<p>サービスコールやコールバックに，パケットを置く領域へのポインタやリター
ンパラメータを入れる領域へのポインタを渡す場合，別に規定がない限りは，
サービスコールやコールバックの処理が完了した後は，それらの領域が参照さ
れることはなく，別の目的に使用できる【NGKI0011】．</p>
</div>
</div>
<div class="sect3">
<h4 id="_返値とエラーコード">1.2.3. 返値とエラーコード</h4>
<div class="paragraph">
<p>一部の例外を除いて，サービスコールおよびコールバックの返値は，処理が正
常終了したかを表す符号付き整数とする．処理が正常終了した場合には，E_OK
（＝0）または正の値が返るものとし，値の意味はサービスコールまたはコール
バック毎に定める【NGKI0012】．処理が正常終了しなかった場合には，その原
因を表す負の値が返る【NGKI0013】．処理が正常終了しなかった原因を表す値
を，エラーコード（error code）と呼ぶ．</p>
</div>
<div class="paragraph">
<p>エラーコードは，いずれも負の値のメインエラーコードとサブエラーコードで
構成される【NGKI0014】．メインエラーコードとサブエラーコードからエラー
コードを構成するマクロ（ERCD）と，エラーコードからメインエラーコードを
取り出すマクロ（MERCD），サブエラーコードを取り出すマクロ（SERCD）が用
意されている【NGKI0015】．</p>
</div>
<div class="paragraph">
<p>メインエラーコードの名称・意味・値は，カーネルとシステムサービスで共通
に定める（「<a href="#toppers_errorcode">TOPPERS共通エラーコード</a>」の節を参照）【NGKI0016】．
サービスコールおよびコールバックの機能説明中の「E_XXXXXエラーとなる」ま
たは「E_XXXXXエラーが返る」という記述は，メインエラーコードとして
E_XXXXXが返ることを意味する．</p>
</div>
<div class="paragraph">
<p>サブエラーコードは，エラーの原因をより詳細に表すために用いる．カーネル
はサブエラーコードを使用せず，サブエラーコードとして常に-1が返る
【NGKI0017】．サブエラーコードの名称・意味・値は，サブエラーコードを使
用するシステムサービスのAPI仕様において規定する【NGKI0018】．</p>
</div>
<div class="paragraph">
<p>サービスコールが負の値のエラーコード（警告を表すものを除く）を返した場
合には，サービスコールによる副作用がないのが原則である【NGKI0019】．た
だし，そのような実装ができない場合にはこの原則の例外とし，サービスコー
ルの機能説明にその旨を記述する【NGKI0020】．</p>
</div>
<div class="paragraph">
<p>サービスコールが複数のエラーを検出するべき状況では，その内のいずれか1つ
のエラーを示すエラーコードが返る【NGKI0021】．</p>
</div>
<div class="paragraph">
<p>コールバックが複数のエラーを検出するべき状況では，その内のいずれか1つの
エラーを示すエラーコードを返せばよい【NGKI0022】．</p>
</div>
<div class="paragraph">
<p>なお，静的APIは返値を持たない．静的APIの処理でエラーが検出された場合の
扱いについては，「2.12.5 コンフィギュレータの処理モデル」の節および
「2.12.6 静的APIのパラメータに関するエラー検出」の節を参照すること．</p>
</div>
</div>
<div class="sect3">
<h4 id="_機能コード">1.2.4. 機能コード</h4>
<div class="paragraph">
<p>ソフトウェア割込みによりサービスコールを呼び出す場合などに用いるための
サービスコールを識別するための番号を，機能コード（function code）と呼ぶ．
機能コードは符号付きの整数値とし，カーネルのサービスコールには負の値を
割り付け，拡張サービスコールには正の値を用いる【NGKI0023】．</p>
</div>
</div>
<div class="sect3">
<h4 id="_ヘッダファイル">1.2.5. ヘッダファイル</h4>
<div class="paragraph">
<p>カーネルやシステムサービスを用いるために必要な定義を含むファイル．</p>
</div>
<div class="paragraph">
<p>ヘッダファイルは，原則として，複数回インクルードしてもエラーにならない
ように対処されている．具体的には，ヘッダファイルの先頭で特定の識別子
（例えば，kernel.hなら"TOPPERS_KERNEL_H"）がマクロ定義され，ヘッダファ
イルの内容全体をその識別子が定義されていない場合のみ有効とする条件ディ
レクティブが付加されている【NGKI0024】．</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_主な概念">1.3. 主な概念</h3>
<div class="sect3">
<h4 id="_オブジェクトと処理単位">1.3.1. オブジェクトと処理単位</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>オブジェクト<br></p>
<div class="paragraph">
<p>カーネルまたはシステムサービスが管理対象とするソフトウェア資源を，オブ
ジェクト（object）と呼ぶ．特に，カーネルが管理対象とするソフトウェア資
源を，カーネルオブジェクト（kernel object）と呼ぶ．</p>
</div>
<div class="paragraph">
<p>オブジェクトは，種類毎に，番号によって識別する【NGKI0025】．カーネルま
たはシステムサービスで，オブジェクトに対して任意に識別番号を付与できる
場合には，1から連続する正の整数値でオブジェクトを識別するのを原則とする
【NGKI0026】．この場合に，オブジェクトの識別番号を，オブジェクトのID番
号（ID number）と呼ぶ．そうでない場合，すなわちカーネルまたはシステムサー
ビスの内部または外部からの条件によって識別番号が決まる場合には，オブジェ
クトの識別番号を，オブジェクト番号（object number）と呼ぶ．識別する必要
のないオブジェクトには，識別番号を付与しない場合がある【NGKI0027】．</p>
</div>
<div class="paragraph">
<p>オブジェクト属性（object attribute）は，オブジェクトの動作モードや初期
状態を定めるもので，オブジェクトの登録時に指定する【NGKI0028】．オブジェ
クト属性にTA_XXXXが指定されている場合，そのオブジェクトを，TA_XXXX属性
のオブジェクトと呼ぶ．複数の属性を指定する場合には，オブジェクト属性を
渡すパラメータに，指定する属性値のビット毎論理和（C言語の"|"）を渡す
【NGKI0029】．また，指定すべきオブジェクト属性がない場合には，TA_NULLを
指定する【NGKI0030】．</p>
</div>
</li>
<li>
<p>処理単位<br></p>
<div class="paragraph">
<p>オブジェクトの中には，プログラムが対応付けられるものがある．プログラム
が対応付けられるオブジェクト（または，対応付けられるプログラム）を，処
理単位（processing unit）と呼ぶ．処理単位に対応付けられるプログラムは，
アプリケーションまたはシステムサービスで用意し，カーネルが実行制御する．</p>
</div>
<div class="paragraph">
<p>処理単位の実行を要求することを起動（activate），処理単位の実行を開始す
ることを実行開始（start）と呼ぶ．</p>
</div>
<div class="paragraph">
<p>拡張情報（extended information）は，処理単位が呼び出される時にパラメー
タとして渡される情報で，処理単位の登録時に指定する【NGKI0031】．拡張情
報は，カーネルやシステムサービスの動作には影響しない【NGKI0032】．</p>
</div>
</li>
<li>
<p>タスク<br></p>
<div class="paragraph">
<p>カーネルが実行順序を制御するプログラムの並行実行の単位をタスク（task）
と呼ぶ．タスクは，処理単位の1つである．</p>
</div>
<div class="paragraph">
<p>サービスコールの機能説明において，サービスコールを呼び出したタスクを，
自タスク（invoking task）と呼ぶ．拡張サービスコールからサービスコールを
呼び出した場合には，拡張サービスコールを呼び出したタスクが自タスクであ
る．</p>
</div>
<div class="paragraph">
<p>カーネルには，静的APIにより，少なくとも1つのタスクを登録しなければなら
ない．タスクが登録されていない場合には，コンフィギュレータがエラーを報
告する【NGKI0033】．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>タスクが呼び出した拡張サービスコールが実行されている間は，「サービスコー
ルを呼び出した処理単位」は拡張サービスコールであり，「自タスク」とは一
致しない．そのため，保護機能対応カーネルにおいて，「サービスコールを呼
び出した処理単位の属する保護ドメイン」と「自タスクの属する保護ドメイン」
は，異なるものを指す．</p>
</div>
</li>
<li>
<p>ディスパッチとスケジューリング<br></p>
<div class="paragraph">
<p>プロセッサが実行するタスクを切り換えることを，タスクディスパッチまたは
単にディスパッチ（dispatching）と呼ぶ．それに対して，次に実行すべきタス
クを決定する処理を，タスクスケジューリングまたは単にスケジューリング
（scheduling）と呼ぶ．</p>
</div>
<div class="paragraph">
<p>ディスパッチが起こるべき状態（すなわち，スケジューリングによって，現在
実行しているタスクとは異なるタスクが，実行すべきタスクに決定されている
状態）となっても，何らかの理由でディスパッチを行わないことを，ディスパッ
チの保留（pend dispatching）という．ディスパッチを行わない理由が解除さ
れた時点で，ディスパッチが起こる【NGKI0034】．</p>
</div>
</li>
<li>
<p>割込みとCPU例外<br></p>
<div class="paragraph">
<p>プロセッサが実行中の処理とは独立に発生するイベントによって起動される例
外処理のことを，外部割込みまたは単に割込み（interrupt）と呼ぶ．それに対
して，プロセッサが実行中の処理に依存して起動される例外処理を，CPU例外
（CPU exception）と呼ぶ．</p>
</div>
<div class="paragraph">
<p>周辺デバイスからの割込み要求をプロセッサに伝える経路を遮断し，割込み要
求が受け付けられるのを抑止することを，割込みのマスク（mask interrupt）
または割込みの禁止（disable interrupt）という．マスクが解除された時点で，
まだ割込み要求が保持されていれば，その時点で割込み要求を受け付ける
【NGKI0035】．</p>
</div>
<div class="paragraph">
<p>マスクすることができない割込みを，NMI（non-maskable interrupt）と呼ぶ．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>μITRON4.0仕様において，未定義のまま使われていた割込みとCPU例外という用
語を定義した．</p>
</div>
</li>
<li>
<p>タイムイベントとタイムイベントハンドラ<br></p>
<div class="paragraph">
<p>時間の経過をきっかけに発生するイベントをタイムイベント（time event）と
呼ぶ．タイムイベントにより起動され，カーネルが実行制御する処理単位を，
タイムイベントハンドラ（time event handler）と呼ぶ．</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_サービスコールとパラメータ">1.3.2. サービスコールとパラメータ</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>優先順位と優先度<br></p>
<div class="paragraph">
<p>優先順位（precedence）とは，処理単位の実行順序を説明するための仕様上の
概念である．複数の処理単位が実行できる場合には，その中で最も優先順位の
高い処理単位が実行される【NGKI0036】．</p>
</div>
<div class="paragraph">
<p>優先度（priority）は，タスクなどの処理単位の優先順位や，メッセージなど
の配送順序を決定するために，アプリケーションが処理単位やメッセージなど
に与える値である．優先度は，符号付きの整数型であるPRI型で表し，1から連
続した正の値を用いるのを原則とする【NGKI0037】．優先度は，値が小さいほ
ど優先度が高い（すなわち，先に実行または配送される）ものとする
【NGKI0038】．</p>
</div>
</li>
<li>
<p>システム時刻と相対時間<br></p>
<div class="paragraph">
<p>カーネルが管理する時刻を，システム時刻（system time）と呼ぶ．システム時
刻は，符号無しの整数型であるSYSTIM型で表し，単位はミリ秒とする
【NGKI0039】．システム時刻は，タイムティック（time tick）を通知するため
のタイマ割込みが発生する毎に更新される【NGKI0040】．</p>
</div>
<div class="paragraph">
<p>イベントを発生させる時刻を指定する場合には，基準時刻（base time）からの
相対時間（relative time）によって指定する【NGKI0041】．基準時刻は，別に
規定がない限りは，相対時間を指定するサービスコールを呼び出した時刻とな
る【NGKI0042】．</p>
</div>
<div class="paragraph">
<p>相対時間は，符号無しの整数型であるRELTIM型で表し，単位はシステム時刻と
同一，すなわちミリ秒とする【NGKI0043】．相対時間には，少なくとも，16ビッ
トの符号無しの整数型（uint16_t型）に格納できる任意の値を指定することが
できるが，RELTIM型（uint_t型に定義される）に格納できる任意の値を指定で
きるとは限らない【NGKI0044】．相対時間に指定できる最大値は，構成マクロ
TMAX_RELTIMに定義されている【NGKI0045】．</p>
</div>
<div class="paragraph">
<p>イベントを発生させる時刻を相対時間で指定した場合，イベントの処理が行わ
れるのは，基準時刻から相対時間によって指定した以上の時間が経過した後と
なる【NGKI0046】．ただし，基準時刻を定めるサービスコールを呼び出した時
に，タイムティックを通知するためのタイマ割込みがマスクされている場合
（タイマ割込みより優先して実行される割込み処理が実行されている場合を含
む）は，相対時間によって指定した以上の時間が経過した後となることは保証
されない【NGKI0047】．</p>
</div>
<div class="paragraph">
<p>イベントが発生する時刻を参照する場合には，基準時刻からの相対時間として
返される【NGKI0048】．基準時刻は，相対時間を返すサービスコールを呼び出
した時刻となる【NGKI0049】．</p>
</div>
<div class="paragraph">
<p>イベントが発生する時刻が相対時間で返された場合，イベントの処理が行われ
るのは，基準時刻から相対時間として返された以上の時間が経過した後となる
【NGKI0050】．ただし，相対時間を返すサービスコールを呼び出した時に，タ
イムティックを通知するためのタイマ割込みがマスクされている場合（タイマ
割込みより優先して実行される割込み処理が実行されている場合を含む）は，
相対時間として返された以上の時間が経過した後となることは保証されない
【NGKI0051】．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>相対時間に0を指定した場合，基準時刻後の最初のタイムティックでイベントの
処理が行われる．また，1を指定した場合，基準時刻後の2回目以降のタイム
ティックでイベントの処理が行われる．これは，基準時刻後の最初のタイム
ティックは，基準時刻の直後に発生する可能性があるため，ここでイベントの
処理を行うと，基準時刻からの経過時間が1以上という仕様を満たせないためで
ある．</p>
</div>
<div class="paragraph">
<p>同様に，相対時間として0が返された場合，基準時刻後の最初のタイムティック
でイベントの処理が行われる．また，1が返された場合，基準時刻後の2回目以
降のタイムティックでイベントの処理が行われる．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>相対時間（RELTIM型）とシステム時刻（SYSTIM型）の時間単位は，μITRON4.0
仕様では実装定義としていたが，この仕様ではミリ秒と規定した．また，相対
時間の解釈について，より厳密に規定した．</p>
</div>
<div class="paragraph">
<p>TMAX_RELTIMは，μITRON4.0仕様に規定されていないカーネル構成マクロである．</p>
</div>
</li>
<li>
<p>タイムアウトとポーリング<br></p>
<div class="paragraph">
<p>サービスコールの中で待ち状態が指定した時間以上継続した場合に，サービス
コールの処理を取りやめて，サービスコールからリターンすることを，タイム
アウト（timeout）という．タイムアウトしたサービスコールからは，E_TMOUT
エラーが返る【NGKI0052】．</p>
</div>
<div class="paragraph">
<p>タイムアウトを起こすまでの時間（タイムアウト時間）は，符号付きの整数型
であるTMO型で表し，単位はシステム時刻と同一，すなわちミリ秒とする
【NGKI0053】．タイムアウト時間に正の値を指定した場合には，タイムアウト
を起こすまでの相対時間を表す【NGKI0054】．すなわち，タイムアウトの処理
が行われるのは，サービスコールを呼び出してから指定した以上の時間が経過
した後となる．</p>
</div>
<div class="paragraph">
<p>ポーリング（polling）を行うサービスコールとは，サービスコールの中で待ち
状態に遷移すべき状況になった場合に，サービスコールの処理を取りやめてリ
ターンするサービスコールのことをいう．ここで，サービスコールの処理を取
りやめてリターンすることを，ポーリングに失敗したという．ポーリングに失
敗したサービスコールからは，E_TMOUTエラーが返る【NGKI0055】．</p>
</div>
<div class="paragraph">
<p>ポーリングを行うサービスコールでは，待ち状態に遷移することはないのが原
則である【NGKI0056】．そのため，ポーリングを行うサービスコールは，ディ
スパッチ保留状態であっても呼び出せる【NGKI0057】．ただし，サービスコー
ルの中で待ち状態に遷移する状況が複数ある場合，ある状況でポーリング動作
をしても，他の状況では待ち状態に遷移する場合がある．このような場合の振
舞いは，該当するサービスコール毎に規定する【NGKI0058】．</p>
</div>
<div class="paragraph">
<p>タイムアウト付きのサービスコールは，別に規定がない限りは，タイムアウト
時間にTMO_POL（＝0）を指定した場合にはポーリングを行い，TMO_FEVR（＝-1）
を指定した場合にはタイムアウトを起こさないものとする【NGKI0059】．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>［NGKI0019］の原則より，サービスコールがタイムアウトした場合やポーリン
グに失敗した場合には，サービスコールによる副作用がないのが原則である．
ただし，そのような実装ができない場合にはこの原則の例外とし，どのような
副作用があるかをサービスコール毎に規定する．</p>
</div>
<div class="paragraph">
<p>タイムアウト付きのサービスコールを，タイムアウト時間をTMO_POLとして呼び
出した場合には，ディスパッチ保留状態で呼び出すとE_CTXエラーとなることを
除いては，ポーリングを行うサービスコールと同じ振舞いをする．また，タイ
ムアウト時間をTMO_FEVRとして呼び出した場合には，タイムアウトなしのサー
ビスコールと全く同じ振舞いをする．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>タイムアウト時間（TMO型）の時間単位は，μITRON4.0仕様では実装定義として
いたが，この仕様ではミリ秒と規定した．</p>
</div>
<div class="paragraph">
<p>【仕様決定の理由】</p>
</div>
<div class="paragraph">
<p>ディスパッチ保留状態において，ポーリングを行うサービスコールを呼び出せ
る場合があるのに対して，タイムアウト付きのサービスコールをタイムアウト
時間をTMO_POLとして呼び出すとエラーになるのは，割込み優先度マスクが全解
除でない状態やディスパッチ禁止状態では，自タスクを広義の待ち状態に遷移
させる可能性のあるサービスコール（タイムアウト付きのサービスコールはこ
れに該当）を呼び出すことはできないという原則［NGKI0175］と［NGKI0179］
があるためである．</p>
</div>
</li>
<li>
<p>ノンブロッキング<br></p>
<div class="paragraph">
<p>サービスコールの中で待ち状態に遷移すべき状況になった時，サービスコール
の処理を継続したままサービスコールからリターンする場合，そのサービスコー
ルをノンブロッキング（non-blocking）という．処理を継続したままリターン
する場合，サービスコールからはE_WBLKエラーが返る【NGKI0060】．E_WBLKは
警告を表すエラーコードであり，サービスコールによる副作用がないという原
則は適用されない【NGKI0061】．</p>
</div>
<div class="paragraph">
<p>サービスコールからE_WBLKエラーが返った場合には，サービスコールの処理は
継続しているため，サービスコールに渡したパラメータまたはリターンパラメー
タを入れる領域はまだ参照される可能性があり，別の目的に使用することはで
きない【NGKI0062】．継続している処理が完了した場合や，何らかの理由で処
理が取りやめられた場合には，コールバックを呼び出すなどの方法で，サービ
スコールを呼び出したソフトウェアに通知するものとする【NGKI0063】．</p>
</div>
<div class="paragraph">
<p>ノンブロッキングの指定は，タイムアウト時間にTMO_NBLK（＝-2）を指定する
ことによって行う【NGKI0064】．ノンブロッキングの指定を行えるサービスコー
ルは，指定した場合の振舞いをサービスコール毎に規定する【NGKI0065】．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>ノンブロッキングは，システムサービスでサポートすることを想定した機能で
ある．カーネルは，ノンブロッキングの指定を行えるサービスコールをサポー
トしていない．</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_保護機能">1.3.3. 保護機能</h4>
<div class="paragraph">
<p>この節では，保護機能に関連する主な概念について説明する．この節の内容は，
保護機能対応カーネルにのみ適用される．</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>アクセス保護<br></p>
<div class="paragraph">
<p>保護機能対応カーネルは，処理単位が，許可されたカーネルオブジェクトに対
して，許可された種別のアクセスを行うことのみを許し，それ以外のアクセス
を防ぐアクセス保護機能を提供する【NGKI0066】．</p>
</div>
<div class="paragraph">
<p>アクセス制御の用語では，処理単位が主体（subject），カーネルオブジェクト
が対象（object）ということになる．</p>
</div>
</li>
<li>
<p>メモリオブジェクト<br></p>
<div class="paragraph">
<p>保護機能対応カーネルにおいては，メモリ領域をカーネルオブジェクトとして
扱い，アクセス保護の対象とする【NGKI0067】．カーネルがアクセス保護の対
象とする連続したメモリ領域を，メモリオブジェクト（memory object）と呼ぶ．
メモリオブジェクトは，互いに重なりあうことはない【NGKI0068】．</p>
</div>
<div class="paragraph">
<p>メモリオブジェクトは，その先頭番地によって識別する【NGKI0069】．言い換
えると，先頭番地がオブジェクト番号となる．</p>
</div>
<div class="paragraph">
<p>メモリオブジェクトの先頭番地とサイズには，ターゲットハードウェアでメモ
リ保護が実現できるように，ターゲット定義の制約が課せられる【NGKI0070】．</p>
</div>
</li>
<li>
<p>保護ドメイン<br></p>
<div class="paragraph">
<p>保護機能を提供するために用いるカーネルオブジェクトの集合を，保護ドメイ
ン（protection domain）と呼ぶ．保護ドメインは，保護ドメインIDと呼ぶID番
号によって識別する【NGKI0071】．</p>
</div>
<div class="paragraph">
<p>カーネルオブジェクトは，たかだか1つの保護ドメインに属する．処理単位は，
いずれか1つの保護ドメインに属さなければならないのに対して，それ以外のカー
ネルオブジェクトは，いずれの保護ドメインにも属さないことができる
【NGKI0072】．いずれの保護ドメインにも属さないカーネルオブジェクトを，
無所属のカーネルオブジェクト（independent kernel object）と呼ぶ．</p>
</div>
<div class="paragraph">
<p>処理単位がカーネルオブジェクトにアクセスできるかどうかは，処理単位が属
する保護ドメインにより決まるのが原則である【NGKI0073】．すなわち，カー
ネルオブジェクトに対するアクセス権は，処理単位ではなく，保護ドメイン単
位で管理される．このことから，ある保護ドメインに属する処理単位がアクセ
スできることを，単に，その保護ドメインからアクセスできるという．</p>
</div>
<div class="paragraph">
<p>ただし，タスクのユーザスタック領域は，ターゲット定義での変更がない限り
は，そのタスク（とカーネルドメインに属する処理単位）のみがアクセスでき
る（「2.11.6 ユーザタスクのユーザスタック領域」の節を参照）【NGKI0074】．
これは，［NGKI0073］の原則の例外となっている．</p>
</div>
<div class="paragraph">
<p>デフォルトでは，保護ドメインに属するカーネルオブジェクトは，同じ保護ド
メイン（とカーネルドメイン）のみからアクセスできる【NGKI0075】．また，
無所属のカーネルオブジェクトは，すべての保護ドメインからアクセスできる
【NGKI0076】．</p>
</div>
</li>
<li>
<p>カーネルドメインとユーザドメイン<br></p>
<div class="paragraph">
<p>システムには，カーネルドメイン（kernel domain）と呼ばれる保護ドメインが
1つ存在する【NGKI0077】．カーネルドメインに属する処理単位は，プロセッサ
の特権モードで実行される【NGKI0078】．また，すべてのカーネルオブジェク
トに対して，すべての種別のアクセスを行うことが許可される【NGKI0079】．
この仕様で，「ある保護ドメイン（またはタスク）のみからアクセスできる」
といった場合でも，カーネルドメインドメインからはアクセスすることができ
る．</p>
</div>
<div class="paragraph">
<p>カーネルドメイン以外の保護ドメインを，ユーザドメイン（user domain）と呼
ぶ．ユーザドメインに属する処理単位は，プロセッサの非特権モードで実行さ
れる【NGKI0080】．また，どのカーネルオブジェクトに対してどの種別のアク
セスを行えるかを制限することができる【NGKI0081】．</p>
</div>
<div class="paragraph">
<p>ユーザドメインには，1から連続する正の整数値の保護ドメインIDが付与される
【NGKI0082】．カーネルドメインの保護ドメインIDは，TDOM_KERNEL（＝-1）で
ある【NGKI0083】．</p>
</div>
<div class="paragraph">
<p>この仕様では，システムに登録できるユーザドメインの数は，32個以下に制限
する【NGKI0084】．これを超える数のユーザドメインを登録した場合には，コ
ンフィギュレータがエラーを報告する【NGKI0085】．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>ユーザドメインは，システムコンフィギュレーションファイル中にユーザドメ
インの囲みを記述することで，カーネルに登録する（「2.12.3 保護ドメインの
指定」の節を参照）．ユーザドメインを動的に生成する機能は，現時点では用
意していない．</p>
</div>
<div class="paragraph">
<p>保護機能対応でないカーネルは，カーネルドメインのみをサポートしていると
みなすこともできる．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0/PX仕様との関係】</p>
</div>
<div class="paragraph">
<p>μITRON4.0/PX仕様のシステムドメイン（system domain）は，現時点ではサポー
トしない．システムドメインは，それに属する処理単位が，プロセッサの特権
モードで実行され，カーネルオブジェクトに対するアクセスを制限することが
できる保護ドメインである．</p>
</div>
</li>
<li>
<p>システムタスクとユーザタスク<br></p>
<div class="paragraph">
<p>カーネルドメインに属するタスクをシステムタスク（system task），ユーザド
メインに属するタスクをユーザタスク（user task）と呼ぶ．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>特権モードで実行されるタスクをシステムタスク，非特権モードで実行される
タスクをユーザタスクと定義する方法もあるが，ユーザタスクであっても，サー
ビスコールの実行中は特権モードで実行されるため，上記の定義とした．</p>
</div>
<div class="paragraph">
<p>μITRON4.0/PX仕様のシステムドメインに属するタスクは，システムタスクと呼
ぶことになる．</p>
</div>
</li>
<li>
<p>アクセス許可パターン<br></p>
<div class="paragraph">
<p>あるカーネルオブジェクトに対するある種別のアクセスが，どの保護ドメイン
に属する処理単位に許可されているかを表現するビットパターンを，アクセス
許可パターン（access permission pattern）と呼ぶ．アクセス許可パターンの
各ビットは，1つのユーザドメインに対応する【NGKI0086】．カーネルドメイン
には，すべてのアクセスが許可されているため，カーネルドメインに対応する
ビットは用意されていない．</p>
</div>
<div class="paragraph">
<p>アクセス許可パターンは，符号無し32ビット整数に定義されるデータ型
（ACPTN）で保持し，値が1のビットに対応するユーザドメインにアクセスが許
可されていることを表す【NGKI0087】．そのため，2つのアクセス許可パターン
のビット毎論理和（C言語の"|"）を求めることで，アクセスを許可されている
ユーザドメインの和集合（union）を得ることができる．また，2つのアクセス
許可パターンのビット毎論理積（C言語の"&amp;"）を求めることで，アクセスを許
可されているユーザドメインの積集合（intersection）を得ることができる．</p>
</div>
<div class="paragraph">
<p>アクセス許可パターンの指定に用いるために，指定したユーザドメインのみに
アクセスを許可することを示すアクセス許可パターンを構成するマクロ（TACP）
が用意されている【NGKI0088】．また，カーネルドメインのみにアクセスを許
可することを示すアクセス許可パターンを表す定数（TACP_KERNEL）と，すべて
の保護ドメインにアクセスを許可することを示すアクセス許可パターンを表す
定数（TACP_SHARED）が用意されている【NGKI0089】．</p>
</div>
</li>
<li>
<p>アクセス許可ベクタ<br></p>
<div class="paragraph">
<p>カーネルオブジェクトに対するアクセスは，カーネルオブジェクトの種類毎に，
通常操作1，通常操作2，管理操作，参照操作の4つの種別に分類されている
【NGKI0090】．あるカーネルオブジェクトに対する4つの種別のアクセスに関す
るアクセス許可パターンをひとまとめにしたものを，アクセス許可ベクタ
（access permission vector）と呼び，次のように定義されるデータ型
（ACVCT）で保持する【NGKI0091】．</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">	typedef struct acvct {
		ACPTN	acptn1;		/* 通常操作1のアクセス許可パターン */
		ACPTN	acptn2;		/* 通常操作2のアクセス許可パターン */
		ACPTN	acptn3;		/* 管理操作のアクセス許可パターン */
		ACPTN	acptn4;		/* 参照操作のアクセス許可パターン */
	} ACVCT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>カーネルオブジェクトの種類毎のアクセスの種別の分類については，「5.8 カー
ネルオブジェクトに対するアクセスの種別」の節を参照すること．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0/PX仕様との関係】</p>
</div>
<div class="paragraph">
<p>μITRON4.0/PX仕様では，アクセス許可ベクタを，1つまたは2つのアクセス許可
パターンで構成することも許しているが，この仕様では4つで構成するものと決
めている．</p>
</div>
</li>
<li>
<p>サービスコールの呼出し方法<br></p>
<div class="paragraph">
<p>保護機能対応カーネルでは，サービスコールは，ソフトウェア割込みによって
呼び出すのが基本である．サービスコール呼出しを通常の方法で記述した場合，
ソフトウェア割込みによって呼び出すコードが生成される【NGKI0092】．</p>
</div>
<div class="paragraph">
<p>一般に，ソフトウェア割込みによるサービスコール呼出しはオーバヘッドが大
きい．そのため，カーネルドメインに属する処理単位からは，関数呼出しによっ
てサービスコールを呼び出すことで，オーバヘッドを削減することができる．
そこで，カーネルドメインに属する処理単位から関数呼出しによってサービス
コールを呼び出せるように，以下の機能が用意されている．</p>
</div>
<div class="paragraph">
<p>カーネルドメインに属する処理単位が実行する関数のみを含んだソースファイ
ルでは，カーネルヘッダファイル（kernel.h）をインクルードする前に，
TOPPERS_SVC_CALLをマクロ定義することで，サービスコール呼出しを通常の方
法で記述した場合に，関数呼出しによって呼び出すコードが生成される
【NGKI0093】．</p>
</div>
<div class="paragraph">
<p>また，カーネルドメインに属する処理単位が実行する関数と，ユーザドメイン
に属する処理単位が実行する関数の両方を含んだソースファイルでは，関数呼
出しによってサービスコールを呼び出すための名称を作るマクロ（SVC_CALL）
を用いることで，関数呼出しによって呼び出すコードが生成される
【NGKI0094】．例えば，act_tskを関数呼出しによって呼び出す場合には，次の
ように記述すればよい．</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">	ercd = SVC_CALL(act_tsk)(tskid);</code></pre>
</div>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>拡張サービスコールを，関数呼出しによって呼び出す方法は用意されていない．
カーネルドメインに属する処理単位が，関数呼出しによって，拡張サービスコー
ルとして登録した関数を呼び出すことはできるが，その場合には，処理単位が
呼び出した通常の関数であるとみなされ，拡張サービスコールであるとは扱わ
れない．</p>
</div>
</li>
<li>
<p>ユーザドメインから行える処理に対する制限<br></p>
<div class="paragraph">
<p>ユーザドメインに属する処理単位が，システムの重要な処理に悪影響を及ぼす
のを防ぐために，ユーザドメインから行える処理に対して制限を設ける機能が
用意されている．具体的には，ユーザドメインに属する処理単位が，タスクの
ベース優先度を変更する際に，指定できるタスク優先度を制限することができ
る．</p>
</div>
<div class="paragraph">
<p>この機能を実現するために，各ユーザドメインは次の情報を持つ【NGKI0531】．</p>
</div>
<div class="ulist">
<ul>
<li>
<p>指定できる最高のタスク優先度</p>
<div class="paragraph">
<p>なお，カーネルドメインに対しては，制限を設ける機能を用意していない．す
なわち，カーネルドメインに属する処理単位は，すべてのタスク優先度を使う
ことができる【NGKI0532】．</p>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_マルチプロセッサ対応">1.3.4. マルチプロセッサ対応</h4>
<div class="paragraph">
<p>この節では，マルチプロセッサ対応に関連する主な概念について説明する．こ
の節の内容は，マルチプロセッサ対応カーネルにのみ適用される．</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>クラス<br></p>
<div class="paragraph">
<p>マルチプロセッサに対応するために用いるカーネルオブジェクトの集合を，ク
ラス（class）と呼ぶ．クラスは，クラスIDと呼ぶID番号によって識別する
【NGKI0095】．</p>
</div>
<div class="paragraph">
<p>カーネルオブジェクトは，いずれか1つのクラスに属するのが原則である
【NGKI0096】．カーネルオブジェクトが属するクラスは，オブジェクトの登録
時に決定し，登録後に変更することはできない【NGKI0097】．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>処理単位を実行するプロセッサを静的に決定する機能分散型のマルチプロセッ
サシステムでは，プロセッサ毎にクラスを設ける方法が典型的である．それに
対して，対称型のマルチプロセッサシステムで，処理単位のマイグレーション
を許す場合には，プロセッサ毎のクラスに加えて，どのプロセッサでも実行で
きるクラスを（システム中に1つまたは初期割付けプロセッサ毎に）設ける方法
が典型的である．</p>
</div>
<div class="paragraph">
<p>［NGKI0096］の原則に関わらず，以下のオブジェクトはいずれのクラスにも属
さない．</p>
</div>
<div class="ulist">
<ul>
<li>
<p>オーバランハンドラ</p>
</li>
<li>
<p>拡張サービスコール</p>
</li>
<li>
<p>グローバル初期化ルーチン</p>
</li>
<li>
<p>グローバル終了処理ルーチン</p>
<div class="paragraph">
<p>マルチプロセッサ対応でないカーネルは，カーネルによって規定された1つのク
ラスのみをサポートしているとみなすこともできる．</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>プロセッサ<br></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>たかだか1つの処理単位のみを同時に実行できるハードウェアの単位を，プロセッ
サ（processor）と呼ぶ．プロセッサは，プロセッサIDと呼ぶID番号によって識
別する【NGKI0098】．</p>
</div>
<div class="paragraph">
<p>+
複数のプロセッサを持つシステム構成をマルチプロセッサ（multiprocessor）
と呼び，同時に複数の処理単位を実行することができる【NGKI0099】．</p>
</div>
<div class="paragraph">
<p>+
システムの初期化時と終了時に特別な役割を果たすプロセッサを，マスタプロ
セッサ（master processor）と呼び，システムに1つ存在する【NGKI0100】．ど
のプロセッサをマスタプロセッサとするかは，ターゲット定義である
【NGKI0101】．マスタプロセッサ以外のプロセッサを，スレーブプロセッサ
（slave processor）と呼ぶ．なお，カーネル動作状態では，マスタプロセッサ
とスレーブプロセッサの振舞いに違いはない【NGKI0102】．</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>処理単位の割付けとマイグレーション<br></p>
<div class="paragraph">
<p>処理単位は，後述のマイグレーションが発生しない限りは，いずれか1つのプロ
セッサに割り付けられて実行される【NGKI0103】．処理単位を実行するプロセッ
サを，割付けプロセッサと呼ぶ．また，処理単位が登録時に割り付けられるプ
ロセッサを，初期割付けプロセッサと呼ぶ．</p>
</div>
<div class="paragraph">
<p>処理単位によっては，処理単位の登録後に，割付けプロセッサを変更すること
が可能である【NGKI0104】．処理単位の登録後に割付けプロセッサを変更する
ことを，処理単位のマイグレーション（migration）と呼ぶ．</p>
</div>
<div class="paragraph">
<p>割付けプロセッサを変更できる処理単位に対しては，処理単位を割り付けるこ
とができるプロセッサ（これを，割付け可能プロセッサと呼ぶ）を制限するこ
とができる【NGKI0105】．</p>
</div>
</li>
<li>
<p>クラスの持つ属性とカーネルオブジェクト<br></p>
<div class="paragraph">
<p>タスクの初期割付けプロセッサや割付け可能プロセッサなど，カーネルオブジェ
クトをマルチプロセッサ上で実現する際に設定すべき属性は，そのカーネルオ
ブジェクトが属するクラスによって定まる．</p>
</div>
<div class="paragraph">
<p>各クラスが持ち，それに属するカーネルオブジェクトに適用される属性は，次
の通りである【NGKI0106】．</p>
</div>
<div class="ulist">
<ul>
<li>
<p>初期割付けプロセッサ</p>
</li>
<li>
<p>割付け可能プロセッサ（複数のプロセッサを指定可能，初期割付けプロセッサを含む）</p>
</li>
<li>
<p>ATT_MOD／ATA_MODによって，オブジェクトモジュールに含まれる標準のセクションがされるメモリリージョン（標準メモリリージョン）</p>
</li>
<li>
<p>オブジェクト生成に必要なメモリ領域（オブジェクトの管理ブロック，タスクのスタックやデータキューのデータキュー管理領域など）の配置場所</p>
</li>
<li>
<p>その他の管理情報（ロック単位など）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用できるクラスのID番号とその属性は，ターゲット定義である【NGKI0107】．</p>
</div>
<div class="paragraph">
<p>【仕様決定の理由】</p>
</div>
<div class="paragraph">
<p>クラスを導入することで，カーネルオブジェクト毎に上記の属性を設定できる
ようにしなかったのは，これらの属性をアプリケーション設計者が個別に設定
するよりも，ターゲット依存部の実装者が有益な組み合わせをあらかじめ用意
しておく方が良いと考えたためである．</p>
</div>
</li>
<li>
<p>ローカルタイマ方式とグローバルタイマ方式<br></p>
<div class="paragraph">
<p>システム時刻の管理方式として，プロセッサ毎にシステム時刻を持つローカル
タイマ方式と，システム全体で1つのシステム時刻を持つグローバルタイマ方式
の2つの方式がある．どちらの方式を用いることができるかは，ターゲット定義
である【NGKI0108】．</p>
</div>
<div class="paragraph">
<p>ローカルタイマ方式では，プロセッサ毎のシステム時刻は，それぞれのプロセッ
サが更新する【NGKI0109】．異なるプロセッサのシステム時刻を同期させる機
能は，カーネルでは用意しない．</p>
</div>
<div class="paragraph">
<p>グローバルタイマ方式では，システム中の1つのプロセッサがシステム時刻を更
新する【NGKI0110】．これを，システム時刻管理プロセッサと呼ぶ．どのプロ
セッサをシステム時刻管理プロセッサとするかは，ターゲット定義である
【NGKI0111】．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>システム時刻管理プロセッサが，マスタプロセッサと一致している必要はない．</p>
</div>
<div class="paragraph">
<p>【未決定事項】</p>
</div>
<div class="paragraph">
<p>ローカルタイマ方式の場合に，プロセッサ毎に異なるタイムティックの周期を
設定したい場合が考えられるが，現時点の実装ではサポートしておらず，
TIC_NUMEとTIC_DENOの扱いも未決定であるため，今後の課題とする．</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_その他">1.3.5. その他</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>オブジェクトモジュール<br></p>
<div class="paragraph">
<p>プログラムのオブジェクトコードとデータを含むファイルを，オブジェクトモ
ジュール（object module）と呼ぶ．オブジェクトファイルとライブラリは，オ
ブジェクトモジュールである．</p>
</div>
</li>
<li>
<p>メモリリージョン<br></p>
<div class="paragraph">
<p>オブジェクトモジュールに含まれるセクションの配置対象となる同じ性質を持っ
た連続したメモリ領域をメモリリージョン（memory region）と呼ぶ．</p>
</div>
<div class="paragraph">
<p>メモリリージョンは，文字列によって識別する【NGKI0112】．メモリリージョ
ンを識別する文字列を，メモリリージョン名と呼ぶ．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>この仕様では，メモリ領域（memory area）という用語は，連続したメモリの範
囲という一般的な意味で使っている．</p>
</div>
</li>
<li>
<p>標準のセクション<br></p>
<div class="paragraph">
<p>コンパイラに特別な指定をしない場合に出力するセクションを，標準のセクショ
ン（standard sections）と呼ぶ．コンパイラが出力しないセクションの中で，
ターゲット定義のものを，標準のセクションと扱う場合もある【NGKI0113】．</p>
</div>
</li>
<li>
<p>保護ドメイン毎の標準セクション<br></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>保護機能対応カーネルにおいては，保護ドメイン毎に，標準のセクションを配
置するためのセクションが登録される【NGKI0114】．また，無所属の標準のセ
クションを配置するためのセクションが登録される【NGKI0115】．これらのセ
クションを，保護ドメイン毎の標準セクションと呼ぶ（standards
for each protection domain）．保護ドメイン毎の標準セクションのセクショ
ン名は，ターゲット定義で別に規定がない限りは，標準のセクション名と保護
ドメイン名（カーネルドメインの場合は"kernel"，無所属の場合は"shared"）
を"_"でつないだものとする【NGKI0116】．例えば，カーネルドメインの
".text"セクションのセクション名は，".text_kernel" とする．</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_処理単位の種類と実行順序">1.4. 処理単位の種類と実行順序</h3>
<div class="sect3">
<h4 id="_処理単位の種類">1.4.1. 処理単位の種類</h4>
<div class="paragraph">
<p>カーネルが実行を制御する処理単位の種類は次の通りである【NGKI0117】．</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(a) タスク
	(a.1) タスク例外処理ルーチン
(b) 割込みハンドラ
	(b.1) 割込みサービスルーチン
	(b.2) タイムイベントハンドラ
(c) CPU例外ハンドラ
(d) 拡張サービスコール
(e) 初期化ルーチン
(f) 終了処理ルーチン</pre>
</div>
</div>
<div class="paragraph">
<p>ここで，タイムイベントハンドラとは，時間の経過をきっかけに起動される処
理単位である周期ハンドラ，アラームハンドラ，オーバランハンドラの総称で
ある．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/ASPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>ASPカーネルでは，オーバランハンドラと拡張サービスコールをサポートしてい
ない【ASPS0003】．ただし，オーバランハンドラ機能拡張パッケージを用いる
と，オーバランハンドラ機能を追加することができる【ASPS0004】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/FMPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>FMPカーネルでは，オーバランハンドラと拡張サービスコールをサポートしてい
ない【FMPS0002】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/SSPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>SSPカーネルでは，タスク例外処理ルーチン，タイムイベントハンドラ，拡張サー
ビスコールをサポートしていない【SSPS0002】．</p>
</div>
</div>
<div class="sect3">
<h4 id="_処理単位の実行順序">1.4.2. 処理単位の実行順序</h4>
<div class="paragraph">
<p>処理単位の実行順序を規定するために，ここでは，処理単位の優先順位を規定
する．また，ディスパッチが起こるタイミングを規定するために，ディスパッ
チを行うカーネル内の処理であるディスパッチャの優先順位についても規定す
る．</p>
</div>
<div class="paragraph">
<p>タスクの優先順位は，ディスパッチャの優先順位よりも低い【NGKI0118】．タ
スク間では，高い優先度を持つ方が優先順位が高く，同じ優先度を持つタスク
間では，先に実行できる状態となった方が優先順位が高い【NGKI0119】．詳し
くは，「2.6.3 タスクのスケジューリング規則」の節を参照すること．</p>
</div>
<div class="paragraph">
<p>タスク例外処理ルーチンの優先順位は，例外が要求されたタスクと同じである
が，タスクよりも先に実行される【NGKI0120】．</p>
</div>
<div class="paragraph">
<p>割込みハンドラの優先順位は，ディスパッチャの優先順位よりも高い
【NGKI0121】．割込みハンドラ間では，高い割込み優先度を持つ方が優先順位
が高く，同じ割込み優先度を持つ割込みハンドラ間では，先に実行開始された
方が優先順位が高い【NGKI0122】．同じ割込み優先度を持つ割込みハンドラ間
での実行開始順序は，この仕様では規定しない．詳しくは，「2.7.2 割込み優
先度」の節を参照すること．</p>
</div>
<div class="paragraph">
<p>割込みサービスルーチンとタイムイベントハンドラの優先順位は，それを呼び
出す割込みハンドラと同じである【NGKI0123】．</p>
</div>
<div class="paragraph">
<p>CPU例外ハンドラの優先順位は，CPU例外がタスクまたはタスク例外処理ルーチ
ンで発生した場合には，ディスパッチャの優先順位と同じであるが，ディスパッ
チャよりも先に実行される【NGKI0124】．CPU例外がその他の処理単位で発生し
た場合には，CPU例外ハンドラの優先順位は，その処理単位の優先順位と同じで
あるが，その処理単位よりも先に実行される【NGKI0125】．</p>
</div>
<div class="paragraph">
<p>拡張サービスコールの優先順位は，それを呼び出した処理単位と同じであるが，
それを呼び出した処理単位よりも先に実行される【NGKI0126】．</p>
</div>
<div class="paragraph">
<p>初期化ルーチンは，カーネルの動作開始前に，システムコンフィギュレーショ
ンファイル中に初期化ルーチンを登録する静的APIを記述したのと同じ順序で実
行される【NGKI0127】．終了処理ルーチンは，カーネルの動作終了後に，終了
処理ルーチンを登録する静的APIを記述したのと逆の順序で実行される
【NGKI0128】．</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，初期化ルーチンには，クラスに属さない
グローバル初期化ルーチンと，クラスに属するローカル初期化ルーチンがある
【NGKI0129】．グローバル初期化ルーチンがマスタプロセッサで実行された後
に，各プロセッサでローカル初期化ルーチンが実行される【NGKI0130】．また，
終了処理ルーチンには，クラスに属さないグローバル終了処理ルーチンと，ク
ラスに属するローカル終了処理ルーチンがある【NGKI0131】．ローカル終了処
理ルーチンが各プロセッサで実行された後に，マスタプロセッサでグローバル
終了処理ルーチンが実行される【NGKI0132】．</p>
</div>
<div class="paragraph">
<p>【仕様決定の理由】</p>
</div>
<div class="paragraph">
<p>終了処理ルーチンを，登録する静的APIを記述したのと逆順で実行するのは，終
了処理は初期化の逆の順序で行うのがよいためである（システムコンフィギュ
レーションファイルを分割すると，終了処理ルーチンを登録する静的APIだけ逆
順に記述するのは難しい）．</p>
</div>
</div>
<div class="sect3">
<h4 id="_カーネル処理の不可分性">1.4.3. カーネル処理の不可分性</h4>
<div class="paragraph">
<p>カーネルのサービスコール処理やディスパッチャ，割込みハンドラとCPU例外ハ
ンドラの入口処理と出口処理などのカーネル処理は不可分に実行されるのが基
本である．実際には，カーネル処理の途中でアプリケーションが実行される場
合はあるが，アプリケーションがサービスコールを用いて観測できる範囲で，
カーネル処理が不可分に実行された場合と同様に振る舞うのが原則である
【NGKI0133】．これを，カーネル処理の不可分性という．</p>
</div>
<div class="paragraph">
<p>ただし，マルチプロセッサ対応カーネルにおいては，カーネル処理が実行され
ているプロセッサ以外のプロセッサから，カーネル処理の途中の状態が観測で
きる場合がある．具体的には，1つのサービスコールにより複数のオブジェクト
の状態が変化する場合に，一部のオブジェクトの状態のみが変化し，残りのオ
ブジェクトの状態が変化していない過渡的な状態が観測できる場合がある
【NGKI0134】．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応でないカーネルでは，1つのサービスコールにより複数の
タスクが実行できる状態になる場合，新しく実行状態となるべきタスクへのディ
スパッチは，すべてのタスクの状態遷移が完了した後に行われる．例えば，低
優先度のタスクAが発行したサービスコールにより，中優先度のタスクBと高優
先度のタスクCがこの順で待ち解除される場合，タスクBとタスクCが待ち解除さ
れた後に，タスクCへのディスパッチが行われる．</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，上のことは，1つのプロセッサ内では成り
立つが，他のプロセッサに割り付けられたタスクに対しては成り立たない．例
えば，プロセッサ1で低優先度のタスクAが実行されている時に，他のプロセッ
サ2で実行されているタスクが発行したサービスコールにより，プロセッサ1に
割り付けられた中優先度のタスクBと高優先度のタスクCがこの順で待ち解除さ
れる場合，タスクCが待ち解除される前に，タスクBへディスパッチされる場合
がある．</p>
</div>
</div>
<div class="sect3">
<h4 id="_処理単位を実行するプロセッサ">1.4.4. 処理単位を実行するプロセッサ</h4>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，処理単位を実行するプロセッサ（割付け
プロセッサ）は，その処理単位が属するクラスの初期割付けプロセッサと割付
け可能プロセッサから，次のように決まる．</p>
</div>
<div class="paragraph">
<p>タスク，周期ハンドラ，アラームハンドラは，登録時に，属するクラスの初期
割付けプロセッサに割り付けられる【NGKI0135】．また，割付けプロセッサを
変更するサービスコール（mact_tsk／imact_tsk，mig_tsk，msta_cyc，
msta_alm／imsta_alm）によって，割付けプロセッサを，クラスの割付け可能プ
ロセッサのいずれかに変更することができる【NGKI0136】．</p>
</div>
<div class="paragraph">
<p>割込みハンドラ，CPU例外ハンドラ，ローカル初期化ルーチン，ローカル終了処
理ルーチンは，属するクラスの初期割付けプロセッサで実行される
【NGKI0137】．クラスの割付け可能プロセッサの情報は用いられない．</p>
</div>
<div class="paragraph">
<p>割込みサービスルーチンは，属するクラスの割付け可能プロセッサのいずれか
（オプション設定によりすべて）で実行される【NGKI0138】．クラスの初期割
付けプロセッサの情報は用いられない．</p>
</div>
<div class="paragraph">
<p>以上を整理すると，次の表の通りとなる．この表の中で，「○」はその情報が
使用されることを，「−」はその情報が使用されないことを示す．</p>
</div>
<table class="tableblock frame-topbot grid-all spread">
<colgroup>
<col style="width: 45.4545%;">
<col style="width: 27.2727%;">
<col style="width: 27.2728%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-center valign-top">初期割付けプロセッサ</th>
<th class="tableblock halign-center valign-top">割付け可能プロセッサ</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">タスク（タスク例外処理ルーチンを含む）</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>○</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>○</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">割込みハンドラ</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>○</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>−</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">割込みサービスルーチン</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>−</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>○</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">周期ハンドラ</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>○</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>○</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">アラームハンドラ</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>○</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>○</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CPU例外ハンドラ</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>○</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>−</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ローカル初期化ルーチン</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>○</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>−</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ローカル終了処理ルーチン</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>○</code></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><code>−</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>オーバランハンドラ，拡張サービスコール，グローバル初期化ルーチン，グロー
バル終了処理ルーチンは，いずれのクラスにも属さない【NGKI0139】．オーバ
ランハンドラは，オーバランを起こしたタスクの割付けプロセッサによって実
行される【NGKI0140】．拡張サービスコールは，それを呼び出した処理単位の
割付けプロセッサによって実行される【NGKI0141】．グローバル初期化ルーチ
ンとグローバル終了処理ルーチンは，マスタプロセッサによって実行される
【NGKI0142】．</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_システム状態とコンテキスト">1.5. システム状態とコンテキスト</h3>
<div class="sect3">
<h4 id="_カーネル動作状態と非動作状態">1.5.1. カーネル動作状態と非動作状態</h4>
<div class="paragraph">
<p>カーネルの初期化が完了した後，カーネルの終了処理が開始されるまでの間を，
カーネル動作状態と呼ぶ．それ以外の状態，すなわちカーネルの初期化完了前
（初期化ルーチンの実行中を含む）と終了処理開始後（終了処理ルーチンの実
行中を含む）を，カーネル非動作状態と呼ぶ．プロセッサは，カーネル動作状
態かカーネル非動作状態のいずれかの状態を取る【NGKI0143】．</p>
</div>
<div class="paragraph">
<p>カーネル非動作状態では，原則として，NMIを除くすべての割込みがマスクされ
る【NGKI0144】．</p>
</div>
<div class="paragraph">
<p>カーネル非動作状態では，システムインタフェースレイヤのAPIとカーネル非動
作状態を参照するサービスコール（sns_ker）のみを呼び出すことができる
【NGKI0145】．カーネル非動作状態で，その他のサービスコールを呼び出した
場合の動作は，保証されない【NGKI0146】．</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，プロセッサ毎に，カーネル動作状態かカー
ネル非動作状態のいずれかの状態を取る【NGKI0147】．</p>
</div>
</div>
<div class="sect3">
<h4 id="_タスクコンテキストと非タスクコンテキスト">1.5.2. タスクコンテキストと非タスクコンテキスト</h4>
<div class="paragraph">
<p>処理単位が実行される環境（用いるスタック領域やプロセッサの動作モードな
ど）をコンテキストと呼ぶ．</p>
</div>
<div class="paragraph">
<p>カーネル動作状態において，処理単位が実行されるコンテキストは，タスクコ
ンテキストと非タスクコンテキストに分類される【NGKI0148】．</p>
</div>
<div class="paragraph">
<p>タスク（タスク例外処理ルーチンを含む）が実行されるコンテキストは，タス
クコンテキストに分類される【NGKI0149】．また，タスクコンテキストから呼
び出した拡張サービスコールが実行されるコンテキストは，タスクコンテキス
トに分類される【NGKI0150】．</p>
</div>
<div class="paragraph">
<p>割込みハンドラ（割込みサービスルーチンおよびタイムイベントハンドラを含
む）とCPU例外ハンドラが実行されるコンテキストは，非タスクコンテキストに
分類される【NGKI0151】．また，非タスクコンテキストから呼び出した拡張サー
ビスコールが実行されるコンテキストは，非タスクコンテキストに分類される
【NGKI0152】．</p>
</div>
<div class="paragraph">
<p>タスクコンテキストで実行される処理単位は，別に規定がない限り，タスクの
スタック領域を用いて実行される【NGKI0153】．非タスクコンテキストで実行
される処理単位は，別に規定がない限り，非タスクコンテキスト用スタック領
域を用いて実行される【NGKI0154】．</p>
</div>
<div class="paragraph">
<p>タスクコンテキストからは，非タスクコンテキスト専用のサービスコールを呼
び出すことはできない【NGKI0155】．逆に，非タスクコンテキストからは，タ
スクコンテキスト専用のサービスコールを呼び出すことはできない
【NGKI0156】．いずれも，呼び出した場合にはE_CTXエラーとなる【NGKI0157】．</p>
</div>
</div>
<div class="sect3">
<h4 id="_カーネルの振舞いに影響を与える状態">1.5.3. カーネルの振舞いに影響を与える状態</h4>
<div class="paragraph">
<p>カーネル動作状態において，プロセッサは，カーネルの振舞いに影響を与える
状態として，次の状態を持つ【NGKI0158】．</p>
</div>
<div class="ulist">
<ul>
<li>
<p>全割込みロックフラグ（全割込みロック状態と全割込みロック解除状態）</p>
</li>
<li>
<p>CPUロックフラグ（CPUロック状態とCPUロック解除状態）</p>
</li>
<li>
<p>割込み優先度マスク（割込み優先度マスク全解除状態と全解除でない状態）</p>
</li>
<li>
<p>ディスパッチ禁止フラグ（ディスパッチ禁止状態とディスパッチ許可状態）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>これらの状態は，それぞれ独立な状態である．すなわち，プロセッサは上記の
状態の任意の組合せを取ることができ，それぞれの状態を独立に変化させるこ
とができる【NGKI0159】．</p>
</div>
</div>
<div class="sect3">
<h4 id="_全割込みロック状態と全割込みロック解除状態">1.5.4. 全割込みロック状態と全割込みロック解除状態</h4>
<div class="paragraph">
<p>プロセッサは，NMIを除くすべての割込みをマスクするための全割込みロックフ
ラグを持つ【NGKI0160】．全割込みロックフラグがセットされた状態を全割込
みロック状態，クリアされた状態を全割込みロック解除状態と呼ぶ．すなわち，
全割込みロック状態では，NMIを除くすべての割込みがマスクされる．</p>
</div>
<div class="paragraph">
<p>全割込みロック状態では，システムインタフェースレイヤのAPIとカーネル非動
作状態を参照するサービスコール（sns_ker），カーネルを終了するサービスコー
ル（ext_ker）のみを呼び出すことができる【NGKI0161】．全割込みロック状態
で，その他のサービスコール（拡張サービスコールを含む）を呼び出した場合
の動作は，保証されない【NGKI0162】．また，全割込みロック状態で，実行中
の処理単位からリターンしてはならない．リターンした場合の動作は保証され
ない【NGKI0164】．</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，プロセッサ毎に，全割込みロックフラグ
を持つ【NGKI0165】．すなわち，プロセッサ毎に，全割込みロック状態か全割
込みロック解除状態のいずれかの状態を取る．</p>
</div>
</div>
<div class="sect3">
<h4 id="_cpuロック状態とcpuロック解除状態">1.5.5. CPUロック状態とCPUロック解除状態</h4>
<div class="paragraph">
<p>プロセッサは，カーネル管理の割込み（「2.7.7 カーネル管理外の割込み」の
節を参照）をすべてマスクするためのCPUロックフラグを持つ【NGKI0166】．
CPUロックフラグがセットされた状態をCPUロック状態，クリアされた状態を
CPUロック解除状態と呼ぶ．CPUロック状態では，すべてのカーネル管理の割込
みがマスクされ，ディスパッチが保留される【NGKI0167】．</p>
</div>
<div class="paragraph">
<p>CPUロック状態で呼び出すことができるサービスコールは次の通り【NGKI0168】．</p>
</div>
<div class="ulist">
<ul>
<li>
<p>システムインタフェースレイヤのAPI</p>
</li>
<li>
<p>loc_cpu／iloc_cpu，unl_cpu／iunl_cpu</p>
</li>
<li>
<p>unl_spn／iunl_spn（マルチプロセッサ対応カーネルのみ）</p>
</li>
<li>
<p>dis_int，ena_int</p>
</li>
<li>
<p>sns_yyy</p>
</li>
<li>
<p>xsns_yyy（CPU例外ハンドラからのみ）</p>
</li>
<li>
<p>get_utm</p>
</li>
<li>
<p>ext_tsk，ext_ker</p>
</li>
<li>
<p>prb_mem（保護機能対応カーネルのみ）</p>
</li>
<li>
<p>cal_svc（保護機能対応カーネルのみ）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>CPUロック状態で，その他のサービスコールを呼び出した場合には，E_CTXエラー
となる【NGKI0169】．</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，プロセッサ毎に，CPUロックフラグを持つ
【NGKI0170】．すなわち，プロセッサ毎に，CPUロック状態かCPUロック解除状
態のいずれかの状態を取る．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>NMI以外にカーネル管理外の割込みを設けない場合には，全割込みロックフラグ
とCPUロックフラグの機能は同一となるが，両フラグは独立に存在する．</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルにおいて，あるプロセッサがCPUロック状態にあ
る間は，そのプロセッサにおいてのみ，すべてのカーネル管理の割込みがマス
クされ，ディスパッチが保留される．それに対して他のプロセッサにおいては，
割込みはマスクされず，ディスパッチも起こるため，CPUロック状態を使って他
のプロセッサで実行される処理単位との排他制御を実現することはできない．</p>
</div>
</div>
<div class="sect3">
<h4 id="_割込み優先度マスク">1.5.6. 割込み優先度マスク</h4>
<div class="paragraph">
<p>プロセッサは，割込み優先度を基準に割込みをマスクするための割込み優先度
マスクを持つ【NGKI0171】．割込み優先度マスクがTIPM_ENAALL（＝0）の時は，
いずれの割込み要求もマスクされない【NGKI0172】．この状態を割込み優先度
マスク全解除状態と呼ぶ．割込み優先度マスクがTIPM_ENAALL（＝0）以外の時
は，割込み優先度マスクと同じかそれより低い割込み優先度を持つ割込みはマ
スクされ，ディスパッチは保留される【NGKI0173】．この状態を割込み優先度
マスクが全解除でない状態と呼ぶ．</p>
</div>
<div class="paragraph">
<p>割込み優先度マスクが全解除でない状態では，別に規定がない限りは，自タス
クを広義の待ち状態に遷移させる可能性のあるサービスコールを呼び出すこと
はできない．呼び出した場合には，E_CTXエラーとなる【NGKI0175】．</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，プロセッサ毎に，割込み優先度マスクを
持つ【NGKI0176】．</p>
</div>
</div>
<div class="sect3">
<h4 id="_ディスパッチ禁止状態とディスパッチ許可状態">1.5.7. ディスパッチ禁止状態とディスパッチ許可状態</h4>
<div class="paragraph">
<p>プロセッサは，ディスパッチを保留するためのディスパッチ禁止フラグを持つ
【NGKI0177】．ディスパッチ禁止フラグがセットされた状態をディスパッチ禁
止状態，クリアされた状態をディスパッチ許可状態と呼ぶ．すなわち，ディス
パッチ禁止状態では，ディスパッチは保留される．</p>
</div>
<div class="paragraph">
<p>ディスパッチ禁止状態では，別に規定がない限りは，自タスクを広義の待ち状
態に遷移させる可能性のあるサービスコールを呼び出すことはできない．呼び
出した場合には，E_CTXエラーとなる【NGKI0179】．</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，プロセッサ毎に，ディスパッチ禁止フラ
グを持つ【NGKI0180】．すなわち，プロセッサ毎に，ディスパッチ禁止状態か
ディスパッチ許可状態のいずれかの状態を取る．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルにおいて，あるプロセッサがディスパッチ禁止
状態にある間は，そのプロセッサにおいてのみ，ディスパッチが保留される．
それに対して他のプロセッサにおいては，ディスパッチが起こるため，ディス
パッチ禁止状態を使って他のプロセッサで実行されるタスクとの排他制御を実
現することはできない．</p>
</div>
</div>
<div class="sect3">
<h4 id="_ディスパッチ保留状態">1.5.8. ディスパッチ保留状態</h4>
<div class="paragraph">
<p>非タスクコンテキストの実行中，CPUロック状態，割込み優先度マスクが全解除
でない状態，ディスパッチ禁止状態では，ディスパッチが保留される
【NGKI0181】．これらの状態を総称して，ディスパッチ保留状態と呼ぶ．</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，プロセッサ毎に，ディスパッチ保留状態
かそうでない状態のいずれかの状態を取る【NGKI0182】．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>全割込みロック状態はカーネルが管理しておらず，ディスパッチが保留される
ことをカーネルが保証できないため，ディスパッチ保留状態に含めていない．</p>
</div>
</div>
<div class="sect3">
<h4 id="_カーネル管理外の状態">1.5.9. カーネル管理外の状態</h4>
<div class="paragraph">
<p>全割込みロック状態，カーネル管理外の割込みハンドラ実行中（「2.7.7 カー
ネル管理外の割込み」の節を参照），カーネル管理外のCPU例外ハンドラ実行中
（「2.8.4 カーネル管理外のCPU例外」の節を参照）を総称して，カーネル管理
外の状態と呼ぶ．</p>
</div>
<div class="paragraph">
<p>カーネル管理外の状態では，システムインタフェースレイヤのAPIとsns_ker，
ext_kerのみ（カーネル管理外のCPU例外ハンドラからは，それに加えて
xsns_dpnとxsns_xpn）を呼び出すことができ，その他のサービスコールを呼び
出すことはできない【NGKI0543】．カーネル管理外の状態から，その他のサー
ビスコールを呼び出した場合の動作は，保証されない【NGKI0544】．</p>
</div>
<div class="paragraph">
<p>カーネル管理外の状態では，少なくとも，カーネル管理の割込みはマスクされ
ている【NGKI0545】．カーネル管理外の割込み（の一部）もマスクされている
場合もある【NGKI0546】．保護機能対応カーネルでは，カーネル管理外の状態
になるのは，特権モードで実行している間に限られる【NGKI0547】．</p>
</div>
</div>
<div class="sect3">
<h4 id="_処理単位の開始_終了とシステム状態">1.5.10. 処理単位の開始・終了とシステム状態</h4>
<div class="paragraph">
<p>各処理単位が実行開始されるシステム状態の条件（実行開始条件），各処理単
位の実行開始時にカーネルによって行われるシステム状態の変更処理（実行開
始時処理），各処理単位からのリターン前（または終了前）にアプリケーショ
ンが設定しておくべきシステム状態（リターン前または終了前），各処理単位
からのリターン時（または終了時）にカーネルによって行われるシステム状態
の変更処理（リターン時処理または終了時処理）は，次の表の通りである．</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">CPUロックフラグ</th>
<th class="tableblock halign-left valign-top">割込み優先度マスク</th>
<th class="tableblock halign-left valign-top">ディスパッチ禁止フラグ</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="4"><p class="tableblock">【タスク】【NGKI0183】</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">実行開始条件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解除</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">全解除</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">許可</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">実行開始時処理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">そのまま</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">そのまま</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">そのまま</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">終了前</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">原則解除(*1)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">原則全解除(*1)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">原則許可(*1)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">終了時処理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解除する</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">全解除する</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">許可する</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="4"><p class="tableblock">【タスク例外処理ルーチン】【NGKI0184】</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">実行開始条件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解除</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">全解除</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">実行開始時処理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">そのまま</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">そのまま</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">そのまま</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">リターン前</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">原則解除(*1)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">原則全解除(*1)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">元に戻す</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">リターン時処理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解除する</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">全解除する</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">元に戻す(*4)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="4"><p class="tableblock">【カーネル管理の割込みハンドラ】【NGKI0185】</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="4"><p class="tableblock">【割込みサービスルーチン】【NGKI0186】</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="4"><p class="tableblock">【タイムイベントハンドラ】【NGKI0187】</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">実行開始条件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解除</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自優先度より低い</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">実行開始時処理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">そのまま</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自優先度に(*2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">そのまま</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">リターン前</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">原則解除(*1)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">変更不可(*3)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">変更不可(*3)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">リターン時処理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解除する</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">元に戻す(*5)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">そのまま</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="4"><p class="tableblock">【CPU例外ハンドラ】【NGKI0188】</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">実行開始条件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">実行開始時処理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">そのまま(*6)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">そのまま</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">そのまま</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">リターン前</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">原則元に(*1)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">変更不可(*3)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">変更不可(*3)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">リターン時処理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">元に戻す</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">元に戻す(*5)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">そのまま</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" colspan="4"><p class="tableblock">【拡張サービスコール】【NGKI0189】</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">実行開始条件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">実行開始時処理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">そのまま</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">そのまま</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">そのまま</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">リターン前</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">任意</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">リターン時処理</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">そのまま</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">そのまま</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">そのまま</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>この表の中で「原則(*1)」とは，処理単位からのリターン前（または終了前）
に，アプリケーションが指定された状態に設定しておくことが原則であるが，
この原則に従わなくても，リターン時（または終了時）にカーネルによって状
態が設定されるため，支障がないことを意味する．</p>
</div>
<div class="paragraph">
<p>「自優先度に(*2)」 とは，割込みハンドラと割込みサービスルーチンの場合に
はそれを要求した割込みの割込み優先度，周期ハンドラとアラームハンドラの
場合にはタイマ割込みの割込み優先度，オーバランハンドラの場合にはオーバ
ランタイマ割込みの割込み優先度に変更することを意味する．</p>
</div>
<div class="paragraph">
<p>「変更不可(*3)」 とは，その処理単位中で，そのシステム状態を変更するAPI
が用意されていないことを示す．</p>
</div>
<div class="paragraph">
<p>保護機能対応カーネルでは，タスク例外処理ルーチンからのリターン時にディ
スパッチ禁止フラグを元に戻す処理(*4)は，タスクにディスパッチ禁止フラグ
の変更を許可している場合にのみ行われる【NGKI0529】．カーネルは，ディス
パッチ禁止フラグの元の状態をユーザスタック上に保存する【NGKI0530】．ア
プリケーションがユーザスタック上に保存されたディスパッチ禁止フラグの状
態を書き換えた場合，タスク例外処理ルーチンからのリターン時には，書き換
えた後のディスパッチ禁止フラグの状態に変更される（すなわち，元に戻され
るとは限らない）【NGKI0190】．</p>
</div>
<div class="paragraph">
<p>また，保護機能対応カーネルでは，タスクにディスパッチ禁止フラグの変更を
許可していない場合で，タスク例外処理ルーチン中で拡張サービスコールを用
いてディスパッチ禁止フラグを変更した場合，カーネルは元の状態に戻さない
【NGKI0191】．このことから，タスク例外処理ルーチンからの終了前に，ディ
スパッチ禁止フラグを元の状態に戻すのは，アプリケーションの責任とする
【NGKI0192】．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルにおいて，タスクがタスク例外処理ルーチンを
実行中にマイグレーションされた場合，マイグレーション先のプロセッサにお
いて，割込み優先度マスクとディスパッチ禁止フラグが元に戻される．</p>
</div>
<div class="paragraph">
<p>【仕様決定の理由】</p>
</div>
<div class="paragraph">
<p>保護機能対応カーネルにおいて，タスク例外処理ルーチンからのリターン時に
ディスパッチ禁止フラグを元に戻す処理(*4)が，タスクにディスパッチ禁止フ
ラグの変更を許可している場合にのみ行われるのは，タスクがユーザスタック
上の状態を書き換えることで，許可していない状態変更を起こせてしまうこと
を防止するためである．</p>
</div>
<div class="paragraph">
<p>割込みハンドラやCPU例外ハンドラで，その処理単位中で割込み優先度マスクを
変更するAPIが用意されていないにもかかわらず，処理単位からのリターン時に
元の状態に戻す(*5)のは，プロセッサによっては，割込み優先度マスクがステー
タスレジスタ等に含まれており，APIを用いずに変更できてしまう場合があるた
めである．</p>
</div>
<div class="paragraph">
<p>CPU例外ハンドラの実行開始時には，CPUロックフラグは変更されない(*6)こと
から，CPUロック状態でCPU例外が発生した場合，CPU例外ハンドラの実行開始直
後はCPUロック状態となっている．CPUロック状態でCPU例外が発生した場合，起
動されるCPU例外ハンドラはカーネル管理外のCPU例外ハンドラであり（xsns_dpn，
xsns_xpnともtrueを返す），CPU例外ハンドラ中でiunl_cpuを呼び出してCPUロッ
ク状態を解除しようとした場合の動作は保証されない．ただし，保証されない
にも関わらずiunl_cpuを呼び出した場合も考えられるため，リターン時には元
に戻すこととしている．</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_タスクの状態遷移とスケジューリング規則">1.6. タスクの状態遷移とスケジューリング規則</h3>
<div class="sect3">
<h4 id="_基本的なタスク状態">1.6.1. 基本的なタスク状態</h4>
<div class="paragraph">
<p>カーネルに登録したタスクは，実行できる状態，休止状態，広義の待ち状態の
いずれかの状態を取る【NGKI0193】．また，実行できる状態と広義の待ち状態
を総称して，起動された状態と呼ぶ．さらに，タスクをカーネルに登録してい
ない仮想的な状態を，未登録状態と呼ぶ．</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>実行できる状態（runnable）<br></p>
<div class="paragraph">
<p>タスクを実行できる条件が，プロセッサが使用できるかどうかを除いて，揃っ
ている状態．実行できる状態は，さらに，実行状態と実行可能状態に分類され
る．</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>実行状態（running）<br></p>
<div class="paragraph">
<p>タスクが実行されている状態．または，そのタスクの実行中に，割込みまたは
CPU例外により非タスクコンテキストの実行が開始され，かつ，タスクコンテキ
ストに戻った後に，そのタスクの実行を再開するという状態．</p>
</div>
</li>
<li>
<p>実行可能状態（ready）<br></p>
<div class="paragraph">
<p>タスク自身は実行できる状態にあるが，それよりも優先順位の高いタスクが実
行状態にあるために，そのタスクが実行されない状態．</p>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>休止状態（dormant）<br></p>
<div class="paragraph">
<p>タスクが実行すべき処理がない状態．タスクの実行を終了した後，次に起動す
るまでの間は，タスクは休止状態となっている．タスクが休止状態にある時に
は，タスクの実行を再開するための情報（実行再開番地やレジスタの内容など）
は保存されていない【NGKI0194】．</p>
</div>
</li>
<li>
<p>広義の待ち状態（blocked）<br></p>
<div class="paragraph">
<p>タスクが，処理の途中で実行を止められている状態．タスクが広義の待ち状態
にある時には，タスクの実行を再開するための情報（実行再開番地やレジスタ
の内容など）は保存されており，タスクが実行を再開する時には，広義の待ち
状態に遷移する前の状態に戻される【NGKI0195】．広義の待ち状態は，さらに，
（狭義の）待ち状態，強制待ち状態，二重待ち状態に分類される．</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>（狭義の）待ち状態（waiting）<br></p>
<div class="paragraph">
<p>タスクが何らかの条件が揃うのを待つために，自ら実行を止めている状態．</p>
</div>
</li>
<li>
<p>強制待ち状態（suspended）<br></p>
<div class="paragraph">
<p>他のタスクによって，強制的に実行を止められている状態．ただし，自タスク
を強制待ち状態にすることも可能である．</p>
</div>
</li>
<li>
<p>二重待ち状態（waiting-suspended）+</p>
<div class="paragraph">
<p>待ち状態と強制待ち状態が重なった状態．すなわち，タスクが何らかの条件が
揃うのを待つために自ら実行を止めている時に，他のタスクによって強制的に
実行を止められている状態．</p>
</div>
<div class="paragraph">
<p>単にタスクが「待ち状態である」といった場合には，二重待ち状態である場合
を含み，「待ち状態でない」といった場合には，二重待ち状態でもないことを
意味する．また，単にタスクが「強制待ち状態である」といった場合には，二
重待ち状態である場合を含み，「強制待ち状態でない」といった場合には，二
重待ち状態でもないことを意味する．</p>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>未登録状態（non-existent）<br></p>
<div class="paragraph">
<p>タスクをカーネルに登録していない仮想的な状態．タスクの生成前と削除後は，
タスクは未登録状態にあるとみなす．</p>
</div>
<div class="paragraph">
<p>カーネルによっては，これらのタスク状態以外に，過渡的な状態が存在する場
合がある【NGKI0196】．過渡的な状態については，「2.6.6 ディスパッチ保留
状態で実行中のタスクに対する強制待ち」の節を参照すること．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/ASPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>ASPカーネルでは，タスクが未登録状態になることはない【ASPS0005】．また，
上記のタスク状態以外の過渡的な状態になることもない【ASPS0006】．ただし，
動的生成機能拡張パッケージでは，タスクが未登録状態になる【ASPS0007】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/FMPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>FMPカーネルでは，タスクが未登録状態になることはない【FMPS0003】．上記の
タスク状態以外の過渡的な状態として，タスクが強制待ち状態［実行継続中］
になることがある【FMPS0004】．詳しくは，「2.6.6 ディスパッチ保留状態で
実行中のタスクに対する強制待ち」の節を参照すること．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/HRP2カーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>HRP2カーネルでは，タスクが未登録状態になることはない【HRPS0002】．また，
上記のタスク状態以外の過渡的な状態になることもない【HRPS0003】．ただし，
動的生成機能拡張パッケージでは，タスクが未登録状態になる【HRPS0010】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/SSPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>SSPカーネルでは，タスクが広義の待ち状態と未登録状態になることはない
【SSPS0003】．また，上記のタスク状態以外の過渡的な状態になることもない
【SSPS0004】．</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_タスクの状態遷移">1.6.2. タスクの状態遷移</h4>
<div class="paragraph">
<p>タスクの状態遷移を図2-2に示す【NGKI0197】．</p>
</div>
<div class="paragraph">
<p>未登録状態のタスクをカーネルに登録することを，タスクを生成する（create）
という．生成されたタスクは，休止状態に遷移する【NGKI0198】．また，タス
ク生成時の属性指定により，生成と同時にタスクを起動し，実行できる状態に
することもできる【NGKI0199】．逆に，登録されたタスクを未登録状態に遷移
させることを，タスクを削除する（delete）という．</p>
</div>
<div class="paragraph">
<p>休止状態のタスクを，実行できる状態にすることを，タスクを起動する
（activate）という．起動されたタスクは，実行できる状態になる
【NGKI0200】．逆に，起動された状態のタスクを，休止状態（または未登録状
態）に遷移させることを，タスクを終了する（terminate）という．</p>
</div>
<div class="paragraph">
<p>実行できる状態になったタスクは，まずは実行可能状態に遷移するが，そのタ
スクの優先順位が実行状態のタスクよりも高い場合には，ディスパッチ保留状
態でない限りはただちにディスパッチが起こり，実行状態へ遷移する
【NGKI0201】．この時，それまで実行状態であったタスクは実行可能状態に遷
移する【NGKI0202】．この時，実行状態に遷移したタスクは，実行可能状態に
遷移したタスクをプリエンプトしたという．逆に，実行可能状態に遷移したタ
スクは，プリエンプトされたという．</p>
</div>
<div class="paragraph">
<p>タスクを待ち解除するとは，タスクが待ち状態（二重待ち状態を除く）であれ
ば実行できる状態に，二重待ち状態であれば強制待ち状態に遷移させることを
いう．また，タスクを強制待ちから再開するとは，タスクが強制待ち状態（二
重待ち状態を除く）であれば実行できる状態に，二重待ち状態であれば待ち状
態に遷移させることをいう．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>タスクの実行開始とは，タスクが起動された後に最初に実行される（実行状態
に遷移する）時のことをいう．</p>
</div>
</div>
<div class="sect3">
<h4 id="_タスクのスケジューリング規則">1.6.3. タスクのスケジューリング規則</h4>
<div class="paragraph">
<p>実行できるタスクは，優先順位の高いものから順に実行される【NGKI0203】．
すなわち，ディスパッチ保留状態でない限りは，実行できるタスクの中で最も
高い優先順位を持つタスクが実行状態となり，他は実行可能状態となる．</p>
</div>
<div class="paragraph">
<p>タスクの優先順位は，タスクの優先度とタスクが実行できる状態になった順序
から，次のように定まる．優先度の異なるタスクの間では，優先度の高いタス
クが高い優先順位を持つ【NGKI0204】．優先度が同一のタスクの間では，先に
実行できる状態になったタスクが高い優先順位を持つ【NGKI0205】．すなわち，
同じ優先度を持つタスクは，FCFS（First Come First Served）方式でスケジュー
リングされる．ただし，サービスコールの呼出しにより，同じ優先度を持つタ
スク間の優先順位を変更することも可能である【NGKI0206】．</p>
</div>
<div class="paragraph">
<p>最も高い優先順位を持つタスクが変化した場合には，ディスパッチ保留状態で
ない限りはただちにディスパッチが起こり，最も高い優先順位を持つタスクが
実行状態となる【NGKI0207】．ディスパッチ保留状態においては，実行状態の
タスクは切り換わらず，最も高い優先順位を持つタスクは実行可能状態にとど
まる【NGKI0208】．</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，プロセッサ毎に，上記のスケジューリン
グ規則を適用して，タスクスケジューリングを行う【NGKI0209】．すなわち，
プロセッサがディスパッチ保留状態でない限りは，そのプロセッサに割り付け
られた実行できるタスクの中で最も高い優先順位を持つタスクが実行状態とな
り，他は実行可能状態となる．そのため，実行状態のタスクは，プロセッサ毎
に存在する．</p>
</div>
</div>
<div class="sect3">
<h4 id="_待ち行列と待ち解除の順序">1.6.4. 待ち行列と待ち解除の順序</h4>
<div class="paragraph">
<p>タスクが待ち解除される順序の管理のために，待ち状態のタスクがつながれて
いるキューを，待ち行列と呼ぶ．また，タスクが同期・通信オブジェクトの待
ち行列につながれている場合に，そのオブジェクトを，タスクの待ちオブジェ
クトと呼ぶ．</p>
</div>
<div class="paragraph">
<p>待ち行列にタスクをつなぐ順序には，FIFO順とタスクの優先度順がある．どち
らの順序でつなぐかは，待ち行列毎に規定される【NGKI0210】．多くの待ち行
列において，どちらの順序でつなぐかを，オブジェクト属性により指定できる
【NGKI0211】．</p>
</div>
<div class="paragraph">
<p>FIFO順の待ち行列においては，新たに待ち状態に遷移したタスクは待ち行列の
最後につながれる【NGKI0212】．それに対してタスクの優先度順の待ち行列に
おいては，新たに待ち状態に遷移したタスクは，優先度の高い順に待ち行列に
つながれる【NGKI0213】．同じ優先度のタスクが待ち行列につながれている場
合には，新たに待ち状態に遷移したタスクが，同じ優先度のタスクの中で最後
につながれる【NGKI0214】．</p>
</div>
<div class="paragraph">
<p>待ち解除の条件がタスクによって異なる場合には，待ち行列の先頭のタスクは
待ち解除の条件を満たさないが，後方のタスクが待ち解除の条件を満たす場合
がある．このような場合の振舞いとして，次の2つのケースがある．どちらの振
舞いをするかは，待ち行列毎に規定される【NGKI0215】．</p>
</div>
<div class="paragraph">
<p>(a) 待ち解除の条件を満たしたタスクの中で，待ち行列の前方につながれたも
のから順に待ち解除される【NGKI0216】．すなわち，待ち行列の前方に待ち解
除の条件を満たさないタスクがあっても，後方のタスクが待ち解除の条件を満
たしていれば，先に待ち解除される．</p>
</div>
<div class="paragraph">
<p>(b) タスクの待ち解除は，待ち行列につながれている順序で行われる
【NGKI0217】．すなわち，待ち行列の前方に待ち解除の条件を満たさないタス
クがあると，後方のタスクが待ち解除の条件を満たしても，待ち解除されない．</p>
</div>
<div class="paragraph">
<p>ここで，(b)の振舞いをする待ち行列においては，待ち行列につながれたタスク
の強制終了，タスク優先度の変更（待ち行列がタスクの優先度順の場合のみ），
待ち状態の強制解除が行われた場合に，タスクの待ち解除が起こることがある．
具体的には，これらの操作により新たに待ち行列の先頭になったタスクが，待
ち解除の条件を満たしていれば，ただちに待ち解除される【NGKI0218】．さら
に，この待ち解除により新たに待ち行列の先頭になったタスクに対しても，同
じ処理が繰り返される【NGKI0219】．</p>
</div>
</div>
<div class="sect3">
<h4 id="_タスク例外処理マスク状態と待ち禁止状態">1.6.5. タスク例外処理マスク状態と待ち禁止状態</h4>
<div class="paragraph">
<p>保護機能対応カーネルにおいて，ユーザタスクについては特権モードで実行し
ている間（特権モードを実行している間に，実行可能状態や広義の待ち状態に
なっている場合を含む．また，サービスコールを呼び出して，実行可能状態や
広義の待ち状態になっている場合も含む．タスクの実行開始前は含まない），
システムタスクについては拡張サービスコールを実行している間（拡張サービ
スコールを実行している間に，実行可能状態や広義の待ち状態になっている場
合を含む）は，タスク例外処理ルーチンの実行は開始されない【NGKI0220】．
これらの状態を，タスク例外処理マスク状態と呼ぶ．</p>
</div>
<div class="paragraph">
<p>タスクは，タスク例外処理マスク状態である時に，基本的なタスク状態と重複
して，待ち禁止状態になることができる【NGKI0221】．待ち禁止状態とは，タ
スクが待ち状態に入ることが一時的に禁止された状態である．待ち禁止状態に
あるタスクが，サービスコールを呼び出して待ち状態に遷移しようとした場合，
サービスコールはE_RLWAIエラーとなる【NGKI0222】．</p>
</div>
<div class="paragraph">
<p>タスクを待ち禁止状態に遷移させるサービスコールは，対象タスクがタスク例
外処理マスク状態である場合に，対象タスクを待ち禁止状態に遷移させる
【NGKI0223】．その後，タスクがタスク例外処理マスク状態でなくなる時点
（ユーザタスクについては特権モードから戻る時点，システムタスクについて
拡張サービスコールからリターンする時点）で，待ち禁止状態が解除される
【NGKI0224】．また，タスクの待ち禁止状態を解除するサービスコールによっ
ても，待ち禁止状態を解除することができる【NGKI0225】．</p>
</div>
<div class="paragraph">
<p>【仕様決定の理由】</p>
</div>
<div class="paragraph">
<p>タスク例外処理ルーチンでは，タスクの本体のための例外処理（例えば，タス
クに対して終了要求があった時の処理）を行うことを想定しており，タスクか
ら呼び出した拡張サービスコールのための例外処理を行うことは想定していな
い．そのため，拡張サービスコールを実行している間にタスク例外処理が要求
された場合に，すぐにタスク例外処理ルーチンを実行すると，拡張サービスコー
ルのための例外処理が行われないことになる．</p>
</div>
<div class="paragraph">
<p>また，ユーザタスクの場合には，特権モードを実行中にタスク例外処理ルーチ
ンを実行すると，システムスタックに情報を残したまま非特権モードに戻るこ
とになる．この状態で，タスク例外処理ルーチンから大域脱出すると，システ
ムスタック上に不要な情報が残ってしまう．</p>
</div>
<div class="paragraph">
<p>これらの理由から，タスクが拡張サービスコールを実行している間は，タスク
例外処理マスク状態とし，タスク例外処理ルーチンの実行を開始しないことと
する．さらに，ユーザタスクについては，特権モードを実行している間（拡張
サービスコールを実行している間を含む）を，タスク例外処理マスク状態とす
る．</p>
</div>
<div class="paragraph">
<p>対象タスクに，タスク例外処理ルーチンをすみやかに実行させたい場合には，
タスク例外処理の要求に加えて，待ち状態の強制解除を行う（必要に応じて，
強制待ち状態からの再開も行う）．保護機能対応でないカーネルにおいては，
この方法により，対象タスクが正常に待ち解除されるのを待たずに，タスク例
外処理ルーチンを実行させることができる．</p>
</div>
<div class="paragraph">
<p>それに対して，保護機能対応カーネルにおいては，対象タスクがタスク例外処
理マスク状態で実行している間は，タスク例外処理ルーチンの実行が開始され
ない．そのため，対象タスクに対して待ち状態の強制解除を行っても，その後
に対象タスクが待ち状態に入ると，タスク例外処理ルーチンがすみやかに実行
されないことになる．</p>
</div>
<div class="paragraph">
<p>待ち禁止状態は，この問題を解決するために導入したものである．タスク例外
処理の要求（ras_tex／iras_tex）に加えて，待ち禁止状態への遷移（dis_wai／
idis_wai）と待ち状態の強制解除（rel_wai／irel_wai）をこの順序で行うこと
で，対象タスクが正常に待ち解除されるのを待たずに，タスク例外処理ルーチ
ンを実行させることができる．</p>
</div>
<div class="paragraph">
<p>タスク例外処理マスク状態を，ユーザタスクについても拡張サービスコールを
実行している間とせず，特権モードで実行している間とした理由は，拡張サー
ビスコールを実行している間とした場合に次のような問題があるためである．</p>
</div>
<div class="paragraph">
<p>ユーザタスクが，ソフトウェア割込みにより自タスクを待ち状態に遷移させる
サービスコールを呼び出した直後に割込みが発生し，その割込みハンドラの中
でiras_tex，idis_wai，irel_waiが呼び出されると，この時点では待ち解除も
されず待ち禁止状態にもならないために，割込みハンドラからのリターン後に
待ち状態に入ってしまう．ソフトウェア割込みによりすべての割込みが禁止さ
れないターゲットプロセッサでは，ソフトウェア割込みの発生とサービスコー
ルの実行を不可分にできないため，このような状況を防ぐことができない．</p>
</div>
<div class="paragraph">
<p>なお，拡張サービスコールは，待ち状態に入るサービスコールからE_RLWAIが返
された場合には，実行中の処理を取りやめて，E_RLWAIを返値としてリターンす
るように実装すべきである．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様，μITRON4.0/PX仕様との関係】</p>
</div>
<div class="paragraph">
<p>待ち禁止状態は，μITRON4.0仕様にはない概念であり，μITRON4.0/PX仕様で導
入された．ただし，μITRON4.0/PX仕様では，タスクの待ち状態を強制解除する
サービスコールが，タスクを待ち禁止状態へ遷移させる機能も持つこととして
いる．その結果μITRON4.0/PX仕様は，待ち状態を強制解除するサービスコール
の仕様において，μITRON4.0仕様との互換性がなくなっている．</p>
</div>
<div class="paragraph">
<p>この仕様では，待ち状態の強制解除と待ち禁止状態への遷移を別々のサービス
コールで行うこととした．これにより，待ち状態を強制解除するサービスコー
ルの仕様が，μITRON4.0仕様と互換になっている．一方，μITRON4.0/PX仕様と
は互換性がない．</p>
</div>
</div>
<div class="sect3">
<h4 id="_ディスパッチ保留状態で実行中のタスクに対する強制待ち">1.6.6. ディスパッチ保留状態で実行中のタスクに対する強制待ち</h4>
<div class="paragraph">
<p>ディスパッチ保留状態において，実行状態のタスクを強制待ち状態へ遷移させ
るサービスコールを呼び出した場合，実行状態のタスクの切換えは，ディスパッ
チ保留状態が解除されるまで保留される【NGKI0226】．</p>
</div>
<div class="paragraph">
<p>この間，それまで実行状態であったタスクは，実行状態と強制待ち状態の間の
過渡的な状態にあると考える【NGKI0227】．この状態を，強制待ち状態［実行
継続中］と呼ぶ．一方，ディスパッチ保留状態が解除された後に実行すべきタ
スクは，実行可能状態にとどまる【NGKI0228】．</p>
</div>
<div class="paragraph">
<p>タスクが強制待ち状態［実行継続中］にある時に，ディスパッチ保留状態が解
除されると，ただちにディスパッチが起こり，タスクは強制待ち状態に遷移す
る【NGKI0229】．</p>
</div>
<div class="paragraph">
<p>過渡的な状態も含めたタスクの状態遷移を図2-3に示す【NGKI0230】．</p>
</div>
<div class="paragraph">
<p>タスクが強制待ち状態［実行継続中］である時の扱いは次の通りである．</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>プロセッサを占有して実行を継続する．<br></p>
<div class="paragraph">
<p>強制待ち状態［実行継続中］のタスクは，プロセッサを占有して，そのまま継
続して実行される【NGKI0231】．</p>
</div>
</li>
<li>
<p>実行状態のタスクに関する情報を参照するサービスコールでは，実行状態
であるものと扱う．</p>
<div class="paragraph">
<p>実行状態のタスクに関する情報を参照するサービスコール（get_tid／
iget_tid，get_did，sns_tex）では，強制待ち状態［実行継続中］のタスクが，
それを実行するプロセッサにおいて実行状態のタスクであるものと扱う．具体
的には，強制待ち状態［実行継続中］のタスクが実行されている時にget_tid／
iget_tidを発行すると，そのタスクのID番号を参照する【NGKI0232】．また，
get_didを発行するとそのタスクが属する保護ドメインのID番号を，sns_texを
発行するとそのタスクのタスク例外処理禁止フラグを参照する【NGKI0233】．</p>
</div>
</li>
<li>
<p>その他のサービスコールでは，強制待ち状態であるものと扱う．</p>
<div class="paragraph">
<p>その他のサービスコールでは，強制待ち状態［実行継続中］のタスクは，強制
待ち状態であるものと扱う【NGKI0234】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/ASPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>ASPカーネルでは，ディスパッチ保留状態において実行状態のタスクを強制待ち
状態へ遷移させるサービスコールはサポートしていないため，タスクが強制待
ち状態［実行継続中］になることはない【ASPS0008】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/FMPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>FMPカーネルでは，ディスパッチ保留状態において実行状態のタスクを強制待ち
状態へ遷移させるサービスコールを，他のプロセッサから呼び出すことができ
るため，タスクが強制待ち状態［実行継続中］になる場合がある【FMPS0005】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/HRP2カーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>HRP2カーネルでは，ディスパッチ保留状態において実行状態のタスクを強制待
ち状態へ遷移させるサービスコールはサポートしていないため，タスクが強制
待ち状態［実行継続中］になることはない【HRPS0004】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/SSPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>SSPカーネルでは，タスクが広義の待ち状態になることはないため，タスクが強
制待ち状態［実行継続中］になることもない【SSPS0005】．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>この仕様では，ディスパッチ保留状態において，実行状態のタスクを強制終了
させるサービスコールはサポートしていない．そのため，実行状態と休止状態
の間の過渡的な状態は存在しない．</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_制約タスク">1.6.7. 制約タスク</h4>
<div class="paragraph">
<p>制約タスク（restricted task）は，複数のタスクでスタック領域を共有するこ
とによるメモリ使用量の削減を目的に，通常のタスクに対して，広義の待ち状
態を持たないなどの機能制限を加えたものである．具体的には，制約タスクに
は以下の機能制限がある．</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>広義の待ち状態に入ることができない【NGKI0235】．</p>
</li>
<li>
<p>サービスコールによりベース優先度を変更することができない【NGKI0236】．</p>
</li>
<li>
<p>対象優先度の中の先頭のタスクが制約タスクである場合には，タスクの優
先順位の回転（rot_rdq／irot_rdq）を行うことができない【NGKI0237】．</p>
</li>
<li>
<p>マルチプロセッサ対応カーネルでは，割付けプロセッサを変更することが
できない【NGKI0238】．</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>制約タスクに対して，機能制限により使用できなくなったサービスコールを呼
び出した場合には，E_NOSPTエラーとなる【NGKI0239】．E_NOSPTエラーが返る
ことに依存している場合を除いては，制約タスクを通常のタスクに置き換える
ことができる【NGKI0240】．</p>
</div>
<div class="paragraph">
<p>【未決定事項】</p>
</div>
<div class="paragraph">
<p>現状では，制約タスクの優先度を変更するサービスコールは設けていないが，
制約タスクが，自タスクの優先度を，起動時優先度（SSPカーネルにおいては，
実行時優先度）と同じかそれよりも高い値に変更することは許してもよい．た
だし，優先度の変更後は，同じ優先度内で最高優先順位としなければならない
ため，chg_priとは振舞いが異なることになる．自タスクの優先度を起動時優先
度と同じかそれよりも高い値に変更するサービスコールを設けるかどうかは，
今後の課題である．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/ASPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>ASPカーネルでは，制約タスクをサポートしていない【ASPS0009】．ただし，制
約タスク拡張パッケージを用いると，制約タスクの機能を追加することができ
る【ASPS0010】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/FMPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>FMPカーネルでは，制約タスクをサポートしていない【FMPS0006】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/HRP2カーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>HRP2カーネルでは，制約タスクをサポートしていない【HRPS0005】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/SSPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>SSPカーネルでは，制約タスクのみをサポートする【SSPS0006】．そのため，す
べてのタスクと非タスクコンテキストがスタック領域を共有することができ，
すべての処理単位で同一のスタック領域を使用している【SSPS0007】．このス
タック領域を，共有スタック領域と呼ぶ．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>制約タスクは，μITRON4.0仕様の自動車制御プロファイルで導入された機能で
ある．この仕様における制約タスクは，μITRON4.0仕様の制約タスクよりも機
能制限が少なくなっている．</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_割込み処理モデル">1.7. 割込み処理モデル</h3>
<div class="paragraph">
<p>TOPPERS新世代カーネルにおける割込み処理のモデルは，TOPPERS標準割込み処
理モデルに準拠している．</p>
</div>
<div class="paragraph">
<p>TOPPERS標準割込み処理モデルの概念図を図2-4に示す【NGKI0241】．この図は，
割込み処理モデルの持つすべての機能が，ハードウェア（プロセッサおよび割
込みコントローラ）で実現されているとして描いた概念図である．実際のハー
ドウェアで不足している機能については，カーネル内の割込み処理のソフトウェ
アで実現される．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>割込み処理モデルは，μITRON4.0仕様から大幅に拡張している．</p>
</div>
<div class="sect3">
<h4 id="_割込み処理の流れ">1.7.1. 割込み処理の流れ</h4>
<div class="paragraph">
<p>周辺デバイス（以下，デバイスと呼ぶ）からの割込み要求は，割込みコントロー
ラ（IRC）を経由して，プロセッサに伝えられる．デバイスから割込みコントロー
ラに割込み要求を伝えるための信号線を，割込み要求ラインと呼ぶ．一般には，
1つの割込み要求ラインに，複数のデバイスからの割込み要求が接続される．</p>
</div>
<div class="paragraph">
<p>プロセッサは，デバイスからの割込み要求を受け付ける条件が満たされた場合，
割込み要求を受け付ける【NGKI0242】．受け付けた割込み要求が，カーネル管
理の割込みである場合には，カーネル内の割込みハンドラの入口処理（割込み
入口処理）を経由して，カーネル内の割込みハンドラを実行する【NGKI0243】．</p>
</div>
<div class="paragraph">
<p>カーネル内の割込みハンドラは，アプリケーションが割込み要求ラインに対し
て登録した割込みサービスルーチン（ISR）を呼び出す【NGKI0244】．割込みサー
ビスルーチンは，プロセッサの割込みアーキテクチャや割込みコントローラに
依存せず，割込みを要求したデバイスのみに依存して記述するのが原則である
【NGKI0245】．1つの割込み要求ラインに対して複数のデバイスが接続されるこ
とから，1つの割込み要求ラインに対して複数の割込みサービスルーチンを登録
することができる【NGKI0246】．</p>
</div>
<div class="paragraph">
<p>ただし，カーネルが標準的に用意している割込みハンドラで対応できない特殊
なケースも考えられる．このような場合に対応するために，アプリケーション
が用意した割込みハンドラをカーネルに登録することもできる【NGKI0247】．</p>
</div>
<div class="paragraph">
<p>カーネルが用いるタイマデバイスからの割込み要求の場合，カーネル内の割込
みハンドラにより，タイムイベントの処理が行われる．具体的には，タイムア
ウト処理等が行われることに加えて，アプリケーションが登録したタイムイベ
ントハンドラが呼び出される【NGKI0248】．</p>
</div>
<div class="paragraph">
<p>なお，受け付けた割込み要求に対して，割込みサービスルーチンも割込みハン
ドラも登録していない場合の振舞いは，ターゲット定義である【NGKI0249】．</p>
</div>
</div>
<div class="sect3">
<h4 id="_割込み優先度">1.7.2. 割込み優先度</h4>
<div class="paragraph">
<p>割込み要求は，割込み処理の優先順位を指定するための割込み優先度を持つ
【NGKI0250】．プロセッサは，割込み優先度マスクの現在値よりも高い割込み
優先度を持つ割込み要求のみを受け付ける【NGKI0251】．逆に言うと，割込み
優先度マスクの現在値と同じか，それより低い割込み優先度を持つ割込みは，
マスクされる．</p>
</div>
<div class="paragraph">
<p>プロセッサは，割込み要求を受け付けると，割込み優先度マスクを，受け付け
た割込み要求の割込み優先度に設定する（ただし，受け付けた割込みがNMIであ
る場合には例外とする）【NGKI0252】．また，割込み処理からのリターンによ
り，割込み優先度マスクを，割込み要求を受け付ける前の値に戻す
【NGKI0253】．</p>
</div>
<div class="paragraph">
<p>これらのことから，他の方法で割込みをマスクしていない限り，ある割込み要
求の処理中は，それと同じかそれより低い割込み優先度を持つ割込み要求は受
け付けられず，それより高い割込み優先度を持つ割込み要求は受け付けられる
ことになる．つまり，割込み優先度は，多重割込みを制御するためのものと位
置付けることができる．それに対して，同時に発生している割込み要求の中で，
割込み優先度の高い割込み要求が先に受け付けられるとは限らない
【NGKI0254】．</p>
</div>
<div class="paragraph">
<p>割込み優先度は，PRI型で表現し，値が小さいほど優先度が高いものとするが，
［NGKI0037］の原則には従わず，-1から連続した負の値を用いる【NGKI0255】．</p>
</div>
<div class="paragraph">
<p>割込み優先度の段階数は，ターゲット定義である【NGKI0256】．プロセッサが
割込み優先度マスクを実現するための機能を持たないか，実現するために大き
いオーバヘッドを生じる場合には，ターゲット定義で，割込み優先度の段階数
を1にする（すなわち，多重割込みを許さない）場合がある．</p>
</div>
<div class="paragraph">
<p>【仕様決定の理由】</p>
</div>
<div class="paragraph">
<p>割込み優先度に-1から連続した負の値を用いるのは，割込み優先度とタスク優
先度を比較できるようになることと，いずれの割込みもマスクしない割込み優
先度マスクの値を0にできるためである．</p>
</div>
</div>
<div class="sect3">
<h4 id="_割込み要求ラインの属性">1.7.3. 割込み要求ラインの属性</h4>
<div class="paragraph">
<p>各割込み要求ラインは，以下の属性を持つ．なお，1つの割込み要求ラインに複
数のデバイスからの割込み要求が接続されている場合，それらの割込み要求は
同一の属性を持つ【NGKI0257】．それらの割込み要求に別々の属性を設定する
ことはできない．</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>割込み要求禁止フラグ</p>
<div class="paragraph">
<p>割込み要求ライン毎に，割込みをマスクするための割込み要求禁止フラグを持
つ【NGKI0258】．割込み要求禁止フラグをセットすると，その割込み要求ライ
ンによって伝えられる割込み要求はマスクされる【NGKI0259】．</p>
</div>
<div class="paragraph">
<p>プロセッサが割込み要求禁止フラグを実現するための機能を持たないか，実現
するために大きいオーバヘッドを生じる場合には，ターゲット定義で，割込み
要求禁止フラグをサポートしない場合がある【NGKI0260】．また，プロセッサ
の持つ割込み要求禁止フラグの機能がこの仕様に合致しない場合には，ターゲッ
ト定義で，割込み要求禁止フラグをサポートしないか，振舞いが異なるものと
する場合がある【NGKI0261】．</p>
</div>
</li>
<li>
<p>割込み優先度</p>
<div class="paragraph">
<p>割込み要求ライン毎に，割込み優先度を設定することができる【NGKI0262】．
割込み要求の割込み優先度とは，その割込み要求を伝える割込み要求ラインに
対して設定された割込み優先度のことである【NGKI0263】．</p>
</div>
</li>
<li>
<p>トリガモード</p>
<div class="paragraph">
<p>割込み要求ラインに対する割込み要求が，レベルトリガであるかエッジトリガ
であるかを設定することができる【NGKI0264】．エッジトリガの場合には，さ
らに，ターゲット定義で，ポジティブエッジトリガかネガティブエッジトリガ
か両エッジトリガかを設定できる場合もある【NGKI0265】．また，レベルトリ
ガの場合には，ターゲット定義で，ローレベルトリガかハイレベルトリガかを
設定できる場合もある【NGKI0266】．</p>
</div>
<div class="paragraph">
<p>プロセッサがトリガモードを設定するための機能を持たないか，設定するため
に大きいオーバヘッドを生じる場合には，ターゲット定義で，トリガモードの
設定をサポートしない場合がある【NGKI0267】．</p>
</div>
<div class="paragraph">
<p>属性が設定されていない割込み要求ラインに対しては，割込み要求禁止フラグ
がセットされ，割込み要求はマスクされる【NGKI0268】．また，割込み要求禁
止フラグをクリアすることもできない【NGKI0269】．</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>【使用上の注意】</p>
</div>
<div class="paragraph">
<p>アプリケーションが，割込み要求禁止フラグを動的にセット／クリアする機能
を用いると，次の理由でソフトウェアの再利用性が下がる可能性があるため，
注意が必要である．プロセッサによっては，この割込み処理モデルに合致した
割込み要求禁止フラグの機能を実現できない場合がある．また，割込み要求禁
止フラグをセットすることで，複数のデバイスからの割込みがマスクされる場
合がある．ソフトウェアの再利用性を上げるためには，あるデバイスからの割
込みのみをマスクしたい場合には，そのデバイス自身の機能を使ってマスクを
実現すべきである．</p>
</div>
<div class="paragraph">
<p>複数のデバイスからの割込み要求が接続されている割込み要求ラインを，エッ
ジトリガに設定することは推奨されない．これは，次のような状況において，
割込み要求を取りこぼす可能性があるためである．ある割込み要求ラインに，
デバイスAとデバイスBからの割込み要求が接続されており，デバイスAの割込み
処理を先に行う場合を考える．この時，デバイスBからの割込み要求によって割
込みハンドラが実行され，デバイスAの割込み処理を行った後，デバイスBの割
込み処理を行う前に，デバイスAからの割込み要求が発生した場合に，デバイス
Aからの割込み要求を取りこぼしてしまう．</p>
</div>
</div>
<div class="sect3">
<h4 id="_割込みを受け付ける条件">1.7.4. 割込みを受け付ける条件</h4>
<div class="paragraph">
<p>NMI以外の割込み要求は，次の4つの条件が揃った場合に受け付けられる
【NGKI0270】．</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>割込み要求ラインに対する割込み要求禁止フラグがクリアされていること</p>
</li>
<li>
<p>割込み要求ラインに設定された割込み優先度が，割込み優先度マスクの現
在値よりも高い（優先度の値としては小さい）こと</p>
</li>
<li>
<p>全割込みロックフラグがクリアされていること</p>
</li>
<li>
<p>割込み要求がカーネル管理の割込みである場合には，CPUロックフラグがク
リアされていること</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>これらの条件が揃った割込み要求が複数ある場合に，どの割込み要求が最初に
受け付けられるかは，この仕様では規定しない【NGKI0271】．すなわち，割込
み優先度の高い割込み要求が先に受け付けられるとは限らない．</p>
</div>
</div>
<div class="sect3">
<h4 id="_割込み番号と割込みハンドラ番号">1.7.5. 割込み番号と割込みハンドラ番号</h4>
<div class="paragraph">
<p>割込み要求ラインを識別するための番号を，割込み番号と呼ぶ．割込み番号は，
符号無しの整数型であるINTNO型で表し，ターゲットハードウェアの仕様から決
まる自然な番号付けを基本として，ターゲット定義で付与される【NGKI0272】．
そのため，1から連続した正の値であるとは限らない．</p>
</div>
<div class="paragraph">
<p>それに対して，アプリケーションが用意した割込みハンドラをカーネルに登録
する場合に，割込みハンドラの登録対象となる割込みを識別するための番号を，
割込みハンドラ番号と呼ぶ．割込みハンドラ番号は，符号無しの整数型である
INHNO型で表し，ターゲットハードウェアの仕様から決まる自然な番号付けを基
本として，ターゲット定義で付与される【NGKI0273】．そのため，1から連続し
た正の値であるとは限らない．</p>
</div>
<div class="paragraph">
<p>割込みハンドラ番号は，割込み番号と1対1に対応するのが基本である（両者が
一致する場合が多い）【NGKI0274】．</p>
</div>
<div class="paragraph">
<p>ただし，割込みを要求したデバイスが割込みベクタを生成してプロセッサに渡
すアーキテクチャなどでは，割込み番号と割込みハンドラ番号の対応を，カー
ネルが管理していない場合がある【NGKI0275】．そこで，ターゲット定義で，
割込み番号に対応しない割込みハンドラ番号や，割込みハンドラ番号に対応し
ない割込み番号を設ける場合もある【NGKI0276】．ただし，割込みサービスルー
チンの登録対象にできる割込み番号は，割込みハンドラ番号との1対1の対応関
係をカーネルが管理しているもののみである【NGKI0277】．</p>
</div>
</div>
<div class="sect3">
<h4 id="_マルチプロセッサにおける割込み処理">1.7.6. マルチプロセッサにおける割込み処理</h4>
<div class="paragraph">
<p>この節では，マルチプロセッサにおける割込み処理について説明する．この節
の内容は，マルチプロセッサ対応カーネルにのみ適用される．</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，TOPPERS標準割込み処理モデルの構成要素
の中で，図2-4の破線に囲まれた部分はプロセッサ毎に持ち，それ以外の部分は
システム全体で1つのみ持つ【NGKI0278】．すなわち，全割込みロックフラグ，
CPUロックフラグ，割込み優先度マスクはプロセッサ毎に持つのに対して，割込
み要求ラインおよびその属性（割込み要求禁止フラグ，割込み優先度，トリガ
モード）はシステム全体で共通に持つ．</p>
</div>
<div class="paragraph">
<p>割込み番号は，割込み要求ラインを識別するための番号であることから，割込
み要求ラインが複数のプロセッサに接続されている場合でも，1つの割込み要求
ラインには1つの割込み番号を付与する【NGKI0279】．逆に，複数のプロセッサ
が同じ種類のデバイスを持っている場合でも，別のデバイスからの割込み要求
ラインには異なる割込み番号を付与する（図2-5）【NGKI0280】．図2-5におい
て，ローカルIRCは個々のプロセッサに対する割込みを制御するための回路であ
り，グローバルIRCはデバイスからの割込みをプロセッサに分配するための回路
である．グローバルIRCは，必ず備わっているとは限らない．</p>
</div>
<div class="paragraph">
<p>割込み要求禁止フラグは，この仕様上はシステム全体で共通に持つこととして
いるが，実際のターゲットハードウェア（特に，グローバルIRCを備えていない
もの）では，プロセッサ毎に持っている場合がある．そのため，ターゲット定
義で，あるプロセッサで割込み要求禁止フラグを動的にセット／クリアしても，
他のプロセッサに対しては割込みがマスク／マスク解除されない場合があるも
のとする【NGKI0281】．</p>
</div>
<div class="paragraph">
<p>複数のプロセッサに接続された割込み要求ラインに対して登録された割込みサー
ビスルーチンは，それらのプロセッサのいずれによっても実行することができ
る【NGKI0282】．ただし，その内のどのプロセッサで割込みサービスルーチン
を実行するかは，割込みサービスルーチンが属するクラスの割付け可能プロセッ
サにより決定される（「2.4.4 処理単位を実行するプロセッサ」の節を参照）．</p>
</div>
<div class="paragraph">
<p>割込みサービスルーチンが属するクラスの割付け可能プロセッサは，登録対象
の割込み要求ラインが接続されたプロセッサの集合に含まれていなければなら
ない【NGKI0283】．また，同一の割込み要求ラインに対して登録する割込みサー
ビスルーチンは，同一のクラスに属していなければならない【NGKI0284】．</p>
</div>
<div class="paragraph">
<p>それに対して，割込みハンドラはプロセッサ毎に登録する．そのため，同じ割
込み要求に対応する割込みハンドラであっても，プロセッサ毎に異なる割込み
ハンドラ番号を付与する（図2-5）【NGKI0285】．割込みハンドラが属するクラ
スの初期割付けプロセッサは，割込みが要求されるプロセッサと一致していな
ければならない【NGKI0286】．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルにおける割込み番号の付与方法は，複数のプロ
セッサに接続された割込み要求ラインに対しては，割込み番号の上位ビットを
0とし，1つのプロセッサのみに接続された割込み要求ラインに対しては，割込
み番号の上位ビットに，接続されたプロセッサのID番号を含める方法を基本と
する．また，割込みハンドラ番号の付与方法は，割込みハンドラ番号の上位ビッ
トに，その割込みハンドラを実行するプロセッサのID番号を含める方法を基本
とする（図2-5）．</p>
</div>
<div class="paragraph">
<p>1つのプロセッサのみに接続された割込み要求ラインに対して登録された割込み
サービスルーチンは，そのプロセッサのみを割付け可能プロセッサとするクラ
スに属していなければならない．</p>
</div>
<div class="paragraph">
<p>【使用上の注意】</p>
</div>
<div class="paragraph">
<p>複数のプロセッサで実行することができる割込みサービスルーチンは，それら
のプロセッサのいずれかで実行されるものと設定した場合でも，複数回の割込
み要求により，異なるプロセッサで同時に実行される可能性がある．</p>
</div>
</div>
<div class="sect3">
<h4 id="_カーネル管理外の割込み">1.7.7. カーネル管理外の割込み</h4>
<div class="paragraph">
<p>高い割込み応答性を求められるアプリケーションでは，カーネル内で割込みを
マスクすることにより，割込み応答性の要求を満たせなくなる場合がある．こ
のような要求に対応するために，カーネル内では，ある割込み優先度（これを，
TMIN_INTPRIと書く）よりも高い割込み優先度を持つ割込みをマスクしないこと
としている【NGKI0287】．TMIN_INTPRIを固定するか設定できるようにするか，
設定できるようにする場合の設定方法は，ターゲット定義である【NGKI0288】．</p>
</div>
<div class="paragraph">
<p>TMIN_INTPRIよりも高い割込み優先度を持ち，カーネル内でマスクしない割込み
を，カーネル管理外の割込みと呼ぶ．また，カーネル管理外の割込みによって
起動される割込みハンドラを，カーネル管理外の割込みハンドラと呼ぶ．NMIは，
カーネル管理外の割込みとして扱う．NMI以外にカーネル管理外の割込みを設け
るか（設けられるようにするか）どうかは，ターゲット定義である【NGKI0289】．</p>
</div>
<div class="paragraph">
<p>それに対して，TMIN_INTPRIと同じかそれよりも低い割込み優先度を持つ割込み
をカーネル管理の割込み，カーネル管理の割込みによって起動される割込みハ
ンドラをカーネル管理の割込みハンドラと呼ぶ．</p>
</div>
<div class="paragraph">
<p>カーネル管理外の割込みハンドラは，カーネル内の割込み入口処理を経由せず
に実行するのが基本である【NGKI0290】．ただし，すべての割込みで同じ番地
に分岐するプロセッサでは，カーネル内の割込み入口処理を全く経由せずにカー
ネル管理外の割込みハンドラを実行することができず，入口処理の一部分を経
由してカーネル管理外の割込みハンドラが実行されることになる【NGKI0291】．</p>
</div>
<div class="paragraph">
<p>カーネル管理外の割込みハンドラが実行開始される時のシステム状態とコンテ
キスト，割込みハンドラの終了時に行われる処理，割込みハンドラの記述方法
は，ターゲット定義である【NGKI0292】．カーネル管理外の割込みハンドラか
らは，システムインタフェースレイヤのAPIとsns_ker，ext_kerのみを呼び出す
ことができ，その他のサービスコールを呼び出すことはできない【NGKI0293】．
カーネル管理外の割込みハンドラから，その他のサービスコールを呼び出した
場合の動作は，保証されない【NGKI0294】．</p>
</div>
</div>
<div class="sect3">
<h4 id="_カーネル管理外の割込みの設定方法">1.7.8. カーネル管理外の割込みの設定方法</h4>
<div class="paragraph">
<p>カーネル管理外の割込みの設定方法は，ターゲット定義で，次の3つの方法のい
ずれかが採用される【NGKI0295】．</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p></p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>NMI以外にカーネル管理外の割込みを設けない</p>
</li>
<li>
<p>カーネル構築時に特定の割込みをカーネル管理外にすると決める</p>
<div class="paragraph">
<p>これら場合には，カーネル管理外とする割込みはカーネル構築時（ターゲット
依存部の実装時やカーネルのコンパイル時）に決まるため，カーネル管理外と
する割込みをアプリケーション側で設定する必要はない【NGKI0296】．ここで，
カーネル管理外とされた割込みに対して，カーネルのAPIにより割込みハンドラ
を登録できるかと，割込み要求ラインの属性を設定できるかは，ターゲット定
義である【NGKI0297】．割込みハンドラを登録できる場合には，それを定義す
るAPIにおいて，カーネル管理外であることを示す割込みハンドラ属性
（TA_NONKERNEL）を指定する【NGKI0298】．また，割込み要求ラインの属性を
設定できる場合には，設定する割込み優先度をTMIN_INTPRIよりも高い値とする
【NGKI0299】．</p>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>カーネル管理外とする割込みをアプリケーションで設定できるようにする</p>
<div class="paragraph">
<p>この場合には，カーネル管理外とする割込みの設定は，次の方法で行う．まず，
カーネル管理外とする割込みハンドラを定義するAPIにおいて，カーネル管理外
であることを示す割込みハンドラ属性（TA_NONKERNEL）を指定する
【NGKI0300】．また，カーネル管理外とする割込みの割込み要求ラインに対し
て設定する割込み優先度を，TMIN_INTPRIよりも高い値とする【NGKI0301】．</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>いずれの場合にも，カーネル管理の割込みの割込み要求ラインに対して設定す
る割込み優先度は，TMIN_INTPRIより高い値であってはならない【NGKI0302】．
また，カーネル管理外の割込みに対して，割込みサービスルーチンを登録する
ことはできない【NGKI0303】．</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cpu例外処理モデル">1.8. CPU例外処理モデル</h3>
<div class="paragraph">
<p>プロセッサが検出するCPU例外の種類や，CPU例外検出時のプロセッサの振舞い
は，プロセッサによって大きく異なる．そのため，CPU例外ハンドラをターゲッ
トハードウェアに依存せずに記述することは，少なくとも現時点では困難であ
る．そこでこの仕様では，CPU例外の処理モデルを厳密に標準化するのではなく，
ターゲットハードウェアに依存せずに決められる範囲で規定する．</p>
</div>
<div class="sect3">
<h4 id="_cpu例外処理の流れ">1.8.1. CPU例外処理の流れ</h4>
<div class="paragraph">
<p>アプリケーションは，プロセッサが検出するCPU例外の種類毎に，CPU例外ハン
ドラを登録することができる【NGKI0304】．プロセッサがCPU例外の発生を検出
すると，カーネル内のCPU例外ハンドラの入口処理（CPU例外入口処理）を経由
して，発生したCPU例外に対して登録したCPU例外ハンドラが呼び出される
【NGKI0305】．</p>
</div>
<div class="paragraph">
<p>CPU例外ハンドラの登録対象となるCPU例外を識別するための番号を，CPU例外ハ
ンドラ番号と呼ぶ．CPU例外ハンドラ番号は，符号無しの整数型であるEXCNO型
で表し，ターゲットハードウェアの仕様から決まる自然な番号付けを基本とし
て，ターゲット定義で付与される【NGKI0306】．そのため，1から連続した正の
値であるとは限らない．</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，異なるプロセッサで発生するCPU例外は，
異なるCPU例外であると扱う【NGKI0307】．すなわち，同じ種類のCPU例外であっ
ても，異なるプロセッサのCPU例外には異なるCPU例外ハンドラ番号を付与し，
プロセッサ毎にCPU例外ハンドラを登録する．CPU例外ハンドラが属するクラス
の初期割付けプロセッサは，CPU例外が発生するプロセッサと一致していなけれ
ばならない【NGKI0308】．</p>
</div>
<div class="paragraph">
<p>CPU例外ハンドラにおいては，CPU例外が発生した状態からのリカバリ処理を行
う【NGKI0309】．どのようなリカバリ処理を行うかは，一般にはCPU例外の種類
やそれが発生したコンテキストおよび状態に依存するが，大きく次の4つの方法
が考えられる【NGKI0310】．</p>
</div>
<div class="paragraph">
<p>(a) カーネルに依存しない形でCPU例外の原因を取り除き，実行を継続する．</p>
</div>
<div class="paragraph">
<p>(b) CPU例外を起こしたタスクよりも優先度の高いタスクを起動または待ち解除
し，そのタスクでリカバリ処理を行う（例えば，CPU例外を起こしたタスクを強
制終了し，再度起動する）．ただし，CPU例外を起こしたタスクが最高優先度の
場合には，この方法でリカバリ処理を行うことはできない（リカバリ処理を行
うタスクを最高優先度とし，タスクの起動または待ち解除後に優先順位を回転
させることで，リカバリ処理を行える可能性があるが，CPU例外を起こしたタス
クが制約タスクの場合には適用できないなど，推奨できる方法ではない）
【NGKI0311】．</p>
</div>
<div class="paragraph">
<p>(c) CPU例外を起こしたタスクにタスク例外処理を要求し，タスク例外処理ルー
チンでリカバリ処理を行う（例えば，CPU例外を起こしたタスクを終了する）．</p>
</div>
<div class="paragraph">
<p>(d) システム全体に対してリカバリ処理を行う（例えば，システムを再起動す
る）．</p>
</div>
<div class="paragraph">
<p>この中で(a)と(d)の方法は，カーネルの機能を必要としないため，CPU例外が発
生したコンテキストおよび状態に依存せずに常に行える【NGKI0312】．それに
対して(b)と(c)の方法は，CPU例外ハンドラからそのためのサービスコールを呼
び出せることが必要であり，それが行えるかどうかは，CPU例外が発生したコン
テキストおよび状態に依存する【NGKI0313】．</p>
</div>
<div class="paragraph">
<p>なお，発生したCPU例外に対して，CPU例外ハンドラを登録していない場合の振
舞いは，ターゲット定義である【NGKI0314】．</p>
</div>
<div class="paragraph">
<p>【使用上の注意】</p>
</div>
<div class="paragraph">
<p>CPU例外入口処理でCPU例外が発生し，それを処理するためのCPU例外ハンドラの
入口処理で同じ原因でCPU例外が発生すると，CPU例外が繰り返し発生し，アプ
リケーションが登録したCPU例外ハンドラまで処理が到達しない状況が考えられ
る．このような状況が発生するかどうかはターゲットによるが，これが許容で
きない場合には，CPU例外入口処理を経由せずに，アプリケーションが用意した
CPU例外ハンドラを直接実行するようにしなければならない．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルにおけるCPU例外ハンドラ番号の付与方法は，
CPU例外ハンドラ番号の上位ビットに，そのCPU例外が発生するプロセッサのID
番号を含める方法を基本とする．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>μITRON4.0仕様では，CPU例外からのリカバリ処理の方法については，記述され
ていない．</p>
</div>
</div>
<div class="sect3">
<h4 id="_cpu例外ハンドラから呼び出せるサービスコール">1.8.2. CPU例外ハンドラから呼び出せるサービスコール</h4>
<div class="paragraph">
<p>CPU例外ハンドラからは，CPU例外発生時のディスパッチ保留状態を参照するサー
ビスコール（xsns_dpn）と，CPU例外発生時にタスク例外処理ルーチンを実行開
始できない状態であったかを参照するサービスコール（xsns_xpn）を呼び出す
ことができる【NGKI0315】．</p>
</div>
<div class="paragraph">
<p>xsns_dpnは，CPU例外がタスクコンテキストで発生し，そのタスクがディスパッ
チできる状態であった場合にfalseを返す【NGKI0316】．xsns_dpnがfalseを返
した場合，そのCPU例外ハンドラから，非タスクコンテキストから呼び出せるす
べてのサービスコールを呼び出すことができ，(b)の方法によるリカバリ処理が
可能である【NGKI0317】．ただし，CPU例外を起こしたタスクが最高優先度の場
合には，この方法でリカバリ処理を行うことはできない【NGKI0318】．</p>
</div>
<div class="paragraph">
<p>xsns_xpnは，CPU例外がタスクコンテキストで発生し，そのタスクがタスク例外
処理ルーチンを実行できる状態であった場合にfalseを返す【NGKI0319】．
xsns_xpnがfalse を返した場合，そのCPU例外ハンドラから，非タスクコンテキ
ストから呼び出せるすべてのサービスコールを呼び出すことができ，(c)の方法
によるリカバリ処理が可能である【NGKI0320】．</p>
</div>
<div class="paragraph">
<p>xsns_dpnとxsns_xpnのいずれのサービスコールもtrueを返した場合，そのCPU例
外ハンドラからは，xsns_dpnとxsns_xpnに加えて，システムインタフェースレ
イヤのAPIとsns_ker，ext_kerのみを呼び出すことができ，その他のサービスコー
ルを呼び出すことはできない【NGKI0321】．いずれのサービスコールもtrueを
返したにもかかわらず，その他のサービスコールを呼び出した場合の動作は，
保証されない【NGKI0322】．この場合には，(b)と(c)の方法によるリカバリ処
理は行うことはできず，(a)または(d)の方法によるリカバリ処理を行うしかな
いことになる．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>CPU例外ハンドラで行える操作に関しては，μITRON4.0仕様を見直し，全面的に
修正した．</p>
</div>
</div>
<div class="sect3">
<h4 id="_エミュレートされたcpu例外ハンドラ">1.8.3. エミュレートされたCPU例外ハンドラ</h4>
<div class="paragraph">
<p>エラーコードによってアプリケーションに通知できないエラーをカーネルが検
出した場合に，アプリケーションが登録したエラー処理を，カーネルが呼び出
す場合がある【NGKI0323】．この場合に，カーネルが検出するエラーをCPU例外
と同等に扱うものとし，エミュレートされたCPU例外と呼ぶ【NGKI0324】．また，
エラー処理のためのプログラムをCPU例外ハンドラと同等に扱うものとし，エミュ
レートされたCPU例外ハンドラと呼ぶ【NGKI0325】．</p>
</div>
<div class="paragraph">
<p>具体的には，エミュレートされたCPU例外ハンドラに対してもCPU例外ハンドラ
番号が付与され，CPU例外ハンドラと同じ方法で登録できる【NGKI0326】．また，
エミュレートされたCPU例外ハンドラからも，CPU例外ハンドラから呼び出せる
サービスコールを呼び出すことができ，CPU例外ハンドラと同様のリカバリ処理
を行うことができる【NGKI0327】．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>エミュレートされたCPU例外およびCPU例外ハンドラは，μITRON4.0仕様に定義
されていない概念である．</p>
</div>
</div>
<div class="sect3">
<h4 id="_カーネル管理外のcpu例外">1.8.4. カーネル管理外のCPU例外</h4>
<div class="paragraph">
<p>カーネル非動作状態，カーネル内のクリティカルセクションの実行中，全割込
みロック状態，CPUロック状態，カーネル管理外の割込みハンドラ実行中のいず
れかで発生したCPU例外を，カーネル管理外のCPU例外と呼ぶ．また，それによっ
て起動されるCPU例外ハンドラを，カーネル管理外のCPU例外ハンドラと呼ぶ．
さらに，カーネル管理外のCPU例外ハンドラ実行中に発生したCPU例外も，カー
ネル管理外のCPU例外とする．</p>
</div>
<div class="paragraph">
<p>それに対して，カーネル管理外のCPU例外以外のCPU例外をカーネル管理のCPU例
外，カーネル管理のCPU例外によって起動されるCPU例外ハンドラをカーネル管
理のCPU例外ハンドラと呼ぶ．</p>
</div>
<div class="paragraph">
<p>カーネル管理外のCPU例外ハンドラにおいては，xsns_dpnとxsns_xpnのいずれの
サービスコールもtrueを返す【NGKI0330】．そのため，「2.8.2 CPU例外ハンド
ラから呼び出せるサービスコール」の節で述べた制限［NGKI0321］［NGKI0322］
が課される．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>カーネル管理外のCPU例外は，カーネル管理外の割込みと異なり，特定のCPU例
外をカーネル外とするわけではない．同じCPU例外であっても，CPU例外が起こ
る状況によって，カーネル管理となる場合とカーネル管理外となる場合がある．</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_システムの初期化と終了">1.9. システムの初期化と終了</h3>
<div class="sect3">
<h4 id="_システム初期化手順">1.9.1. システム初期化手順</h4>
<div class="paragraph">
<p>システムのリセット後，最初に実行するプログラムを，スタートアップモジュー
ルと呼ぶ．スタートアップモジュールはカーネルの管理外であり，アプリケー
ションで用意するのが基本であるが，スタートアップモジュールで行うべき処
理を明確にするために，カーネルの配布パッケージの中に，標準のスタートアッ
プモジュールが用意されている【NGKI0331】．</p>
</div>
<div class="paragraph">
<p>標準のスタートアップモジュールは，プロセッサのモードとスタックポインタ
等の初期化，NMIを除くすべての割込みのマスク（全割込みロック状態と同等の
状態にする），ターゲットシステム依存の初期化フックの呼出し，非初期化デー
タセクション（bssセクション）のクリア，初期化データセクション（dataセク
ション）の初期化，ソフトウェア環境（ライブラリなど）依存の初期化フック
の呼出しを行った後，カーネルの初期化処理へ分岐する【NGKI0332】．ここで
呼び出すターゲットシステム依存の初期化フックでは，リセット後に速やかに
行うべき初期化処理を行うことが想定されている．</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，すべてのプロセッサがスタートアップモ
ジュールを実行し，カーネルの初期化処理へ分岐する【NGKI0333】．ただし，
共有リソースの初期化処理（非初期化データセクションのクリア，初期化デー
タセクションの初期化，ソフトウェア環境依存の初期化フックの呼出しなど）
は，マスタプロセッサのみで実行する【NGKI0334】．各プロセッサがカーネル
の初期化処理へ分岐するのは，共有リソースの初期化処理が完了した後でなけ
ればならないため，スレーブプロセッサは，カーネルの初期化処理へ分岐する
前に，マスタプロセッサによる共有リソースの初期化処理の完了を待ち合わせ
る必要がある【NGKI0335】．</p>
</div>
<div class="paragraph">
<p>カーネルの初期化処理においては，まず，カーネル自身の初期化処理（カーネ
ル内のデータ構造の初期化，カーネルが用いるデバイスの初期化など）と静的
APIの処理（オブジェクトの登録など）が行われる【NGKI0336】．静的APIのパ
ラメータに関するエラーは，コンフィギュレータによって検出されるのが原則
であるが，コンフィギュレータで検出できないエラーが，この処理中に検出さ
れる場合もある【NGKI0337】．</p>
</div>
<div class="paragraph">
<p>静的APIの処理順序によりシステムの規定された振舞いが変化する場合には，シ
ステムコンフィギュレーションファイルにおける静的APIの記述順と同じ順序で
静的APIが処理された場合と，同じ振舞いとなる【NGKI0338】．例えば，静的
APIによって同じ優先度のタスクを複数生成・起動した場合，静的APIの記述順
が先のタスクが高い優先順位を持つ．それに対して，周期ハンドラの動作開始
順序は，同じタイムティックで行うべき処理が複数ある場合の処理順序が規定
されないことから（「4.6.1 システム時刻管理」の節を参照），静的APIの記述
順となるとは限らない．</p>
</div>
<div class="paragraph">
<p>次に，静的API（ATT_INI）により登録した初期化ルーチンが，システムコンフィ
ギュレーションファイルにおける静的APIの記述順と同じ順序で実行される
【NGKI0339】．</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，すべてのプロセッサがカーネル自身の初
期化処理と静的APIの処理を完了した後に，マスタプロセッサがグローバル初期
化ルーチンを実行する【NGKI0340】．グローバル初期化ルーチンの実行が完了
した後に，各プロセッサは，自プロセッサに割り付けられたローカル初期化ルー
チンを実行する【NGKI0341】．すなわち，ローカル初期化ルーチンは，初期割
付けプロセッサにより実行される．</p>
</div>
<div class="paragraph">
<p>以上が終了すると，カーネル非動作状態から動作状態に遷移し（「2.5.1 カー
ネル動作状態と非動作状態」の節を参照），カーネルの動作が開始される
【NGKI0342】．具体的には，システム状態が，全割込みロック解除状態・CPUロッ
ク解除状態・割込み優先度マスク全解除状態・ディスパッチ許可状態に設定さ
れ（すなわち，割込みがマスク解除され），タスクの実行が開始される．</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，すべてのプロセッサがローカル初期化ルー
チンの実行を完了した後に，カーネル非動作状態から動作状態に遷移し，カー
ネルの動作が開始される【NGKI0343】．マルチプロセッサ対応カーネルにおけ
るシステム初期化の流れと，各プロセッサが同期を取るタイミングを，図2-6に
示す【NGKI0344】．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>μITRON4.0仕様においては，初期化ルーチンの実行は静的APIの処理に含まれる
ものとしていたが，この仕様では，初期化ルーチンを登録する静的APIの処理は，
初期化ルーチンを登録することのみを意味し，初期化ルーチンの実行は含まな
いものとした．</p>
</div>
</div>
<div class="sect3">
<h4 id="_システム終了手順">1.9.2. システム終了手順</h4>
<div class="paragraph">
<p>カーネルを終了させるサービスコール（ext_ker）を呼び出すと，カーネル動作
状態から非動作状態に遷移する（「2.5.1 カーネル動作状態と非動作状態」の
節を参照）【NGKI0345】．具体的には，NMIを除くすべての割込みがマスクされ，
タスクの実行が停止される．</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，カーネルを終了させるサービスコール
（ext_ker）は，どのプロセッサからでも呼び出すことができる【NGKI0346】．
1つのプロセッサでカーネルを終了させるサービスコールを呼び出すと，そのプ
ロセッサがカーネル動作状態から非動作状態に遷移した後，他のプロセッサに
対してカーネル終了処理の開始を要求する【NGKI0347】．複数のプロセッサか
ら，カーネルを終了させるサービスコール（ext_ker）を呼び出してもよい
【NGKI0348】．</p>
</div>
<div class="paragraph">
<p>次に，静的API（ATT_TER）により登録した終了処理ルーチンが，システムコン
フィギュレーションファイルにおける静的APIの記述順と逆の順序で実行される
【NGKI0349】．</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，すべてのプロセッサがカーネル非動作状
態に遷移した後に，各プロセッサが，自プロセッサに割り付けられたローカル
終了処理ルーチンを実行する【NGKI0350】．すなわち，ローカル終了処理ルー
チンは，初期割付けプロセッサにより実行される．すべてのプロセッサでロー
カル終了処理ルーチンの実行が完了した後に，マスタプロセッサがグローバル
終了処理ルーチンを実行する【NGKI0351】．</p>
</div>
<div class="paragraph">
<p>以上が終了すると，ターゲットシステム依存の終了処理が呼び出される
【NGKI0352】．ターゲットシステム依存の終了処理は，カーネルの管理外であ
り，アプリケーションで用意するのが基本であるが，カーネルの配布パッケー
ジの中に，ターゲットシステム毎に標準的なルーチンが用意されている
【NGKI0353】．標準のターゲットシステム依存の終了処理では，ソフトウェア
環境（ライブラリなど）依存の終了処理フックを呼び出す【NGKI0354】．</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，すべてのプロセッサで，ターゲットシス
テム依存の終了処理が呼び出される【NGKI0355】．マルチプロセッサ対応カー
ネルにおけるシステム終了処理の流れと，各プロセッサが同期を取るタイミン
グを，図2-7に示す【NGKI0356】．</p>
</div>
<div class="paragraph">
<p>【使用上の注意】</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルで，あるプロセッサからカーネルを終了させる
サービスコール（ext_ker）を呼び出しても，他のプロセッサがカーネル動作状
態で割込みをマスクしたまま実行し続けると，カーネルが終了しない．</p>
</div>
<div class="paragraph">
<p>プロセッサが割込みをマスクしたまま実行し続けないようにするのは，アプリ
ケーションの責任である．例えば，ある時間を超えて割込みをマスクしたまま
実行し続けていないかを，ウォッチドッグタイマを用いて監視する方法が考え
られる．割込みをマスクしたまま実行し続けていた場合には，そのプロセッサ
からもカーネルを終了させるサービスコール（ext_ker）を呼び出すことで，カー
ネルを終了させることができる．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>μITRON4.0仕様には，システム終了に関する規定はない．</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_オブジェクトの登録とその解除">1.10. オブジェクトの登録とその解除</h3>
<div class="sect3">
<h4 id="_id番号で識別するオブジェクト">1.10.1. ID番号で識別するオブジェクト</h4>
<div class="paragraph">
<p>ID番号で識別するオブジェクトは，オブジェクトを生成する静的
API（CRE_YYY），サービスコール（acre_yyy），またはオブジェクトを追加す
る静的API（ATT_YYY，ATA_YYY）によってカーネルに登録する【NGKI0357】．オ
ブジェクトを追加する静的APIによって登録されたオブジェクトはID番号を持た
ないため，ID番号を指定して操作することができない【NGKI0358】．</p>
</div>
<div class="paragraph">
<p>オブジェクトを生成する静的API（CRE_YYY）は，生成するオブジェクトにID番
号を割り付け，ID番号を指定するパラメータとして記述した識別名を，割り付
けたID番号にマクロ定義する【NGKI0359】．同じ識別名のオブジェクトが生成
済みの場合には，E_OBJエラーとなる【NGKI0360】．</p>
</div>
<div class="paragraph">
<p>オブジェクトを生成するサービスコール（acre_yyy）は，割付け可能なID番号
の数を指定する静的API（AID_YYY）によって確保されたID番号の中から，使用
されていないID番号を1つ選び，生成するオブジェクトに割り付ける
【NGKI0361】．割り付けたID番号は，サービスコールの返値としてアプリケー
ションに通知する【NGKI0362】．使用されていないID番号が残っていない場合
には，E_NOIDエラーとなる【NGKI0363】．</p>
</div>
<div class="paragraph">
<p>割付け可能なID番号の数を指定する静的API（AID_YYY）は，システムコンフィ
ギュレーションファイル中に複数記述することができる【NGKI0364】．その場
合，各静的APIで指定した数の合計の数のID番号が確保される【NGKI0365】．</p>
</div>
<div class="paragraph">
<p>オブジェクトを生成するサービスコール（acre_yyy）によって登録したオブジェ
クトは，オブジェクトを削除するサービスコール（del_yyy）によって登録を解
除することができる【NGKI0366】．登録解除したオブジェクトのID番号は，未
使用の状態に戻され，そのID番号を用いて新しいオブジェクトを登録すること
ができる【NGKI0367】．この場合に，登録解除前のオブジェクトに対して行う
つもりの操作が，新たに登録したオブジェクトに対して行われないように，注
意が必要である．</p>
</div>
<div class="paragraph">
<p>オブジェクトを生成または追加する静的APIによって登録したオブジェクトは，
登録を解除することができない．登録を解除しようとした場合には，E_OBJエラー
となる【NGKI0369】．</p>
</div>
<div class="paragraph">
<p>タスク以外の処理単位は，その処理単位が実行されている間でも，登録解除す
ることができる【NGKI0370】．この場合，登録解除された処理単位に実行が強
制的に終了させられることはなく，処理単位が自ら実行を終了するまで，処理
単位の実行は継続される【NGKI0371】．</p>
</div>
<div class="paragraph">
<p>同期・通信オブジェクトを削除した時に，そのオブジェクトを待っているタス
クがあった場合，それらのタスクは待ち解除され，待ち状態に遷移させたサー
ビスコールはE_DLTエラーとなる【NGKI0372】．複数のタスクが待ち解除される
場合には，待ち行列につながれていた順序で待ち解除される【NGKI0373】．削
除した同期・通信オブジェクトが複数の待ち行列を持つ場合には，別の待ち行
列で待っていたタスクの間の待ち解除の順序は，該当するサービスコール毎に
規定する【NGKI0374】．</p>
</div>
<div class="paragraph">
<p>オブジェクトを再初期化するサービスコール（ini_yyy）は，指定したオブジェ
クトを削除した後に，同じパラメータで再度生成したのと等価の振舞いをする
【NGKI0375】．ただし，オブジェクトを生成または追加する静的APIによって登
録したオブジェクトも，再初期化することができる【NGKI0376】．</p>
</div>
<div class="paragraph">
<p>なお，動的生成対応カーネル以外では，オブジェクトを生成するサービスコー
ル（acre_yyy），割付け可能なID番号の数を指定する静的API（AID_YYY），オ
ブジェクトのアクセス許可ベクタを設定するサービスコール（sac_yyy），オブ
ジェクトを削除するサービスコール（del_yyy）は，サポートされない
【NGKI0377】．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>ID番号を指定してオブジェクトを生成するサービスコール（cre_yyy）を廃止し
た．また，オブジェクトを生成または追加する静的APIによって登録したオブジェ
クトは，登録解除できないこととした．</p>
</div>
<div class="paragraph">
<p>μITRON4.0仕様では，割付け可能なID番号の数を指定する静的API（AID_YYY）
は規定されていない．</p>
</div>
<div class="paragraph">
<p>複数の待ち行列を持つ同期・通信オブジェクトを削除した時に，別の待ち行列
で待っていたタスクの間の待ち解除の順序は，μITRON4.0仕様では実装依存と
されている．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0/PX仕様との関係】</p>
</div>
<div class="paragraph">
<p>アクセス許可ベクタを指定してオブジェクトを生成する静的API（CRA_YYY）は
廃止し，オブジェクトの登録後にアクセス許可ベクタを設定する静的
API（SAC_YYY）をサポートすることとした．これにあわせて，アクセス許可ベ
クタを指定してオブジェクトを登録するサービスコール（cra_yyy，acra_yyy，
ata_yyy）も廃止した．</p>
</div>
<div class="paragraph">
<p>【仕様決定の理由】</p>
</div>
<div class="paragraph">
<p>ID番号を指定してオブジェクトを生成するサービスコール（cre_yyy）とアクセ
ス許可ベクタを指定してオブジェクトを登録するサービスコール（cra_yyy，
acra_yyy，ata_yyy）を廃止したのは，必要性が低いと考えたためである．
静的APIについても，サービスコールに整合するよう変更した．</p>
</div>
</div>
<div class="sect3">
<h4 id="_オブジェクト番号で識別するオブジェクト">1.10.2. オブジェクト番号で識別するオブジェクト</h4>
<div class="paragraph">
<p>オブジェクト番号で識別するオブジェクトは，オブジェクトを定義する静的
API（DEF_YYY）またはサービスコール（def_yyy）によってカーネルに登録する
【NGKI0378】．</p>
</div>
<div class="paragraph">
<p>オブジェクトを定義するサービスコール（def_yyy）によって登録したオブジェ
クトは，同じサービスコールを，オブジェクトの定義情報を入れたパケットへ
のポインタをNULLとして呼び出すことによって，登録を解除することができる
【NGKI0379】．登録解除したオブジェクト番号は，オブジェクト登録前の状態
に戻され，同じオブジェクト番号に対して新たにオブジェクトを定義すること
ができる【NGKI0380】．登録解除されていないオブジェクト番号に対して再度
オブジェクトを登録しようとした場合には，E_OBJエラーとなる【NGKI0381】．</p>
</div>
<div class="paragraph">
<p>オブジェクトを定義する静的APIによって登録したオブジェクトは，登録を解除
することができない【NGKI0382】．登録を解除しようとした場合には，E_OBJエ
ラーとなる【NGKI0383】．</p>
</div>
<div class="paragraph">
<p>なお，動的生成対応カーネル以外では，オブジェクトを定義するサービスコー
ル（def_yyy）はサポートされない【NGKI0384】．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>この仕様では，オブジェクトの定義を変更したい場合には，一度登録解除した
後に，新たにオブジェクトを定義する必要がある．また，オブジェクトを定義
する静的APIによって登録したオブジェクトは，この仕様では，登録解除できな
いこととした．</p>
</div>
</div>
<div class="sect3">
<h4 id="_識別番号を持たないオブジェクト">1.10.3. 識別番号を持たないオブジェクト</h4>
<div class="paragraph">
<p>識別する必要がないために，識別番号を持たないオブジェクトは，オブジェク
トを追加する静的API（ATT_YYY）によってカーネルに登録する．</p>
</div>
</div>
<div class="sect3">
<h4 id="_オブジェクト生成に必要なメモリ領域">1.10.4. オブジェクト生成に必要なメモリ領域</h4>
<div class="paragraph">
<p>カーネルオブジェクトを生成する際に，サイズが一定でないメモリ領域を必要
とする場合には，カーネルオブジェクトを生成する静的APIおよびサービスコー
ルに，使用するメモリ領域の先頭番地を渡すパラメータを設けている
【NGKI0385】．このパラメータをNULLとした場合，必要なメモリ領域は，コン
フィギュレータまたはカーネルにより確保される【NGKI0386】．</p>
</div>
<div class="paragraph">
<p>オブジェクト生成に必要なメモリ領域の中で，カーネルの内部で用いるものを，
カーネルの用いるオブジェクト管理領域と呼ぶ．この仕様では，以下のメモリ
領域が，カーネルの用いるオブジェクト管理領域に該当する．</p>
</div>
<div class="ulist">
<ul>
<li>
<p>データキュー管理領域</p>
</li>
<li>
<p>優先度データキュー管理領域</p>
</li>
<li>
<p>優先度別のメッセージキューヘッダ領域</p>
</li>
<li>
<p>固定長メモリプール管理領域</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>カーネルオブジェクトを生成する際には，管理ブロックなどを置くためのメモ
リ領域も必要になるが，サイズが一定のメモリ領域はコンフィギュレータによ
り確保されるため，カーネルオブジェクトを生成する静的APIおよびサービスコー
ルにそれらのメモリ領域の先頭番地を渡すパラメータを設けていない．</p>
</div>
</div>
<div class="sect3">
<h4 id="_オブジェクトが属する保護ドメインの設定">1.10.5. オブジェクトが属する保護ドメインの設定</h4>
<div class="paragraph">
<p>保護機能対応カーネルにおいて，カーネルオブジェクトが属する保護ドメイン
は，オブジェクトの登録時に決定し，登録後に変更することはできない
【NGKI0387】．</p>
</div>
<div class="paragraph">
<p>カーネルオブジェクトを静的APIによって登録する場合には，オブジェクトを登
録する静的APIを，そのオブジェクトを属させる保護ドメインの囲みの中に記述
する【NGKI0388】．無所属のオブジェクトを登録する静的APIは，保護ドメイン
の囲みの外に記述する（「2.12.3 保護ドメインの指定」の節を参照）
【NGKI0389】．</p>
</div>
<div class="paragraph">
<p>カーネルオブジェクトをサービスコールによって登録する場合には，オブジェ
クト属性にTA_DOM(domid)を指定することにより，オブジェクトを属させる保護
ドメインを設定する【NGKI0390】．ここでdomidは，そのオブジェクトを属させ
る保護ドメインのID番号であり，TDOM_KERNEL（＝-1）を指定することでカーネ
ルドメインに属させることができる．また，domidにTDOM_SELF（＝0）を指定す
るか，オブジェクト属性にTA_DOM(domid)を指定しないことで，自タスクが属す
る保護ドメインに属させることができる．さらに，無所属のオブジェクトを登
録する場合には，domidにTDOM_NONE（＝-2）を指定する．</p>
</div>
<div class="paragraph">
<p>ただし，特定の保護ドメインのみに属することができるカーネルオブジェクト
を登録するサービスコールの中には，オブジェクトを属させる保護ドメインを
オブジェクト属性で設定する必要がないものもある【NGKI0391】．</p>
</div>
<div class="paragraph">
<p>割付け可能なID番号の数を指定する静的API（AID_YYY）で確保したID番号は，
どの保護ドメインに属するオブジェクトにも（また，無所属のオブジェクトに
も）割り付けられる【NGKI0392】．これらの静的APIは，保護ドメインの囲みの
外に記述しなければならない．保護ドメインの囲みの中に記述した場合には，
E_RSATRエラーとなる【NGKI0394】．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>この仕様では，カーネルオブジェクトの属する保護ドメインを参照する機能は
用意していない．</p>
</div>
<div class="paragraph">
<p>【仕様決定の理由】</p>
</div>
<div class="paragraph">
<p>カーネルオブジェクトをサービスコールによって登録する場合に，オブジェク
トを属させる保護ドメインをオブジェクト属性で指定することにしたのは，保
護機能対応でないカーネルとの互換性のためには，サービスコールのパラメー
タを増やさない方が望ましいためである．</p>
</div>
</div>
<div class="sect3">
<h4 id="_オブジェクトが属するクラスの設定">1.10.6. オブジェクトが属するクラスの設定</h4>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルにおいて，カーネルオブジェクトが属するクラ
スは，オブジェクトの登録時に決定し，登録後に変更することはできない
【NGKI0395】．</p>
</div>
<div class="paragraph">
<p>カーネルオブジェクトを静的APIによって登録する場合には，オブジェクトを登
録する静的APIを，そのオブジェクトを属させるクラスの囲みの中に記述する
【NGKI0396】．クラスに属さないオブジェクトを登録する静的APIは，クラスの
囲みの外に記述する（「2.12.4 クラスの指定」の節を参照）【NGKI0397】．</p>
</div>
<div class="paragraph">
<p>カーネルオブジェクトをサービスコールによって登録する場合には，オブジェ
クト属性にTA_CLS(clsid)を指定することにより，オブジェクトを属させるクラ
スを設定する【NGKI0398】．ここでclsidは，そのオブジェクトを属させるクラ
スのID番号であり，clsidにTCLS_SELF（＝0）を指定するか，オブジェクト属性
にTA_CLS(clsid)を指定しないことで，自タスクが属するクラスに属させること
ができる．</p>
</div>
<div class="paragraph">
<p>割付け可能なID番号の数を指定する静的API（AID_YYY）で確保したID番号は，
静的APIを囲むクラスに属するオブジェクトにのみ割り付けられる【NGKI0399】．
これらの静的APIは，確保したID番号を割り付けるオブジェクトの属すべきクラ
スの囲みの中に記述しなければならない．クラスの囲みの外に記述した場合に
は，E_RSATRエラーとなる【NGKI0401】．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>この仕様では，カーネルオブジェクトの属するクラスを参照する機能は用意し
ていない．</p>
</div>
<div class="paragraph">
<p>【仕様決定の理由】</p>
</div>
<div class="paragraph">
<p>カーネルオブジェクトをサービスコールによって登録する場合に，オブジェク
トを属させるクラスをオブジェクト属性で指定することにしたのは，マルチプ
ロセッサ対応でないカーネルとの互換性のためには，サービスコールのパラメー
タを増やさない方が望ましいためである．</p>
</div>
</div>
<div class="sect3">
<h4 id="_オブジェクトの状態参照">1.10.7. オブジェクトの状態参照</h4>
<div class="paragraph">
<p>ID番号で識別するオブジェクトのすべてと，オブジェクト番号で識別するオブ
ジェクトの一部に対して，オブジェクトの状態を参照するサービスコール
（ref_yyy，get_yyy）を用意する【NGKI0402】．</p>
</div>
<div class="paragraph">
<p>オブジェクトの状態を参照するサービスコールでは，オブジェクトの登録時に
指定し，その後に変化しない情報（例えば，タスクのタスク属性や初期優先度）
を参照するための機能は用意しないことを原則とする【NGKI0403】．自タスク
の拡張情報の参照するサービスコール（get_inf）は，この原則に対する例外で
ある【NGKI0404】．</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_オブジェクトのアクセス保護">1.11. オブジェクトのアクセス保護</h3>
<div class="paragraph">
<p>この節では，カーネルオブジェクトのアクセス保護について述べる．この節の
内容は，保護機能対応カーネルにのみ適用される．</p>
</div>
<div class="sect3">
<h4 id="_オブジェクトのアクセス保護とアクセス違反の通知">1.11.1. オブジェクトのアクセス保護とアクセス違反の通知</h4>
<div class="paragraph">
<p>カーネルオブジェクトに対するアクセスは，そのオブジェクトに対して設定さ
れたアクセス許可ベクタによって保護される【NGKI0405】．ただし，アクセス
許可ベクタを持たないオブジェクトに対するアクセスは，システム状態に対す
るアクセス許可ベクタによって保護される【NGKI0406】．また，オブジェクト
を登録するサービスコールと，特定のオブジェクトに関連しないシステムの状
態に対するアクセスについては，システム状態のアクセス許可ベクタによって
保護される【NGKI0407】．</p>
</div>
<div class="paragraph">
<p>アクセス許可ベクタによって許可されていないアクセス（アクセス違反）は，
カーネルによって検出され，以下の方法によって通知される．</p>
</div>
<div class="paragraph">
<p>サービスコールにより，メモリオブジェクト以外のカーネルオブジェクトに対
して，許可されていないアクセスを行おうとした場合，サービスコールから
E_OACVエラーが返る【NGKI0408】．また，メモリオブジェクトに対して，許可
されていない管理操作または参照操作を行おうとした場合も，サービスコール
からE_OACVエラーが返る【NGKI0409】．</p>
</div>
<div class="paragraph">
<p>メモリオブジェクトに対して，通常のメモリアクセスにより，許可されていな
い書込みアクセスまたは読出しアクセス（実行アクセスを含む）を行おうとし
た場合，CPU例外ハンドラが起動される【NGKI0410】．どのCPU例外ハンドラが
起動されるかは，ターゲット定義である【NGKI0411】．ターゲットによっては，
エミュレートされたCPU例外ハンドラの場合もある．また，ターゲット定義で，
アクセス違反の状況に応じて異なるCPU例外ハンドラが起動される場合もある．
この（これらの）CPU例外ハンドラを，メモリアクセス違反ハンドラと呼ぶ．</p>
</div>
<div class="paragraph">
<p>メモリオブジェクトに対して，サービスコールを通じて，許可されていない書
込みアクセスまたは読出しアクセスを行おうとした場合，サービスコールから
E_MACVエラーが返るか，メモリアクセス違反ハンドラが起動される
【NGKI0412】．E_MACVエラーが返るかメモリアクセス違反ハンドラが起動され
るかは，ターゲット定義である【NGKI0413】．</p>
</div>
<div class="paragraph">
<p>メモリアクセス違反ハンドラでは，アクセス違反を発生させたアクセスに関す
る情報（アクセスした番地，アクセスの種別，アクセスした命令の番地など）
を参照する方法を，ターゲット定義で用意する【NGKI0414】．</p>
</div>
<div class="paragraph">
<p>メモリオブジェクトとしてカーネルに登録されていないメモリ領域に対して，
ユーザドメインから書込みアクセスまたは読出しアクセス（実行アクセスを含
む）を行おうとした場合には，メモリオブジェクトに対するアクセスが許可さ
れていない場合と同様に扱われる【NGKI0415】．カーネルドメインから同様の
アクセスを行おうとした場合の動作は保証されない【NGKI0416】．</p>
</div>
<div class="paragraph">
<p>【未決定事項】</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルにおいて，システム状態のアクセス許可ベクタ
をシステム全体で1つ持つかプロセッサ毎に持つかは，今後の課題である．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0/PX仕様との関係】</p>
</div>
<div class="paragraph">
<p>μITRON4.0/PX仕様では，アクセス保護の実装定義の制限について規定している
が，この仕様では，メモリオブジェクトに対するアクセス許可ベクタのターゲッ
ト定義の制限以外については規定していない．</p>
</div>
<div class="paragraph">
<p>【仕様決定の理由】</p>
</div>
<div class="paragraph">
<p>オブジェクトを登録するサービスコールを，そのオブジェクトのアクセス許可
ベクタによって保護しないのは，オブジェクトを登録する前には，アクセス許
可ベクタが設定されていないためである．</p>
</div>
</div>
<div class="sect3">
<h4 id="_メモリオブジェクトに対するアクセス許可ベクタの制限">1.11.2. メモリオブジェクトに対するアクセス許可ベクタの制限</h4>
<div class="paragraph">
<p>メモリオブジェクトの書込みアクセスと読出しアクセス（実行アクセスを含む）
に対して設定できるアクセス許可パターンは，ターゲット定義で制限される場
合がある【NGKI0417】．</p>
</div>
<div class="paragraph">
<p>ただし，少なくとも，次の5つの組み合わせの設定は，行うことができる．</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>メモリオブジェクトが属する保護ドメインのみに，読出しアクセス（実行
アクセスを含む）のみを許可する【NGKI0418】．これを，専有リードオン
リー（private read only）と呼ぶ．</p>
</li>
<li>
<p>メモリオブジェクトが属する保護ドメインのみに，書込みアクセスと読出
しアクセス（実行アクセスを含む）を許可する【NGKI0419】．これを，専
有リードライト（private read/write）と呼ぶ．</p>
</li>
<li>
<p>すべての保護ドメインに，読出しアクセス（実行アクセスを含む）のみを
許可する【NGKI0420】．これを，共有リードオンリー（shared read only）
と呼ぶ．</p>
</li>
<li>
<p>すべての保護ドメインに，書込みアクセスと読出しアクセス（実行アクセ
スを含む）を許可する【NGKI0421】．これを，共有リードライト（shared
read/write）と呼ぶ．</p>
</li>
<li>
<p>メモリオブジェクトが属する保護ドメインに，書込みアクセスと読出しア
クセス（実行アクセスを含む）を許可し，他の保護ドメインには，読出し
アクセス（実行アクセスを含む）のみを許可する【NGKI0422】．これを，
共有リード専有ライト（shared read private write）と呼ぶ．</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>また，ターゲット定義で，1つの保護ドメインに登録できるメモリオブジェクト
の数が制限される場合がある【NGKI0423】．</p>
</div>
</div>
<div class="sect3">
<h4 id="_デフォルトのアクセス許可ベクタ">1.11.3. デフォルトのアクセス許可ベクタ</h4>
<div class="paragraph">
<p>カーネルオブジェクトを登録した直後は，次に規定されるデフォルトのアクセ
ス許可ベクタが設定される．</p>
</div>
<div class="paragraph">
<p>保護ドメインに属するカーネルオブジェクトに対しては，4つの種別のアクセス
がいずれも，その保護ドメインのみに許可される【NGKI0424】．すなわち，カー
ネルドメインに属するオブジェクトに対しては，4つのアクセス許可パターンが
いずれもTACP_KERNELに，ユーザドメインに属するオブジェクトに対しては，4
つのアクセス許可パターンがいずれもTACP(domid)（domidはオブジェクトが属
する保護ドメインのID番号）に設定される．ただし，カーネルオブジェクトを
サービスコールにより登録した場合には，管理操作に対するアクセスは，サー
ビスコールを呼び出した処理単位が属する保護ドメインにも許可される
【NGKI3427】．</p>
</div>
<div class="paragraph">
<p>無所属のカーネルオブジェクトに対しては，4つの種別のアクセスがいずれも，
すべての保護ドメインに許可される【NGKI0425】．すなわち，4つのアクセス許
可パターンがいずれも，TACP_SHAREDに設定される．</p>
</div>
<div class="paragraph">
<p>システム状態のアクセス許可ベクタは，4つの種別のアクセスがいずれも，カー
ネルドメインのみに許可される【NGKI0426】．すなわち，4つのアクセス許可パ
ターンがいずれも，TACP_KERNELに設定される．</p>
</div>
</div>
<div class="sect3">
<h4 id="_アクセス許可ベクタの設定">1.11.4. アクセス許可ベクタの設定</h4>
<div class="paragraph">
<p>アクセス許可ベクタをデフォルト以外の値に設定するために，カーネルオブジェ
クトのアクセス許可ベクタを設定する静的API（SAC_YYY）と，システム状態の
アクセス許可ベクタを設定する静的API（SAC_SYS）が用意されている
【NGKI0427】．</p>
</div>
<div class="paragraph">
<p>また，動的生成対応カーネルにおいては，カーネルオブジェクトのアクセス許
可ベクタを設定するサービスコール（sac_yyy）と，システム状態のアクセス許
可ベクタを設定するサービスコール（sac_sys）が用意されている【NGKI0428】．
ただし，静的APIによって登録したオブジェクトは，サービスコール（sac_yyy）
によってアクセス許可ベクタを設定することができない．アクセス許可ベクタ
を設定しようとした場合には，E_OBJエラーとなる【NGKI0430】．</p>
</div>
<div class="paragraph">
<p>メモリオブジェクトに対しては，アクセス許可ベクタを設定する静的APIは用意
されておらず，オブジェクトの登録と同時にアクセス許可ベクタを設定する静
的API（ATA_YYY）が用意されている【NGKI0431】．</p>
</div>
<div class="paragraph">
<p>オブジェクトに対するアクセスが許可されているかは，そのオブジェクトにア
クセスするサービスコールを呼び出した時点でチェックされる【NGKI0432】．
そのため，アクセス許可ベクタを変更しても，変更以前に呼び出されたサービ
スコールの振舞いには影響しない．例えば，待ち行列を持つ同期・通信オブジェ
クトのアクセス許可ベクタを変更しても，呼び出した時点ですでに待ち行列に
つながれているタスクには影響しない．また，ミューテックスのアクセス許可
ベクタを変更しても，呼び出した時点ですでにミューテックをロックしていた
タスクには影響しない．</p>
</div>
<div class="paragraph">
<p>この仕様では，カーネルオブジェクトに設定されたアクセス許可ベクタを参照
する機能は用意していない．</p>
</div>
<div class="paragraph">
<p>【使用上の注意】</p>
</div>
<div class="paragraph">
<p>カーネルオブジェクトのアクセス許可ベクタをデフォルト以外の値に設定する
際に，オブジェクトに対して同じ保護ドメインに属する処理単位からアクセス
できるようにするには，その保護ドメインからアクセスできることを明示的に
指定する必要がある．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0/PX仕様との関係】</p>
</div>
<div class="paragraph">
<p>アクセス許可ベクタを指定してオブジェクトを生成する静的API（CRA_YYY）は
廃止し，オブジェクトの登録後にアクセス許可ベクタを設定する静的
API（SAC_YYY）をサポートすることとした．</p>
</div>
<div class="paragraph">
<p>静的APIによって登録したオブジェクトは，サービスコール（sac_yyy）によっ
てアクセス許可ベクタを設定することができないこととした．</p>
</div>
<div class="paragraph">
<p>オブジェクトの状態参照するサービスコール（ref_yyy）により，オブジェクト
に設定されたアクセス許可ベクタを参照する機能サポートしないこととした．
これは，［NGKI0403］の原則に合わせるための修正である．</p>
</div>
</div>
<div class="sect3">
<h4 id="_カーネルの管理領域のアクセス保護">1.11.5. カーネルの管理領域のアクセス保護</h4>
<div class="paragraph">
<p>カーネルが動作するために，カーネルの内部で用いるメモリ領域を，カーネル
の管理領域と呼ぶ．ユーザタスクからカーネルを保護するためには，カーネル
の管理領域にアクセスできるのは，カーネルドメインのみでなければならない．
そのため，カーネルの管理領域は，書込みアクセスおよび読出しアクセスが可
能で，4つの種別のアクセスがカーネルドメインのみに許可されたメモリオブジェ
クト（これを，カーネル専用のメモリオブジェクトと呼ぶ）の中に置かれる
【NGKI0433】．</p>
</div>
<div class="paragraph">
<p>カーネルの用いるオブジェクト管理領域（カーネルの管理領域に該当する．
「2.10.4 オブジェクト生成に必要なメモリ領域」の節を参照）として，カーネ
ル専用のメモリオブジェクトに含まれないメモリ領域を指定した場合，E_OBJエ
ラーとなる【NGKI0434】．また，カーネルの用いるオブジェクト管理領域の先
頭番地にNULL を指定した場合，必要なメモリ領域が，カーネル専用のメモリオ
ブジェクトの中に確保される【NGKI0435】．</p>
</div>
<div class="paragraph">
<p>システムタスクのスタック領域，ユーザタスクのシステムスタック領域，非タ
スクコンテキスト用のスタック領域は，カーネルの用いるオブジェクト管理領
域には該当しないが，カーネルドメインの実行中にのみアクセスされるため，
カーネルの用いるオブジェクト管理領域と同様の扱いとなる【NGKI0436】．一
方，ユーザタスクのユーザスタック領域と固定長メモリプール領域は，ユーザ
ドメインの実行中にもアクセスされるため，カーネルの用いるオブジェクト管
理領域とは異なる扱いとなる．</p>
</div>
</div>
<div class="sect3">
<h4 id="_ユーザタスクのユーザスタック領域">1.11.6. ユーザタスクのユーザスタック領域</h4>
<div class="paragraph">
<p>ユーザタスクが非特権モードで実行する間に用いるスタック領域を，システム
スタック領域（「4.1 タスク管理機能」の節を参照）と対比させて，ユーザス
タック領域と呼ぶ．ユーザスタック領域は，そのタスクと同じ保護ドメインに
属する1つのメモリオブジェクトとしてカーネルに登録される【NGKI0437】．た
だし，他のメモリオブジェクトとは異なり，次のように扱われる．</p>
</div>
<div class="paragraph">
<p>タスクのユーザスタック領域に対しては，そのタスクのみが書込みアクセスお
よび読出しアクセスを行うことができる【NGKI0438】．そのため，書込みアク
セスと読出しアクセス（実行アクセスを含む）に対するアクセス許可パターン
は意味を持たない【NGKI0439】．ユーザスタック領域に対して実行アクセスを
行えるかどうかは，ターゲット定義である【NGKI0440】．</p>
</div>
<div class="paragraph">
<p>ただし，上記の仕様を実現するために大きいオーバヘッドを生じる場合には，
ターゲット定義で，タスクのユーザスタック領域を，そのタスクが属する保護
ドメイン全体からアクセスできるものとする場合がある【NGKI0441】．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0/PX仕様との関係】</p>
</div>
<div class="paragraph">
<p>この仕様では，タスクのユーザスタック領域は，そのタスクのみがアクセスで
きるものとした．</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_システムコンフィギュレーション手順">1.12. システムコンフィギュレーション手順</h3>
<div class="sect3">
<h4 id="_システムコンフィギュレーションファイル">1.12.1. システムコンフィギュレーションファイル</h4>
<div class="paragraph">
<p>カーネルやシステムサービスが管理するオブジェクトの生成情報や初期状態な
どを記述するファイルを，システムコンフィギュレーションファイル（system
configuration file）と呼ぶ．また，システムコンフィギュレーションファイ
ルを解釈して，カーネルやシステムサービスの構成・初期化情報を含むファイ
ルなどを生成するツールを，コンフィギュレータ（configurator）と呼ぶ．</p>
</div>
<div class="paragraph">
<p>システムコンフィギュレーションファイルには，カーネルの静的API，システム
サービスの静的API，保護ドメインの囲み，クラスの囲み，コンフィギュレータ
に対するINCLUDEディレクティブ，C言語プリプロセッサのインクルードディレ
クティブ（#include）と条件ディレクティブ（#if，#ifdefなど）のみを記述す
ることができる【NGKI0442】．</p>
</div>
<div class="paragraph">
<p>コンフィギュレータに対するINCLUDEディレクティブは，システムコンフィギュ
レーションファイルを複数のファイルに分割して記述するために用いるもので，
その文法は次のいずれかである（両者の違いは，指定されたファイルを探すディ
レクトリの違いのみ）【NGKI0443】．</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">INCLUDE("ファイル名");
INCLUDE(&lt;ファイル名&gt;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>コンフィギュレータは，INCLUDEディレクティブによって指定されたファイル中
の記述を，システムコンフィギュレーションファイルの一部分として解釈する
【NGKI0444】．すなわち，INCLUDEディレクティブによって指定されたファイル
中には，カーネルの静的API，システムサービスの静的API，コンフィギュレー
タに対するINCLUDEディレクティブ，C言語プリプロセッサのインクルードディ
レクティブと条件ディレクティブのみを記述することができる．</p>
</div>
<div class="paragraph">
<p>C言語プリプロセッサのインクルードディレクティブは，静的APIのパラメータ
を解釈するために必要なC言語のヘッダファイルを指定するために用いる
【NGKI0445】．また，条件ディレクティブは，有効とする静的APIを選択するた
めに用いることができる【NGKI0446】．ただし，インクルードディレクティブ
は，コンフィギュレータが生成するファイルでは先頭に集められる
【NGKI0447】．そのため，条件ディレクティブの中にインクルードディレクティ
ブを記述しても，インクルードディレクティブは常に有効となる．また，1つの
静的APIの記述の途中に，条件ディレクティブを記述することはできない
【NGKI0448】．</p>
</div>
<div class="paragraph">
<p>コンフィギュレータは，システムコンフィギュレーションファイル中の静的
APIを，その記述順に解釈する【NGKI0449】．そのため例えば，タスクを生成す
る静的APIの前に，そのタスクにタスク例外処理ルーチンを定義する静的APIが
記述されていた場合，タスク例外処理ルーチンを定義する静的APIがE_NOEXSエ
ラーとなる．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>システムコンフィギュレーションファイルにおけるC言語プリプロセッサのディ
レクティブの扱いを全面的に見直し，コンフィギュレータに対するINCLUDEディ
レクティブを設けた．また，共通静的APIを廃止した．μITRON4.0仕様における
#includeディレクティブの役割は，この仕様ではINCLUDEディレクティブに置き
換わる．逆に，μITRON4.0仕様におけるINCLUDE静的APIの役割は，この仕様で
は#includeディレクティブに置き換わる．</p>
</div>
</div>
<div class="sect3">
<h4 id="_静的apiの文法とパラメータ">1.12.2. 静的APIの文法とパラメータ</h4>
<div class="paragraph">
<p>静的APIは，次に述べる例外を除いては，C言語の関数呼出しと同様の文法で記
述する【NGKI0450】．すなわち，静的APIの名称に続けて，静的APIの各パラメー
タを","で区切って列挙したものを"("と")"で囲んで記述し，最後に";"を記述
する．ただし，静的APIのパラメータに構造体（または構造体へのポインタ）を
記述する場合には，構造体の各フィールドを","で区切って列挙したものを"{"
と"}"で囲んだ形で記述する【NGKI0451】．</p>
</div>
<div class="paragraph">
<p>サービスコールに対応する静的APIの場合，静的APIのパラメータは，対応する
サービスコールのパラメータと同一とすることを原則とする【NGKI0452】．</p>
</div>
<div class="paragraph">
<p>静的APIのパラメータは，次の4種類に分類される．</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>オブジェクト識別名</p>
<div class="paragraph">
<p>オブジェクトのID番号を指定するパラメータ．オブジェクトの名称を表す単一
の識別名のみを記述することができる．</p>
</div>
<div class="paragraph">
<p>コンフィギュレータは，オブジェクト生成のための静的API（CRE_YYY）を処理
する際に，オブジェクトにID番号を割り付け，構成・初期化ヘッダファイルに，
指定された識別名を割り付けたID番号にマクロ定義するC言語プリプロセッサの
ディレクティブ（#define）を生成する【NGKI0453】．</p>
</div>
<div class="paragraph">
<p>オブジェクト生成以外の静的APIが，オブジェクトのID番号をパラメータに取る
場合（カーネルの静的APIでは，SAC_TSKやDEF_TEXのtskidパラメータ等がこれ
に該当する）には，パラメータとして記述する識別名は，生成済みのオブジェ
クトの名称を表す識別名でなければならない．そうでない場合には，コンフィ
ギュレータがエラーを報告する【NGKI0455】．</p>
</div>
<div class="paragraph">
<p>静的APIの整数定数式パラメータの記述に，オブジェクト識別名を使用すること
はできない【NGKI0456】．</p>
</div>
</li>
<li>
<p>整数定数式パラメータ</p>
<div class="paragraph">
<p>オブジェクト番号や機能コード，オブジェクト属性，サイズや数，優先度など，
整数値を指定するパラメータ．プログラムが配置される番地に依存せずに値の
決まる整数定数式を記述することができる．</p>
</div>
<div class="paragraph">
<p>整数定数式の解釈に必要な定義や宣言等は，システムコンフィギュレーション
ファイルからC言語プリプロセッサのインクルードディレクティブによってイン
クルードするファイルに含まれていなければならない【NGKI0457】．</p>
</div>
</li>
<li>
<p>一般定数式パラメータ</p>
<div class="paragraph">
<p>処理単位のエントリ番地，メモリ領域の先頭番地，拡張情報など，番地を指定
する可能性のあるパラメータ．任意の定数式を記述することができる．</p>
</div>
<div class="paragraph">
<p>定数式の解釈に必要な定義や宣言等は，システムコンフィギュレーションファ
イルからC言語プリプロセッサのインクルードディレクティブによってインクルー
ドするファイルに含まれていなければならない【NGKI0458】．</p>
</div>
</li>
<li>
<p>文字列パラメータ</p>
<div class="paragraph">
<p>オブジェクトモジュール名やセクション名など，文字列を指定するパラメータ．
任意の文字列を，C言語の文字列の記法で記述することができる．</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>μITRON4.0仕様においては，静的APIのパラメータを次の4種類に分類していた
が，コンフィギュレータの仕組みを見直したことに伴い全面的に見直した．</p>
</div>
<div class="olist upperalpha">
<ol class="upperalpha" type="A">
<li>
<p>自動割付け対応整数値パラメータ</p>
</li>
<li>
<p>自動割付け非対応整数値パラメータ</p>
</li>
<li>
<p>プリプロセッサ定数式パラメータ</p>
</li>
<li>
<p>一般定数式パラメータ</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>この仕様の(a)が，おおよそμITRON4.0仕様の(A)に相当するが，(a)には整数値
を記述できない点が異なる．(b)〜(c)と(B)〜(D)の間には単純な対応関係がな
いが，記述できる定数式の範囲には，(B)⊂(C)⊂(b)⊂(c)＝(D)の関係がある．</p>
</div>
<div class="paragraph">
<p>μITRON4.0仕様では，静的APIのパラメータは基本的には(D)とし，コンフィギュ
レータが値を知る必要があるパラメータを(B)，構成・初期化ファイルに生成す
るC言語プリプロセッサの条件ディレクティブ（#if）中に含めたい可能性のあ
るパラメータを(C)としていた．</p>
</div>
<div class="paragraph">
<p>それに対して，この仕様におけるコンフィギュレータの処理モデル（「2.12.5
コンフィギュレータの処理モデル」の節を参照）では，コンフィギュレータの
パス2において定数式パラメータの値を知ることができるため，(B)〜(D)の区別
をする必要がない．そのため，静的APIのパラメータは基本的には(b)とし，パ
ス2で値を知ることのできない定数式パラメータのみを(c)としている．</p>
</div>
</div>
<div class="sect3">
<h4 id="_保護ドメインの指定">1.12.3. 保護ドメインの指定</h4>
<div class="paragraph">
<p>保護機能対応カーネルでは，オブジェクトを登録する静的API等を，そのオブジェ
クトが属する保護ドメインの囲みの中に記述する【NGKI0459】．無所属のオブ
ジェクトを登録する静的APIは，保護ドメインの囲みの外に記述する
【NGKI0460】．保護ドメインに属すべきオブジェクトを登録する静的API等を，
保護ドメインの囲みの外に記述した場合には，コンフィギュレータがE_RSATRエ
ラーを報告する【NGKI0461】．</p>
</div>
<div class="paragraph">
<p>ユーザドメインの囲みの文法は次の通り【NGKI0462】．</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">DOMAIN(保護ドメイン名) {
	ユーザドメインに属するオブジェクトを登録する静的API等
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>保護ドメイン名には，ユーザドメインの名称を表す単一の識別名のみを記述す
ることができる【NGKI0463】．</p>
</div>
<div class="paragraph">
<p>コンフィギュレータは，ユーザドメインの囲みを処理する際に，ユーザドメイ
ンに保護ドメインIDを割り付け，構成・初期化ヘッダファイルに，指定された
保護ドメイン名を割り付けた保護ドメインIDにマクロ定義するC言語プリプロセッ
サのディレクティブ（#define）を生成する【NGKI0464】．また，ユーザドメイ
ンの囲みの中およびそれ以降に記述する静的APIの整数定数式パラメータの記述
に保護ドメイン名を記述すると，割り付けた保護ドメインIDの値に評価される
【NGKI0465】．</p>
</div>
<div class="paragraph">
<p>ユーザドメインの囲みの中を空にすることで，ユーザドメインへの保護ドメイ
ンIDの割付けのみを行うことができる【NGKI0466】．</p>
</div>
<div class="paragraph">
<p>カーネルドメインの囲みの文法は次の通り【NGKI0467】．</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">KERNEL_DOMAIN {
	カーネルドメインに属するオブジェクトを登録する静的API等
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>同じ保護ドメイン名を指定したユーザドメインの囲みや，カーネルドメインの
囲みを，複数回記述してもよい【NGKI0468】．保護機能対応でないカーネルで
保護ドメインの囲みを記述した場合や，保護ドメインの囲みの中に保護ドメイ
ンの囲みを記述した場合には，コンフィギュレータがエラーを報告する
【NGKI0469】．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0/PX仕様との関係】</p>
</div>
<div class="paragraph">
<p>保護ドメインの囲みの文法を変更した．</p>
</div>
<div class="paragraph">
<p>【仕様決定の理由】</p>
</div>
<div class="paragraph">
<p>保護ドメインに属すべきオブジェクトを登録する静的API等を保護ドメインの囲
みの外に記述した場合のエラーコードをE_RSATRとしたのは，オブジェクトを動
的に登録するAPIにおいては，オブジェクトの属する保護ドメインを，オブジェ
クト属性によって指定するためである．</p>
</div>
</div>
<div class="sect3">
<h4 id="_クラスの指定">1.12.4. クラスの指定</h4>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，オブジェクトを登録する静的API等を，そ
のオブジェクトが属するクラスの囲みの中に記述する【NGKI0470】．クラスに
属すべきオブジェクトを登録する静的API等を，クラスの囲みの外に記述した場
合には，コンフィギュレータがE_RSATRエラーを報告する【NGKI0471】．</p>
</div>
<div class="paragraph">
<p>クラスの囲みの文法は次の通り【NGKI0472】．</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">CLASS(クラスID) {
	クラスに属するオブジェクトを登録する静的API等
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>クラスIDには，静的APIの整数定数式パラメータと同等の定数式を記述すること
ができる【NGKI0473】．使用できないクラスIDを指定した場合には，コンフィ
ギュレータがE_IDエラーを報告する【NGKI0474】．</p>
</div>
<div class="paragraph">
<p>同じクラスIDを指定したクラスの囲みを複数回記述してもよい【NGKI0475】．
マルチプロセッサ対応でないカーネルでクラスの囲みを記述した場合や，クラ
スの囲みの中にクラスの囲みを記述した場合には，コンフィギュレータがエラー
を報告する【NGKI0476】．</p>
</div>
<div class="paragraph">
<p>なお，保護機能とマルチプロセッサの両方に対応するカーネルでは，保護ドメ
インの囲みとクラスの囲みはどちらが外側になっていてもよい【NGKI0477】．</p>
</div>
<div class="paragraph">
<p>【仕様決定の理由】</p>
</div>
<div class="paragraph">
<p>クラスに属すべきオブジェクトを登録する静的API等をクラスの囲みの外に記述
した場合のエラーコードをE_RSATRとしたのは，オブジェクトを動的に登録する
APIにおいては，オブジェクトの属するクラスを，オブジェクト属性によって指
定するためである．</p>
</div>
</div>
<div class="sect3">
<h4 id="_コンフィギュレータの処理モデル">1.12.5. コンフィギュレータの処理モデル</h4>
<div class="paragraph">
<p>コンフィギュレータは，次の3つないしは4つのパスにより，システムコンフィ
ギュレーションファイルを解釈し，構成・初期化情報を含むファイルなどを生
成する（図2-8）．</p>
</div>
<div class="paragraph">
<p>最初のパス1では，システムコンフィギュレーションファイルを解釈し，そこに
含まれる静的APIの整数定数式パラメータの値をCコンパイラを用いて求めるた
めに，パラメータ計算用C言語ファイル（cfg1_out.c）を生成する．この時，シ
ステムコンフィギュレーションファイルに含まれるC言語プリプロセッサのイン
クルードディレクティブは，パラメータ計算用C言語ファイルの先頭に集めて生
成する．また，条件ディレクティブは，順序も含めて，そのままの形でパラメー
タ計算用C言語ファイルに出力する．システムコンフィギュレーションファイル
に文法エラーや未サポートの記述があった場合には，この段階で検出される．</p>
</div>
<div class="paragraph">
<p>次に，Cコンパイラおよび関連ツールを用いて，パラメータ計算用C言語ファイ
ルをコンパイルし，ロードモジュールを生成する．また，それをSレコードフォー
マットの形に変換したSレコードファイル（cfg1_out.srec）と，その中の各シ
ンボルとアドレスの対応表を含むシンボルファイル（cfg1_out.syms）を生成す
る．静的APIの整数定数式パラメータに解釈できない式が記述された場合には，
この段階でエラーが検出される．</p>
</div>
<div class="paragraph">
<p>コンフィギュレータのパス2では，パス1で生成されたロードモジュールのSレコー
ドファイルとシンボルファイルから，C言語プリプロセッサの条件ディレクティ
ブによりどの静的APIが有効となったかと，それらの静的APIの整数定数式パラ
メータの値を取り出し，カーネルおよびシステムサービスの構成・初期化ファ
イル（kernel_cfg.cなど）と構成・初期化ヘッダファイル（kernel_cfg.hなど）
を生成する．構成・初期化ヘッダファイルには，登録できるオブジェクトの数
（動的生成対応カーネル以外では，静的APIによって登録されたオブジェクトの
数に一致）やオブジェクトのID番号などの定義を出力する．静的APIの整数定数
式パラメータに不正がある場合には，この段階でエラーが検出される．</p>
</div>
<div class="paragraph">
<p>パス2で生成されたファイルを，他のソースファイルとあわせてコンパイルし，
アプリケーションのロードモジュールを生成する．また，そのSレコードファイ
ル（system.srec）とシンボルファイル（system.syms）を生成する．静的APIの
一般定数式パラメータに解釈できない式が記述された場合には，この段階でエ
ラーが検出される．</p>
</div>
<div class="paragraph">
<p>コンフィギュレータのパス3では，パス1およびパス2で生成されたロードモジュー
ルのSレコードファイルとシンボルファイルから，静的APIのパラメータの値な
どを取り出し，妥当性のチェックを行う．静的APIの一般定数式パラメータに不
正がある場合には，この段階でエラーが検出される．</p>
</div>
<div class="paragraph">
<p>保護機能対応カーネルにおいては，メモリ配置を決定し，メモリ保護のための
設定情報を生成するために，さらに以下の処理を行う（図2-9）．</p>
</div>
<div class="paragraph">
<p>コンフィギュレータは，決定したメモリ配置に従ってロードモジュールを生成
するために，リンクスクリプト（ldscript.ld）を生成する．また，メモリ保護
のための設定情報を，メモリ構成・初期化ファイル（kernel_mem.c）に生成す
る．これらのファイルを生成するためには，パス3以降で初めて得られる情報が
必要となるため，これらのファイルはパス3以降でしか生成できず，最終的なロー
ドモジュールも，パス3以降で生成する．</p>
</div>
<div class="paragraph">
<p>そのため，パス2で生成されたロードモジュールは，仮のロードモジュールとい
う位置付けになる．ここで，パス3以降で必要な情報を取り出し，最終的なロー
ドモジュールのサイズを割り出せるように，パス3以降でメモリ構成・初期化ファ
イルに生成するのと同様のデータ構造を，パス2において仮のメモリ構成・初期
化ファイル（kernel_mem2.c）に生成する．また，これをリンクするための仮の
リンクスクリプト（cfg2_out.ld）を生成し，これらを用いて仮のロードモジュー
ルを生成する．さらに，仮のロードモジュールのSレコードファイル
（cfg2_out.srec）とシンボルファイル（cfg2_out.syms）も，最終的なものと
混同しないように，異なるファイル名で生成する．</p>
</div>
<div class="paragraph">
<p>パス3は，ターゲット依存で用いるパスで，メモリ配置やメモリ保護のための設
定情報のサイズを最適化するための処理を行う．パス2で生成された仮のロード
モジュールのSレコードファイルとシンボルファイルから必要な情報を取り出し，
再度，仮のメモリ構成・初期化ファイル（kernel_mem3.c）と仮のリンクスクリ
プト（cfg3_out.ld）を生成する．また，これらのファイルを他のソースファイ
ルとあわせてコンパイルして仮のロードモジュールを生成し，そのSレコードファ
イル（cfg3_out.srec）とシンボルファイル（cfg3_out.syms）を生成する．こ
の段階で，メモリオブジェクトに重なりがあるなどのエラーが検出される場合
もある．</p>
</div>
<div class="paragraph">
<p>パス4では，パス3（パス3を用いない場合はパス2）で生成された仮のロードモ
ジュールのSレコードファイルとシンボルファイルから必要な情報を取り出し，
最終的なメモリ構成・初期化ファイル（kernel_mem.c）とリンクスクリプト
（ldscript.ld）を生成する．またパス4では，保護機能対応でないカーネルに
おいてパス3で行っていた静的APIパラメータの値などの妥当性のチェックも行
う．そのため，静的APIの一般定数式パラメータに不正がある場合には，この段
階でエラーが検出される．</p>
</div>
<div class="paragraph">
<p>パス4で生成されたファイルを，他のソースファイルとあわせてコンパイルし，
アプリケーションの最終的なロードモジュールを生成する．また，そのSレコー
ドファイル（system.srec，必要な場合のみ）とシンボルファイル
（system.syms）を生成する．</p>
</div>
<div class="paragraph">
<p>最後に，最終的なロードモジュールが，パス3（パス3を用いない場合はパス2）
で生成された仮のロードモジュールと同じメモリ配置であることをチェックす
る．両者のメモリ配置が異なっていた場合には，ロードモジュールが正しく生
成されていない可能性があるが，これは，コンフィギュレーション処理の不具
合を示すものである．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>コンフィギュレータの処理モデルは全面的に変更した．</p>
</div>
</div>
<div class="sect3">
<h4 id="_静的apiのパラメータに関するエラー検出">1.12.6. 静的APIのパラメータに関するエラー検出</h4>
<div class="paragraph">
<p>静的APIのパラメータに関するエラー検出は，同じものがサービスコールとして
呼ばれた場合と同等とすることを原則とする【NGKI0478】．言い換えると，サー
ビスコールによっても検出できないエラーは，静的APIにおいても検出しない．
静的APIの機能説明中の「E_XXXXXエラーとなる」または「E_XXXXXエラーが返る」
という記述は，コンフィギュレータがそのエラーを検出することを意味する．</p>
</div>
<div class="paragraph">
<p>ただし，エラーの種類によっては，サービスコールと同等のエラー検出を行う
ことが難しいため，そのようなものについては例外とする【NGKI0479】．例え
ば，メモリ不足をコンフィギュレータによって検出するのは容易ではない．</p>
</div>
<div class="paragraph">
<p>逆に，オブジェクト属性については，サービスコールより強力なエラーチェッ
クを行える可能性がある．例えば，タスク属性にTA_STAと記述されている場合，
サービスコールではエラーを検出できないが，コンフィギュレータでは検出で
きる可能性がある．ただし，このようなエラー検出を完全に行おうとするとコ
ンフィギュレータが複雑になるため，このようなエラーを検出することは必須
とせず，検出できた場合には警告として報告する【NGKI0480】．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>μITRON4.0仕様では，静的APIのパラメータに関するエラー検出について規定さ
れていない．</p>
</div>
</div>
<div class="sect3">
<h4 id="_オブジェクトのid番号の指定">1.12.7. オブジェクトのID番号の指定</h4>
<div class="paragraph">
<p>コンフィギュレータのオプション機能として，アプリケーション設計者がオブ
ジェクトのID番号を指定するための次の機能を用意する．</p>
</div>
<div class="paragraph">
<p>コンフィギュレータのオプション指定により，オブジェクト識別名とID番号の
対応表を含むファイルを渡すと，コンフィギュレータはそれに従ってオブジェ
クトにID番号を割り付ける【NGKI0481】．それに従ったID番号割付けができな
い場合（ID番号に抜けができる場合など）には，コンフィギュレータはエラー
を報告する【NGKI0482】．</p>
</div>
<div class="paragraph">
<p>またコンフィギュレータは，オプション指定により，オブジェクト識別名とコ
ンフィギュレータが割り付けたID番号の対応表を含むファイルを，コンフィギュ
レータに渡すファイルと同じフォーマットで生成する【NGKI0483】．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>μITRON4.0仕様では，オブジェクト生成のための静的APIのID番号を指定するパ
ラメータに整数値を記述できるため，このような機能は用意されていない．</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_toppersネーミングコンベンション">1.13. TOPPERSネーミングコンベンション</h3>
<div class="paragraph">
<p>この節では，TOPPERSソフトウェアのAPIの構成要素の名称に関するネーミング
コンベンションについて述べる．このネーミングコンベンションは，モジュー
ル間のインタフェースに関わる名称に適用することを想定しているが，モジュー
ル内部の名称に適用してもよい．</p>
</div>
<div class="sect3">
<h4 id="_モジュール識別名">1.13.1. モジュール識別名</h4>
<div class="paragraph">
<p>異なるモジュールのAPIの構成要素の名称が衝突することを避けるために，各モ
ジュールに対して，それを識別するためのモジュール識別名を定める．モジュー
ル識別名は，英文字と数字で構成し，2〜8文字程度の長さとする．</p>
</div>
<div class="paragraph">
<p>カーネルのモジュール識別名は"kernel"，システムインタフェースレイヤのモ
ジュール識別名は"sil"とする．</p>
</div>
<div class="paragraph">
<p>APIの構成要素の名称には，モジュール識別名を含めることを原則とするが，カー
ネルのAPIなど，頻繁に使用されて衝突のおそれが少ない場合には，モジュール
識別名を含めない名称を使用する．</p>
</div>
<div class="paragraph">
<p>以下では，モジュール識別名の英文字を英小文字としたものをwww，英大文字と
したものをWWWと表記する．</p>
</div>
</div>
<div class="sect3">
<h4 id="_データ型名">1.13.2. データ型名</h4>
<div class="paragraph">
<p>各サイズの整数型など，データの意味を定めない基本データ型の名称は，英小
文字，数字，"_"で構成する．データ型であることを明示するために，末尾が
"_t"である名称とする．</p>
</div>
<div class="paragraph">
<p>複合データ型やデータの意味を定めるデータ型の名称は，英大文字，数字，
"<em>"で構成する．データ型であることを明示するために，先頭が"T</em>"または末尾
が"_T"である名称とする場合もある．</p>
</div>
<div class="paragraph">
<p>データ型の種類毎に，次のネーミングコンベンションを定める．</p>
</div>
<div class="olist upperalpha">
<ol class="upperalpha" type="A">
<li>
<p>パケットのデータ型</p>
<div class="listingblock">
<div class="content">
<pre>	T_CYYY			acre_yyyに渡すパケットのデータ型
	T_DYYY			def_yyyに渡すパケットのデータ型
	T_RYYY			ref_yyyに渡すパケットのデータ型
	T_WWW_CYYY		www_acre_yyyに渡すパケットのデータ型
	T_WWW_DYYY		www_def_yyyに渡すパケットのデータ型
	T_WWW_RYYY		www_ref_yyyに渡すパケットのデータ型</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_関数名">1.14. 関数名</h3>
<div class="paragraph">
<p>関数の名称は，英小文字，数字，"_"で構成する．</p>
</div>
<div class="paragraph">
<p>関数の種類毎に，次のネーミングコンベンションを定める．</p>
</div>
<div class="olist upperalpha">
<ol class="upperalpha" type="A">
<li>
<p>サービスコール</p>
<div class="paragraph">
<p>サービスコールは，xxx_yyyまたはwww_xxx_yyyの名称とする．ここで，xxxは操
作の方法，yyyは操作の対象を表す．xxx_yyyまたはwww_xxx_yyyから派生したサー
ビスコールは，それぞれzxxx_yyyまたはwww_zxxx_yyyの名称とする．ここでzは，
派生したことを表す文字である．派生したことを表す文字を2つ付加する場合に
は，zzxxx_yyyまたはwww_zzxxx_yyyの名称となる．</p>
</div>
<div class="paragraph">
<p>非タスクコンテキスト専用のサービスコールの名称は，派生したことを表す文
字として"i"を付加し，ixxx_yyy，izxxx_yyy，www_ixxx_yyy，www_izxxx_yyyと
いった名称とする．</p>
</div>
<div class="paragraph">
<p>【補足説明】</p>
</div>
<div class="paragraph">
<p>サービスコールの名称を構成する省略名（xxx，yyy，z）の元になった英語につ
いては，「5.10 省略名の元になった英語」の節を参照すること．</p>
</div>
</li>
<li>
<p>コールバック</p>
<div class="paragraph">
<p>コールバックの名称は，サービスコールのネーミングコンベンションに従う．</p>
</div>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_変数名">1.14.1. 変数名</h4>
<div class="paragraph">
<p>変数（const修飾子のついたものを含む）の名称は，英小文字，数字，"_"で構
成する．データ型が異なる変数には，異なる名称を付けることを原則とする．</p>
</div>
<div class="paragraph">
<p>変数の名称に関して，次のガイドラインを設ける．</p>
</div>
<div class="literalblock">
<div class="content">
<pre>〜id		〜ID（オブジェクトのID番号，ID型）
〜no		〜番号（オブジェクト番号）
〜atr		〜属性（オブジェクト属性，ATR型）
〜stat		〜状態（オブジェクト状態，STAT型）
〜mode		〜モード（サービスコールの動作モード，MODE型）
〜pri		〜優先度（優先度，PRI型）
〜sz		〜サイズ（単位はバイト数，SIZE型またはuint_t型）
〜cnt		〜の個数（単位は個数，uint_t型）
〜ptn		〜パターン
〜tim		〜時刻，〜時間
〜cd		〜コード
i〜			〜の初期値
max〜		〜の最大値
min〜		〜の最小値
left〜		〜の残り</pre>
</div>
</div>
<div class="paragraph">
<p>また，ポインタ変数（関数ポインタを除く）の名称に関して，次のガイドライ
ンを設ける．</p>
</div>
<div class="literalblock">
<div class="content">
<pre>p_〜		ポインタ
pp_〜		ポインタを入れる領域へのポインタ
pk_〜		パケットへのポインタ
ppk_〜		パケットへのポインタを入れる領域へのポインタ</pre>
</div>
</div>
<div class="paragraph">
<p>変数の種類毎に，次のネーミングコンベンションを定める．</p>
</div>
<div class="paragraph">
<p>(A) パケットへのポインタ</p>
</div>
<div class="literalblock">
<div class="content">
<pre>pk_cyyy			acre_yyyに渡すパケットへのポインタ
pk_dyyy			def_yyyに渡すパケットへのポインタ
pk_ryyy			ref_yyyに渡すパケットへのポインタ
pk_www_cyyy		www_acre_yyyに渡すパケットへのポインタ
pk_www_dyyy		www_def_yyyに渡すパケットへのポインタ
pk_www_ryyy		www_ref_yyyに渡すパケットへのポインタ</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_定数名">1.14.2. 定数名</h4>
<div class="paragraph">
<p>定数（C言語プリプロセッサのマクロ定義によるもの）の名称は，英大文字，数
字，"_"で構成する．</p>
</div>
<div class="paragraph">
<p>定数の種類毎に，次のネーミングコンベンションを定める．</p>
</div>
<div class="paragraph">
<p>(A) メインエラーコード</p>
</div>
<div class="paragraph">
<p>メインエラーコードは，先頭が"E_"である名称とする．</p>
</div>
<div class="paragraph">
<p>(B) 機能コード</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TFN_XXX_YYY			xxx_yyyの機能コード
TFN_WWW_XXX_YYY		www_xxx_yyyの機能コード</pre>
</div>
</div>
<div class="paragraph">
<p>(C) その他の定数</p>
</div>
<div class="paragraph">
<p>その他の定数は，先頭がTUU_またはTUU_WWW_である名称とする．ここでUUは，
定数の種類またはデータ型を表す．同じパラメータまたはリターンパラメータ
に用いられる定数の名称については，UUを同一にすることを原則とする．</p>
</div>
<div class="paragraph">
<p>また，定数の名称に関して，次のガイドラインを設ける．</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TA_〜		オブジェクトの属性値
TSZ_〜		〜のサイズ
TBIT_〜		〜のビット数
TMAX_〜		〜の最大値
TMIN_〜		〜の最小値</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_マクロ名">1.14.3. マクロ名</h4>
<div class="paragraph">
<p>マクロ（C言語プリプロセッサのマクロ定義によるもの）の名称は，それが表す
構成要素のネーミングコンベンションに従う．すなわち，関数を表すマクロは
関数のネーミングコンベンションに，定数を表すマクロは定数のネーミングコ
ンベンションに従う．ただし，簡単な関数を表すマクロや，副作用があるなど
の理由でマクロであることを明示したい場合には，英大文字，数字，"_"で構成
する場合もある．</p>
</div>
<div class="paragraph">
<p>マクロの種類毎に，次のネーミングコンベンションを定める．</p>
</div>
<div class="paragraph">
<p>(A) 構成マクロ</p>
</div>
<div class="paragraph">
<p>構成マクロの名称は，英大文字，数字，"_"で構成し，次のガイドラインを設け
る．</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TSZ_〜		〜のサイズ
TBIT_〜		〜のビット数
TMAX_〜		〜の最大値
TMIN_〜		〜の最小値</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_静的api名">1.14.4. 静的API名</h4>
<div class="paragraph">
<p>静的APIの名称は，英大文字，数字，"_"で構成し，対応するサービスコールの
名称中の英小文字を英大文字で置き換えたものとする．対応するサービスコー
ルがない場合には，サービスコールのネーミングコンベンションに従って定め
た名称中の英小文字を英大文字で置き換えたものとする．</p>
</div>
</div>
<div class="sect3">
<h4 id="_ファイル名">1.14.5. ファイル名</h4>
<div class="paragraph">
<p>ファイルの名称は，英小文字，数字，"_"，"."で構成する．英大文字と英小文
字を区別しないファイルシステムに対応するために，英大文字は使用しない．
また，"-"も使用しない．</p>
</div>
<div class="paragraph">
<p>ファイルの種類毎に，次のネーミングコンベンションを定める．</p>
</div>
<div class="paragraph">
<p>(A) ヘッダファイル</p>
</div>
<div class="paragraph">
<p>モジュールを用いるために必要な定義を含むヘッダファイルは，そのモジュー
ルのモジュール識別名の末尾に".h"を付加した名前（すなわち，www.h）とする．</p>
</div>
</div>
<div class="sect3">
<h4 id="_モジュール内部の名称の衝突回避">1.14.6. モジュール内部の名称の衝突回避</h4>
<div class="paragraph">
<p>モジュール内部の名称が，他のモジュール内部の名称と衝突することを避ける
ために，次のガイドラインを設ける．</p>
</div>
<div class="paragraph">
<p>モジュール内部に閉じて使われる関数や変数などの名称で，オブジェクトファ
イルのシンボル表に登録されて外部から参照できる名称は，C言語レベルで，先
頭が_www_または_WWW_である名称とする．例えば，カーネルの内部シンボルは，
C言語レベルで，先頭が"<em>kernel</em>"または"<em>KERNEL</em>"である名称とする．</p>
</div>
<div class="paragraph">
<p>また，モジュールを用いるために必要な定義を含むヘッダファイル中に用いる
名称で，それをインクルードする他のモジュールで使用する名称と衝突する可
能性のある名称は，"TOPPERS_"で始まる名称とする．</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_toppers共通定義">1.15. TOPPERS共通定義</h3>
<div class="paragraph">
<p>TOPPERSソフトウェアに共通に用いる定義を，TOPPERS共通定義と呼ぶ．</p>
</div>
<div class="sect3">
<h4 id="_toppers共通ヘッダファイル">1.15.1. TOPPERS共通ヘッダファイル</h4>
<div class="paragraph">
<p>TOPPERS共通定義（共通データ型，共通定数，共通マクロ）は，TOPPERS共通ヘッ
ダファイル（t_stddef.h）およびそこからインクルードされるファイルに含ま
れている【NGKI0484】．TOPPERS共通定義を用いる場合には，TOPPERS共通ヘッ
ダファイルをインクルードする【NGKI0485】．</p>
</div>
<div class="paragraph">
<p>TOPPERS共通ヘッダファイルは，カーネルヘッダファイル（kernel.h）やシステ
ムインタフェースレイヤヘッダファイル（sil.h）からインクルードされるため，
これらのファイルをインクルードする場合には，TOPPERS共通ヘッダファイルを
直接インクルードする必要はない【NGKI0486】．</p>
</div>
</div>
<div class="sect3">
<h4 id="_toppers共通データ型">1.15.2. TOPPERS共通データ型</h4>
<div class="paragraph">
<p>C90に規定されているデータ型以外で，TOPPERSソフトウェアで共通に用いるデー
タ型は次の通りである【NGKI0487】．</p>
</div>
<div class="literalblock">
<div class="content">
<pre>int8_t		符号付き8ビット整数（オプション，C99準拠）
uint8_t		符号無し8ビット整数（オプション，C99準拠）
int16_t		符号付き16ビット整数（C99準拠）
uint16_t	符号無し16ビット整数（C99準拠）
int32_t		符号付き32ビット整数（C99準拠）
uint32_t	符号無し32ビット整数（C99準拠）
int64_t		符号付き64ビット整数（オプション，C99準拠）
uint64_t	符号無し64ビット整数（オプション，C99準拠）
int128_t	符号付き128ビット整数（オプション，C99準拠）
uint128_t	符号無し128ビット整数（オプション，C99準拠）</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>int_least8_t	8ビット以上の符号付き整数（C99準拠）
uint_least8_t	int_least8_t型と同じサイズの符号無し整数（C99準拠）</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>float32_t	IEEE754準拠の32ビット単精度浮動小数点数（オプション）
double64_t	IEEE754準拠の64ビット倍精度浮動小数点数（オプション）</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>bool_t		真偽値（trueまたはfalse）
int_t		16ビット以上の符号付き整数
uint_t		int_t型と同じサイズの符号無し整数
long_t		32ビット以上かつint_t型以上のサイズの符号付き整数
ulong_t		long_t型と同じサイズの符号無し整数</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>intptr_t	ポインタを格納できるサイズの符号付き整数（C99準拠）
uintptr_t	intptr_t型と同じサイズの符号無し整数（C99準拠）</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>FN			機能コード（符号付き整数，int_tに定義）
ER			正常終了（E_OK）またはエラーコード（符号付き整数，int_t
			に定義）
ID			オブジェクトのID番号（符号付き整数，int_tに定義）
ATR			オブジェクト属性（符号無し整数，uint_tに定義）
STAT		オブジェクトの状態（符号無し整数，uint_tに定義）
MODE		サービスコールの動作モード（符号無し整数，uint_tに定義）
PRI			優先度（符号付き整数，int_tに定義）
SIZE		メモリ領域のサイズ（符号無し整数，ポインタを格納できる
			サイズの符号無し整数型に定義）</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>TMO			タイムアウト指定（符号付き整数，単位はミリ秒，int_tに定義）
RELTIM		相対時間（符号無し整数，単位はミリ秒，uint_tに定義）
SYSTIM		システム時刻（符号無し整数，単位はミリ秒，ulong_tに定義）
SYSUTM		性能評価用システム時刻（符号無し整数，単位はマイクロ秒，
			ulong_tに定義）</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>FP			プログラムの起動番地（型の定まらない関数ポインタ）</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>ER_BOOL		エラーコードまたは真偽値（符号付き整数，int_tに定義）
ER_ID		エラーコードまたはID番号（符号付き整数，int_tに定義，
			負のID番号は格納できない）
ER_UINT		エラーコードまたは符号無し整数（符号付き整数，int_tに
			定義，符号無し整数を格納する場合の有効ビット数はuint_t
			より1ビット短い）</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>MB_T		オブジェクト管理領域を確保するためのデータ型</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>ACPTN		アクセス許可パターン（符号無し32ビット整数，uint32_tに
			定義）
ACVCT		アクセス許可ベクタ</pre>
</div>
</div>
<div class="paragraph">
<p>ここで，データ型が「AまたはB」とは，AかBのいずれかの値を取ることを示す．
例えばER_BOOLは，エラーコードまたは真偽値のいずれかの値を取る．</p>
</div>
<div class="paragraph">
<p>int8_t，uint8_t，int64_t，uint64_t，int128_t，uint128_t，float32_t，
double64_tが使用できるかどうかは，ターゲット定義である【NGKI0488】．こ
れらが使用できるかどうかは，それぞれ，INT8_MAX，UINT8_MAX，INT64_MAX，
UINT64_MAX，INT128_MAX，UINT128_MAX，FLOAT32_MAX，DOUBLE64_MAXがマクロ
定義されているかどうかで判別することができる【NGKI0489】．IEEE754準拠の
浮動小数点数がサポートされていない場合には，ターゲット定義で，
float32_tとdouble64_tは使用できないものとする【NGKI0490】．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>B，UB，H，UH，W，UW，D，UD，VP_INTに代えて，C99準拠のint8_t，uint8_t，
int16_t，uint16_t，int32_t，uint32_t，int64_t，uint64_t，intptr_tを用い
ることにした．また，uintptr_t，int128_t，uint128_tを用意することにした．</p>
</div>
<div class="paragraph">
<p>VPは，void *と等価であるため，用意しないことにした．また，ターゲットシ
ステムにより振舞いが一定しないことから，VB，VH，VW，VDに代わるデータ型
は用意しないことにした．</p>
</div>
<div class="paragraph">
<p>INT，UINTに代えて，C99の型名と相性が良いint_t，uint_tを用いることにした．
また，32ビット以上かつint_t型（またはuint_t型）以上のサイズが保証される
整数型として，long_t，ulong_tを用意し，8ビット以上のサイズで必ず存在す
る整数型として，C99準拠のint_least8_t，uint_least8_tを導入することにし
た．int_least16_t，uint_least16_t，int_least32_t，uint_least32_tを導入
しなかったのは，16ビットおよび32ビットの整数型があることを仮定しており，
それぞれint16_t，uint16_t，int32_t，uint32_tで代用できるためである．</p>
</div>
<div class="paragraph">
<p>TECSとの整合性を取るために，BOOLに代えて，bool_tを用いることにした．ま
た，IEEE754準拠の単精度浮動小数点数を表す型としてfloat32_t，IEEE754準拠
の64ビットを表す型としてdouble64_tを導入した．</p>
</div>
<div class="paragraph">
<p>性能評価用システム時刻のためのデータ型としてSYSUTMを，オブジェクト管理
領域を確保するためのデータ型としてMB_Tを用意することにした</p>
</div>
</div>
<div class="sect3">
<h4 id="_toppers共通定数">1.15.3. TOPPERS共通定数</h4>
<div class="paragraph">
<p>C90に規定されている定数以外で，TOPPERSソフトウェアで共通に用いる定数は
次の通りである（一部，C90に規定されているものも含む）．</p>
</div>
<div class="paragraph">
<p>(1) 一般定数【NGKI0491】</p>
</div>
<div class="literalblock">
<div class="content">
<pre>NULL					無効ポインタ</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>true			1		真
false			0		偽</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>E_OK			0		正常終了</pre>
</div>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>BOOLをbool_tに代えたことから，TRUEおよびFALSEに代えて，trueおよびfalse
を用いることにした．</p>
</div>
<div class="paragraph">
<p>(2) 整数型に格納できる最大値と最小値【NGKI0492】</p>
</div>
<div class="literalblock">
<div class="content">
<pre>INT8_MAX			int8_tに格納できる最大値（オプション，C99準拠）
INT8_MIN			int8_tに格納できる最小値（オプション，C99準拠）
UINT8_MAX			uint8_tに格納できる最大値（オプション，C99準拠）
INT16_MAX			int16_tに格納できる最大値（C99準拠）
INT16_MIN			int16_tに格納できる最小値（C99準拠）
UINT16_MAX			uint16_tに格納できる最大値（C99準拠）
INT32_MAX			int32_tに格納できる最大値（C99準拠）
INT32_MIN			int32_tに格納できる最小値（C99準拠）
UINT32_MAX			uint32_tに格納できる最大値（C99準拠）
INT64_MAX			int64_tに格納できる最大値（オプション，C99準拠）
INT64_MIN			int64_tに格納できる最小値（オプション，C99準拠）
UINT64_MAX			uint64_tに格納できる最大値（オプション，C99準拠）
INT128_MAX			int128_tに格納できる最大値（オプション，C99準拠）
INT128_MIN			int128_tに格納できる最小値（オプション，C99準拠）
UINT128_MAX			uint128_tに格納できる最大値（オプション，C99準拠）</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>INT_LEAST8_MAX		int_least8_tに格納できる最大値（C99準拠）
INT_LEAST8_MIN		int_least8_tに格納できる最小値（C99準拠）
UINT_LEAST8_MAX		uint_least8_tに格納できる最大値（C99準拠）
INT_MAX				int_tに格納できる最大値（C90準拠）
INT_MIN				int_tに格納できる最小値（C90準拠）
UINT_MAX			uint_tに格納できる最大値（C90準拠）
LONG_MAX			long_tに格納できる最大値（C90準拠）
LONG_MIN			long_tに格納できる最小値（C90準拠）
ULONG_MAX			ulong_tに格納できる最大値（C90準拠）</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>FLOAT32_MIN			float32_tに格納できる最小の正規化された正の浮
					動小数点数（オプション）
FLOAT32_MAX			float32_tに格納できる表現可能な最大の有限浮動
					小数点数（オプション）
DOUBLE64_MIN		double64_tに格納できる最小の正規化された正の浮
					動小数点数（オプション）
DOUBLE64_MAX		double64_tに格納できる表現可能な最大の有限浮動
					小数点数（オプション）</pre>
</div>
</div>
<div class="paragraph">
<p>(3) 整数型のビット数【NGKI0493】</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CHAR_BIT			char型のビット数（C90準拠）</pre>
</div>
</div>
<div class="paragraph">
<p>(4) オブジェクト属性【NGKI0494】</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TA_NULL		0U		オブジェクト属性を指定しない</pre>
</div>
</div>
<div class="paragraph">
<p>(5) タイムアウト指定【NGKI0495】</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TMO_POL		0		ポーリング
TMO_FEVR	-1		永久待ち
TMO_NBLK	-2		ノンブロッキング</pre>
</div>
</div>
<div class="paragraph">
<p>(6) アクセス許可パターン【NGKI0496】</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TACP_KERNEL		0U		カーネルドメインのみにアクセスを許可
TACP_SHARED		~0U		すべての保護ドメインにアクセスを許可</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="toppers_errorcode">1.15.4. TOPPERS共通エラーコード</h4>
<div class="paragraph">
<p>TOPPERSソフトウェアで共通に用いるメインエラーコードは次の通りである
【NGKI0497】．</p>
</div>
<div class="paragraph">
<p>(A) 内部エラークラス（EC_SYS，-5〜-8）</p>
</div>
<div class="literalblock">
<div class="content">
<pre>E_SYS		-5		システムエラー</pre>
</div>
</div>
<div class="paragraph">
<p>(B) 未サポートエラークラス（EC_NOSPT，-9〜-16）</p>
</div>
<div class="literalblock">
<div class="content">
<pre>E_NOSPT		-9		未サポート機能
E_RSFN		-10		予約機能コード
E_RSATR		-11		予約属性</pre>
</div>
</div>
<div class="paragraph">
<p>(C) パラメータエラークラス（EC_PAR，-17〜-24）</p>
</div>
<div class="literalblock">
<div class="content">
<pre>E_PAR		-17		パラメータエラー
E_ID		-18		不正ID番号</pre>
</div>
</div>
<div class="paragraph">
<p>(D) 呼出しコンテキストエラークラス（EC_CTX，-25〜-32）</p>
</div>
<div class="literalblock">
<div class="content">
<pre>E_CTX		-25		コンテキストエラー
E_MACV		-26		メモリアクセス違反
E_OACV		-27		オブジェクトアクセス違反
E_ILUSE		-28		サービスコール不正使用</pre>
</div>
</div>
<div class="paragraph">
<p>(E) 資源不足エラークラス（EC_NOMEM，-33〜-40）</p>
</div>
<div class="literalblock">
<div class="content">
<pre>E_NOMEM		-33		メモリ不足
E_NOID		-34		ID番号不足
E_NORES		-35		資源不足</pre>
</div>
</div>
<div class="paragraph">
<p>(F) オブジェクト状態エラークラス（EC_OBJ，-41〜-48）</p>
</div>
<div class="literalblock">
<div class="content">
<pre>E_OBJ		-41		オブジェクト状態エラー
E_NOEXS		-42		オブジェクト未登録
E_QOVR		-43		キューイングオーバフロー</pre>
</div>
</div>
<div class="paragraph">
<p>(G) 待ち解除エラークラス（EC_RLWAI，-49〜-56）</p>
</div>
<div class="literalblock">
<div class="content">
<pre>E_RLWAI		-49		待ち禁止状態または待ち状態の強制解除
E_TMOUT		-50		ポーリング失敗またはタイムアウト
E_DLT		-51		待ちオブジェクトの削除または再初期化
E_CLS		-52		待ちオブジェクトの状態変化</pre>
</div>
</div>
<div class="paragraph">
<p>(H) 警告クラス（EC_WARN，-57〜-64）</p>
</div>
<div class="literalblock">
<div class="content">
<pre>E_WBLK		-57		ノンブロッキング受付け
E_BOVR		-58		バッファオーバフロー</pre>
</div>
</div>
<div class="paragraph">
<p>このエラークラスに属するエラーコードは，警告を表すエラーコードであり，
［NGKI0019］の原則では例外としている．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>E_NORESは，μITRON4.0仕様に規定されていないエラーコードである．</p>
</div>
</div>
<div class="sect3">
<h4 id="_toppers共通マクロ">1.15.5. TOPPERS共通マクロ</h4>
<div class="paragraph">
<p>(1) 整数定数を作るマクロ【NGKI0498】</p>
</div>
<div class="literalblock">
<div class="content">
<pre>INT8_C(val)			int_least8_t型の定数を作るマクロ（C99準拠）
UINT8_C(val)		uint_least8_t型の定数を作るマクロ（C99準拠）
INT16_C(val)		int16_t型の定数を作るマクロ（C99準拠）
UINT16_C(val)		uint16_t型の定数を作るマクロ（C99準拠）
INT32_C(val)		int32_t型の定数を作るマクロ（C99準拠）
UINT32_C(val)		uint32_t型の定数を作るマクロ（C99準拠）
INT64_C(val)		int64_t型の定数を作るマクロ（オプション，C99準拠）
UINT64_C(val)		uint64_t型の定数を作るマクロ（オプション，C99準拠）
INT128_C(val)		int128_t型の定数を作るマクロ（オプション，C99準拠）
UINT128_C(val)		uint128_t型の定数を作るマクロ（オプション，C99準拠）</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>UINT_C(val)			uint_t型の定数を作るマクロ
ULONG_C(val)		ulong_t型の定数を作るマクロ</pre>
</div>
</div>
<div class="paragraph">
<p>【仕様決定の理由】</p>
</div>
<div class="paragraph">
<p>C99に用意されていないUINT_CとULONG_Cを導入したのは，アセンブリ言語から
も参照する定数を記述するためである．C言語のみで用いる定数をこれらのマク
ロを使って記述する必要はない．</p>
</div>
<div class="paragraph">
<p>(2) 型に関する情報を取り出すためのマクロ【NGKI0499】</p>
</div>
<div class="literalblock">
<div class="content">
<pre>offsetof(structure, field)	構造体structure中のフィールドfieldの
							バイト位置を返すマクロ（C90準拠）</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>alignof(type)				型typeのアラインメント単位を返すマクロ</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>ALIGN_TYPE(addr, type)		番地addrが型typeに対してアラインしてい
							るかどうかを返すマクロ</pre>
</div>
</div>
<div class="paragraph">
<p>(3) assertマクロ【NGKI0500】</p>
</div>
<div class="literalblock">
<div class="content">
<pre>assert(exp)			expが成立しているかを検査するマクロ（C90準拠）</pre>
</div>
</div>
<div class="paragraph">
<p>(4) コンパイラの拡張機能のためのマクロ【NGKI0501】</p>
</div>
<div class="literalblock">
<div class="content">
<pre>inline				インライン関数
Inline				ファイルローカルなインライン関数
asm					インラインアセンブラ
Asm					インラインアセンブラ（最適化抑止）
throw()				例外を発生しない関数
NoReturn			リターンしない関数</pre>
</div>
</div>
<div class="paragraph">
<p>(5) エラーコード構成・分解マクロ【NGKI0502】</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ERCD(mercd, sercd)	メインエラーコードmercdとサブエラーコードsercdか
					ら，エラーコードを構成するためのマクロ</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>MERCD(ercd)			エラーコードercdからメインエラーコードを抽出する
					ためのマクロ
SERCD(ercd)			エラーコードercdからサブエラーコードを抽出するた
					めのマクロ</pre>
</div>
</div>
<div class="paragraph">
<p>(6) アクセス許可パターン構成マクロ【NGKI0503】</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TACP(domid)			domidで指定されるユーザドメインのみにアクセスを
					許可するアクセス許可パターンを構成するためのマ
					クロ</pre>
</div>
</div>
<div class="paragraph">
<p>ここで，TACPのパラメータ（domid）には，ユーザドメインのID番号のみを指定
することができる【NGKI0504】．TDOM_SELF，TDOM_KERNEL，TDOM_NONEを指定し
た場合，どのようなアクセス許可パターンが構成されるかは保証されない
【NGKI0505】．</p>
</div>
</div>
<div class="sect3">
<h4 id="_toppers共通構成マクロ">1.15.6. TOPPERS共通構成マクロ</h4>
<div class="paragraph">
<p>(1) 相対時間の範囲【NGKI0506】</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TMAX_RELTIM		相対時間に指定できる最大値</pre>
</div>
</div>
<div class="paragraph">
<p>2.15 カーネル共通定義</p>
</div>
<div class="paragraph">
<p>カーネルの複数の機能で共通に用いる定義を，カーネル共通定義と呼ぶ．</p>
</div>
<div class="paragraph">
<p>2.15.1 カーネルヘッダファイル</p>
</div>
<div class="paragraph">
<p>カーネルを用いるために必要な定義は，カーネルヘッダファイル（kernel.h）
およびそこからインクルードされるファイルに含まれている【NGKI0507】．カー
ネルを用いる場合には，カーネルヘッダファイルをインクルードする
【NGKI0508】．</p>
</div>
<div class="paragraph">
<p>ただし，カーネルを用いるために必要な定義の中で，コンフィギュレータによっ
て生成されるものは，カーネル構成・初期化ヘッダファイル（kernel_cfg.h）
に含まれる【NGKI0509】．具体的には，登録できるオブジェクトの数
（TNUM_YYY）やオブジェクトのID番号などの定義が，これに該当する．これら
の定義を用いる場合には，カーネル構成・初期化ヘッダファイルをインクルー
ドする【NGKI0510】．</p>
</div>
<div class="paragraph">
<p>μITRON4.0仕様で規定されており，この仕様で廃止されたデータ型および定数
を用いる場合には，ITRON仕様互換ヘッダファイル（itron.h）をインクルード
する【NGKI0511】．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>この仕様では，コンフィギュレータが生成するヘッダファイルに，オブジェク
トのID番号の定義に加えて，登録できるオブジェクトの数（TNUM_YYY）の定義
が含まれることとした．これに伴い，ヘッダファイルの名称を，μITRON4.0仕
様の自動割付け結果ヘッダファイル（kernel_id.h）から，カーネル構成・初期
化ヘッダファイル（kernel_cfg.h）に変更した．</p>
</div>
</div>
<div class="sect3">
<h4 id="_カーネル共通定数">1.15.7. カーネル共通定数</h4>
<div class="paragraph">
<p>(1) オブジェクト属性【NGKI0512】</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TA_TPRI			0x01U	タスクの待ち行列をタスクの優先度順に</pre>
</div>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>値が0のオブジェクト属性（TA_HLNG，TA_TFIFO，TA_MFIFO，TA_WSGL）は，デフォ
ルトの扱いにして廃止した．これは，「(tskatr &amp; TA_HLNG) != 0U」のような
間違いを防ぐためである．TA_ASMは，有効な使途がないために廃止した．
TA_MPRIは，メールボックス機能でのみ使用するため，カーネル共通定義から外
した．</p>
</div>
<div class="paragraph">
<p>(2) 保護ドメインID【NGKI0513】</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TDOM_SELF		0		自タスクの属する保護ドメイン
TDOM_KERNEL		-1		カーネルドメイン
TDOM_NONE		-2		無所属（保護ドメインに属さない）</pre>
</div>
</div>
<div class="paragraph">
<p>(3) その他のカーネル共通定数【NGKI0514】</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TCLS_SELF		0		自タスクの属するクラス</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>TPRC_NONE		0		割付けプロセッサの指定がない
TPRC_INI		0		初期割付けプロセッサ</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>TSK_SELF		0		自タスク指定
TSK_NONE		0		該当するタスクがない</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>TPRI_SELF		0		自タスクのベース優先度の指定
TPRI_INI		0		タスクの起動時優先度の指定</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>TIPM_ENAALL		0		割込み優先度マスク全解除</pre>
</div>
</div>
<div class="paragraph">
<p>(4) カーネルで用いるメインエラーコード</p>
</div>
<div class="paragraph">
<p>「<a href="#toppers_errorcode">TOPPERS共通エラーコード</a>」の節で定義したメインエラーコードの中
で，E_CLS，E_WBLK，E_BOVRの3つは，カーネルでは使用しない【NGKI0515】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/ASPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>ASPカーネルでは，サービスコールから，E_RSFN，E_RSATR，E_MACV，E_OACV，
E_NOMEM，E_NOID，E_NORES，E_NOEXSが返る状況は起こらない【ASPS0011】．
E_RSATRは，コンフィギュレータによって検出される【ASPS0012】．ただし，動
的生成機能拡張パッケージでは，サービスコールから，E_RSATR，E_NOMEM，
E_NOID，E_NOEXSが返る状況が起こる【ASPS0013】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/FMPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>FMPカーネルでは，サービスコールから，E_RSFN，E_RSATR，E_MACV，E_OACV，
E_NOMEM，E_NOID，E_NORES，E_NOEXSが返る状況は起こらない【FMPS0007】．
E_RSATRとE_NORESは，コンフィギュレータによって検出される【FMPS0008】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/HRP2カーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>HRP2カーネルでは，サービスコールから，E_RSATR，E_NOMEM，E_NOID，
E_NORES，E_NOEXSが返る状況は起こらない【HRPS0006】．E_RSATRは，コンフィ
ギュレータによって検出される【HRPS0007】．ただし，動的生成機能拡張パッ
ケージでは，サービスコールから，E_RSATR，E_NOMEM，E_NOID，E_NOEXSが返る
状況が起こる【HRPS0011】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/SSPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>SSPカーネルでは，サービスコールから，E_RSFN，E_RSATR，E_MACV，E_OACV，
E_ILUSE，E_NOMEM，E_NOID，E_NORES，E_NOEXS，E_RLWAI，E_TMOUT，E_DLTが返
る状況は起こらない【SSPS0008】．E_RSATRは，コンフィギュレータによって検
出される【SSPS0009】．</p>
</div>
</div>
<div class="sect3">
<h4 id="_カーネル共通マクロ">1.15.8. カーネル共通マクロ</h4>
<div class="paragraph">
<p>(1) スタック領域をアプリケーションで確保するためのデータ型とマクロ</p>
</div>
<div class="paragraph">
<p>スタック領域をアプリケーションで確保するために，次のデータ型とマクロを
用意している【NGKI0516】．</p>
</div>
<div class="literalblock">
<div class="content">
<pre>STK_T				スタック領域を確保するためのデータ型</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>COUNT_STK_T(sz)		サイズszのスタック領域を確保するために必要な
					STK_T型の配列の要素数
ROUND_STK_T(sz)		要素数COUNT_STK_T(sz)のSTK_T型の配列のサイズ（sz
					を，STK_T型のサイズの倍数になるように大きい方に
					丸めた値）</pre>
</div>
</div>
<div class="paragraph">
<p>これらを用いてスタック領域を確保する方法は次の通り【NGKI0517】．</p>
</div>
<div class="paragraph">
<p>STK_T	&lt;スタック領域の変数名&gt;[COUNT_STK_T(&lt;スタック領域のサイズ&gt;)];</p>
</div>
<div class="paragraph">
<p>この方法で確保したスタック領域を，サービスコールまたは静的APIに渡す場合
には，スタック領域の先頭番地に&lt;スタック領域の変数名&gt;を，スタック領域の
サイズにROUND_STK_T(&lt;スタック領域のサイズ&gt;)を指定する【NGKI0518】．</p>
</div>
<div class="paragraph">
<p>ただし，保護機能対応カーネルにおいては，上の方法によりタスクのユーザス
タック領域を確保することはできない【NGKI0519】．詳しくは，「4.1 タスク
管理機能」の節のCRE_TSKの機能の項を参照すること．</p>
</div>
<div class="paragraph">
<p>(2) オブジェクト属性を作るマクロ</p>
</div>
<div class="paragraph">
<p>保護機能対応カーネルでは，オブジェクトが属する保護ドメインを指定するた
めのオブジェクト属性を作るマクロとして，次のマクロを用意している
【NGKI0520】．</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TA_DOM(domid)		domidで指定される保護ドメインに属する</pre>
</div>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，オブジェクトが属するクラスを指定する
ためのオブジェクト属性を作るマクロとして，次のマクロを用意している
【NGKI0521】．</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TA_CLS(clsid)		clsidで指定されるクラスに属する</pre>
</div>
</div>
<div class="paragraph">
<p>(3) サービスコールの呼出し方法を指定するマクロ</p>
</div>
<div class="paragraph">
<p>保護機能対応カーネルでは，サービスコールの呼出し方法を指定するためのマ
クロとして，次のマクロを用意している【NGKI0522】．</p>
</div>
<div class="literalblock">
<div class="content">
<pre>SVC_CALL(svc)		svcで指定されるサービスコールを関数呼出しによっ
					て呼び出すための名称</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_カーネル共通構成マクロ">1.15.9. カーネル共通構成マクロ</h4>
<div class="paragraph">
<p>(1) サポートする機能【NGKI0523】</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TOPPERS_SUPPORT_PROTECT			保護機能対応のカーネル
TOPPERS_SUPPORT_MULTI_PRC		マルチプロセッサ対応のカーネル
TOPPERS_SUPPORT_DYNAMIC_CRE		動的生成対応のカーネル</pre>
</div>
</div>
<div class="paragraph">
<p>【未決定事項】</p>
</div>
<div class="paragraph">
<p>マクロ名は，今後変更する可能性がある．</p>
</div>
<div class="paragraph">
<p>(2) 優先度の範囲【NGKI0524】</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TMIN_TPRI		タスク優先度の最小値（＝1）
TMAX_TPRI		タスク優先度の最大値</pre>
</div>
</div>
<div class="paragraph">
<p>【TOPPERS/ASPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>ASPカーネルでは，タスク優先度の最大値（TMAX_TPRI）は16に固定されている
【ASPS0014】．ただし，タスク優先度拡張パッケージを用いると，TMAX_TPRIを
256に拡張することができる【ASPS0015】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/FMPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>FMPカーネルでは，タスク優先度の最大値（TMAX_TPRI）は16に固定されている
【FMPS0009】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/HRP2カーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>HRP2カーネルでは，タスク優先度の最大値（TMAX_TPRI）は16に固定されている
【HRPS0008】．</p>
</div>
<div class="paragraph">
<p>【TOPPERS/SSPカーネルにおける規定】</p>
</div>
<div class="paragraph">
<p>SSPカーネルでは，タスク優先度の最大値（TMAX_TPRI）は16に固定されている
【SSPS0010】．</p>
</div>
<div class="paragraph">
<p>【μITRON4.0仕様との関係】</p>
</div>
<div class="paragraph">
<p>メッセージ優先度の最小値（TMIN_MPRI）と最大値（TMAX_MPRI）は，メールボッ
クス機能でのみ使用するため，カーネル共通定義から外した．</p>
</div>
<div class="paragraph">
<p>(3) プロセッサの数</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，プロセッサの数を知るためのマクロとし
て，次の構成マクロを用意している【NGKI0525】．</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TNUM_PRCID		プロセッサの数</pre>
</div>
</div>
<div class="paragraph">
<p>(4) 特殊な役割を持ったプロセッサ</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，特殊な役割を持ったプロセッサを知るた
めのマクロとして，次の構成マクロを用意している【NGKI0526】．</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TOPPERS_MASTER_PRCID		マスタプロセッサのID番号
TOPPERS_SYSTIM_PRCID		システム時刻管理プロセッサのID番号（グ
							ローバルタイマ方式の場合のみ）</pre>
</div>
</div>
<div class="paragraph">
<p>(5) タイマ方式</p>
</div>
<div class="paragraph">
<p>マルチプロセッサ対応カーネルでは，システム時刻の方式を知るためのマクロ
として，次の構成マクロを用意している【NGKI0527】．</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TOPPERS_SYSTIM_LOCAL		ローカルタイマ方式の場合にマクロ定義
TOPPERS_SYSTIM_GLOBAL		グローバルタイマ方式の場合にマクロ定義</pre>
</div>
</div>
<div class="paragraph">
<p>(6) バージョン情報【NGKI0528】</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TKERNEL_MAKER		カーネルのメーカコード（＝0x0118）
TKERNEL_PRID		カーネルの識別番号
TKERNEL_SPVER		カーネル仕様のバージョン番号
TKERNEL_PRVER		カーネルのバージョン番号</pre>
</div>
</div>
<div class="paragraph">
<p>カーネルのメーカコード（TKERNEL_MAKER）は，TOPPERSプロジェクトから配布
するカーネルでは，TOPPERSプロジェクトを表す値（0x0118）に設定されている．</p>
</div>
<div class="paragraph">
<p>カーネルの識別番号（TKERNEL_PRID）は，TOPPERSカーネルの種類を表す．</p>
</div>
<div class="literalblock">
<div class="content">
<pre>0x0001		TOPPERS/JSPカーネル
0x0002		予約（IIMPカーネル）
0x0003		予約（IDLカーネル）
0x0004		TOPPERS/FI4カーネル
0x0005		TOPPERS/FDMPカーネル
0x0006		TOPPERS/HRPカーネル
0x0007		TOPPERS/ASPカーネル
0x0008		TOPPERS/FMPカーネル
0x0009		TOPPERS/SSPカーネル
0x000a		TOPPERS/ASP Safetyカーネル</pre>
</div>
</div>
<div class="paragraph">
<p>カーネル仕様のバージョン番号（TKERNEL_SPVER）は，上位8ビット（0xf5）が
TOPPERS新世代カーネル仕様であることを，中位4ビットがメジャーバージョン
番号，下位4ビットがマイナーバージョン番号を表す．</p>
</div>
<div class="paragraph">
<p>カーネルのバージョン番号（TKERNEL_PRVER）は，上位4ビットがメジャーバー
ジョン番号，中位8ビットがマイナーバージョン番号，下位4ビットがパッチレ
ベルを表す．</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2016-07-20 01:21:51 UTC
</div>
</div>
</body>
</html>