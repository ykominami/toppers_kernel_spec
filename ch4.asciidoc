:numbered:
[[ch4_kernel_api, カーネルAPI仕様]]
==　カーネルAPI仕様

この章では，カーネルのAPI仕様について規定する．

【μITRON4.0仕様との関係】

TOPPERS共通データ型に従い，パラメータのデータ型を次の通り変更した．これ
らの変更については，個別のAPI仕様では記述しない．

	INT → int_t
	UINT → uint_t
	VP → void *
	VP_INT → intptr_t

【μITRON4.0/PX仕様との関係】

ID番号で識別するオブジェクトのアクセス許可ベクタをデフォルト以外に設定
する場合には，オブジェクトを生成した後に設定することとし，アクセス許可
ベクタを設定する静的API（SAC_YYY）を新設した．逆に，アクセス許可ベクタ
を指定してオブジェクトを生成する機能（CRA_YYY，cra_yyy，acra_yyy）は廃
止した．これらの変更については，個別のAPI仕様では記述しない．

=== タスク管理機能

タスクは，プログラムの並行実行の単位で，カーネルが実行を制御する処理単
位である．タスクは，タスクIDと呼ぶID番号によって識別する【NGKI1001】．

タスク管理機能に関連して，各タスクが持つ情報は次の通り【NGKI1002】．

* タスク属性
* タスク状態
* ベース優先度
* 現在優先度
* 起動要求キューイング数
* 割付けプロセッサ（マルチプロセッサ対応カーネルの場合）
* 次回起動時の割付けプロセッサ（マルチプロセッサ対応カーネルの場合）
* 拡張情報
* メインルーチンの先頭番地
* 起動時優先度
* 実行時優先度（TOPPERS/SSPカーネルの場合）
* スタック領域
* システムスタック領域（保護機能対応カーネルの場合）
* アクセス許可ベクタ（保護機能対応カーネルの場合）
* 属する保護ドメイン（保護機能対応カーネルの場合）
* 属するクラス（マルチプロセッサ対応カーネルの場合）

タスクのベース優先度は，タスクの現在優先度を決定するために使われる優先
度であり，タスクの起動時に起動時優先度に初期化される【NGKI1003】．

タスクの現在優先度は，タスクの実行順位を決定するために使われる優先度で
ある．単にタスクの優先度と言った場合には，現在優先度のことを指す．タス
クがミューテックスをロックしていない間は，タスクの現在優先度はベース優
先度に一致する【NGKI1004】．ミューテックスをロックしている間のタスクの
現在優先度については，「4.4.6 ミューテックス」の節を参照すること．

タスクの起動要求キューイング数は，処理されていないタスクの起動要求の数
であり，タスクの生成時に0に初期化される【NGKI1005】．

割付けプロセッサは，マルチプロセッサ対応カーネルにおいて，タスクを実行
するプロセッサで，タスクの生成時に，タスクが属するクラスによって定まる
初期割付けプロセッサに初期化される【NGKI1006】．

次回起動時の割付けプロセッサは，マルチプロセッサ対応カーネルにおいて，
タスクが次に起動される時に割り付けられるプロセッサで，タスクの生成時に
未設定の状態に初期化される【NGKI1007】．タスクの起動時に，次回起動時の
割付けプロセッサが設定されていれば，タスクの割付けプロセッサがそのプロ
セッサに変更され，次回起動時の割付けプロセッサは未設定の状態に戻される
【NGKI1008】．次回起動時の割付けプロセッサが未設定の場合には，タスクの
割付けプロセッサは変更されない（つまり，タスクが前に実行されていたのと
同じプロセッサで実行される）【NGKI1009】．

保護機能対応カーネルにおいては，スタック領域の扱いは，ユーザタスクとシ
ステムタスクで異なる．ユーザタスクのスタック領域は，ユーザタスクが非特
権モードで実行する間に用いるスタック領域であり，ユーザスタック領域と呼
ぶ【NGKI1010】．その扱いについては，「2.11.6 ユーザタスクのユーザスタッ
ク領域」の節を参照すること．システムタスクのスタック領域は，カーネルの
用いるオブジェクト管理領域と同様に扱われる【NGKI1011】．

システムスタック領域は，保護機能対応カーネルにおいて，ユーザタスクがサー
ビスコール（拡張サービスコールを含む）を呼び出し，特権モードで実行する
間に用いるスタック領域である【NGKI1012】．システムスタック領域は，カー
ネルの用いるオブジェクト管理領域と同様に扱われる【NGKI1013】．

タスク属性には，次の属性を指定することができる【NGKI1014】．

	TA_ACT		0x02U	タスクの生成時にタスクを起動する
	TA_RSTR		0x04U	生成するタスクを制約タスクとする

TA_ACTを指定しない場合，タスクの生成直後には，タスクは休止状態となる
【NGKI1015】．また，ターゲットによっては，ターゲット定義のタスク属性を
指定できる場合がある【NGKI1016】．ターゲット定義のタスク属性として，次
の属性を予約している【NGKI1017】．

	TA_FPU				FPUレジスタをコンテキストに含める

タスク終了時には，次の処理が行われる．まず，終了するタスク（対象タスク）
に対してタスク終了時に行うべきその他の処理が行われた後，対象タスクは休
止状態になる【NGKI1178】．対象タスクの起動要求キューイング数が0でない場
合には，対象タスクに対してタスク起動時に行うべき処理が行われ，対象タス
クは実行できる状態になる【NGKI1179】．またこの時，起動要求キューイング
数から1が減ぜられる【NGKI1180】．

C言語によるタスクの記述形式は次の通り【NGKI1018】．

[source.c]
----
	void task(intptr_t exinf)
	{
		タスク本体
		ext_tsk();
	}
----

exinfには，タスクの拡張情報が渡される【NGKI1019】．ext_tskを呼び出さず，
タスクのメインルーチンからリターンした場合，ext_tskを呼び出した場合と同
じ動作をする【NGKI1020】．

タスク管理機能に関連するカーネル構成マクロは次の通り．

	TMAX_ACTCNT		タスクの起動要求キューイング数の最大値【NGKI1021】

	TNUM_TSKID		登録できるタスクの数（動的生成対応でないカーネルで
					は，静的APIによって登録されたタスクの数に一致）
					【NGKI1022】

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，TMAX_ACTCNTは1に固定されている【ASPS0101】．また，制約
タスクはサポートしていない【ASPS0102】．ただし，制約タスク拡張パッケー
ジを用いると，制約タスクの機能を追加することができる【ASPS0103】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，TMAX_ACTCNTは1に固定されている【FMPS0101】．また，制約
タスクはサポートしていない【FMPS0102】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，TMAX_ACTCNTは1に固定されている【HRPS0101】．また，制
約タスクはサポートしていない【HRPS0102】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，TMAX_ACTCNTは1に固定されている【SSPS0101】．

SSPカーネルは，制約タスクのみをサポートすることから，すべてのタスクでス
タック領域を共有しており，タスク毎にスタック領域の情報を持たない
【SSPS0102】．

SSPカーネルにおける追加機能として，タスクに対して，実行時優先度の情報を
持つ【SSPS0103】．SSPカーネルにおいては，タスクが起動された後，最初に実
行状態になる時に，タスクのベース優先度が，タスクの実行時優先度に設定さ
れる【SSPS0104】．実行時優先度の機能は，起動時優先度よりも高い優先度で
タスクを実行することで，同時期に共有スタック領域を使用している状態にな
るタスクの組み合わせを限定し，スタック領域を節約するための機能である．

タスクの実行時優先度は，実行時優先度を定義する静的API（DEF_EPR）によっ
て設定する【SSPS0105】．実行時優先度を定義しない場合，タスクの実行時優
先度は，起動時優先度と同じ値に設定される【SSPS0106】．

〔実行時優先度によるスタック領域の節約〕

いずれのタスクにも実行時優先度が設定されていない場合には，すべてのタス
クが同時期に共有スタック領域を使用している状態になる可能性があるため，
すべてのタスクのスタック領域のサイズの和に，非タスクコンテキスト用のス
タック領域のサイズを加えたものが，共有スタック領域に必要なサイズとなる．

タスクAに対して実行時優先度が設定されており，タスクAの起動時優先度より
も高く，タスクAの実行時優先度と同じかそれよりも低い起動時優先度を持つタ
スクBがある場合，タスクAとタスクBは同時期に共有スタック領域を使用してい
る状態にならない．そのため，タスクAとタスクBの内，サイズが小さい方のス
タック領域のサイズは，共有スタック領域のサイズに加える必要がなくなり，
スタック領域を節約できることになる．

【μITRON4.0仕様との関係】

この仕様では，自タスクの拡張情報の参照するサービスコール（get_inf）をサ
ポートし，起動コードを指定してタスクを起動するサービスコール（sta_tsk），
タスクを終了と同時に削除するサービスコール（exd_tsk），タスクの状態を参
照するサービスコールの簡易版（ref_tst）はサポートしないこととした．

TNUM_TSKIDは，μITRON4.0仕様に規定されていないカーネル構成マクロである．

[[API_CRE_TSK]]
CRE_TSK		タスクの生成〔S〕【NGKI1023】 +
acre_tsk	タスクの生成〔TD〕【NGKI1024】

【静的API】

保護機能対応でないカーネルの場合
[source,c]
----
CRE_TSK(ID tskid, { ATR tskatr, intptr_t exinf, TASK task,
		PRI itskpri, SIZE stksz, STK_T *stk })
----

保護機能対応カーネルの場合
[source,c]
----
	CRE_TSK(ID tskid, { ATR tskatr, intptr_t exinf, TASK task,
			PRI itskpri, SIZE stksz, STK_T *stk, SIZE sstksz, STK_T *sstk })
----
	※ sstkszおよびsstkの記述は省略することができる【NGKI1025】．

【C言語API】
----
	ER_ID tskid = acre_tsk(const T_CTSK *pk_ctsk)
----

【パラメータ】
----
	ID			tskid		生成するタスクのID番号（CRE_TSKの場合）
	T_CTSK *	pk_ctsk		タスクの生成情報を入れたパケットへのポイン
							タ（静的APIを除く）
----

　＊タスクの生成情報（パケットの内容）
	ATR			tskatr		タスク属性
	intptr_t	exinf		タスクの拡張情報
	TASK		task		タスクのメインルーチンの先頭番地
	PRI			itskpri		タスクの起動時優先度
	SIZE		stksz		タスクのスタック領域のサイズ（バイト数）
	STK_T *		stk			タスクのスタック領域の先頭番地
	SIZE		sstksz		タスクのシステムスタック領域のサイズ（バイ
							ト数，保護機能対応カーネルの場合，静的API
							においては省略可）
	STK_T *		sstk		タスクのシステムスタック領域の先頭番地（保
							護機能対応カーネルの場合，静的APIにおいて
							は省略可）

【リターンパラメータ】
----
	ER_ID		tskid		生成されたタスクのID番号（正の値）またはエ
							ラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI1026】
				・CPUロック状態からの呼出し〔s〕【NGKI1027】
	E_RSATR		予約属性
				・tskatrが無効【NGKI1028】
				・属する保護ドメインの指定が有効範囲外または無所属〔sP〕
				　【NGKI1029】
				・保護ドメインの囲みの中に記述されていない〔SP〕【NGKI1030】
				・属するクラスの指定が有効範囲外〔sM〕【NGKI1031】
				・クラスの囲みの中に記述されていない〔SM〕【NGKI1032】
	E_PAR		パラメータエラー
				・taskがプログラムの先頭番地として正しくない【NGKI1033】
				・itskpriが有効範囲外【NGKI1034】
				・その他の条件については機能の項を参照
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する管理操作が許可されていない〔sP〕
				　【NGKI1035】
	E_MACV		メモリアクセス違反
				・pk_ctskが指すメモリ領域への読出しアクセスが許可されて
				　いない〔sP〕【NGKI1036】
	E_NOID		ID番号不足
				・割り付けられるタスクIDがない〔sD〕【NGKI1037】
	E_NOMEM		メモリ不足
				・スタック領域が確保できない【NGKI1038】
				・システムスタック領域が確保できない〔P〕【NGKI1039】
	E_OBJ		オブジェクト状態エラー
				・tskidで指定したタスクが登録済み（CRE_TSKの場合）【NGKI1040】
				・その他の条件については機能の項を参照
----

【機能】

各パラメータで指定したタスク生成情報に従って，タスクを生成する．具体的
な振舞いは以下の通り．

まず，stkとstkszからタスクが用いるスタック領域が設定される【NGKI1041】．
ただし，保護機能対応カーネルで，生成するタスクがシステムタスクの場合に
は，スタック領域の設定にsstkszも用いられる．stkszに0以下の値を指定した
時や，設定されるスタック領域のサイズがターゲット定義の最小値よりも小さ
くなる時には，E_PARエラーとなる【NGKI1042】．

また，保護機能対応カーネルで，生成するタスクがユーザタスクの場合には，
sstkとsstkszからシステムスタック領域が設定される【NGKI1043】．この場合，
sstkszに0以下の値を指定した時や，ターゲット定義の最小値よりも小さい値を
指定した時には，E_PARエラーとなる【NGKI1044】．

次に，生成されたタスクに対してタスク生成時に行うべき初期化処理が行われ，
生成されたタスクは休止状態になる【NGKI1045】．さらに，tskatrにTA_ACTを
指定した場合には，タスク起動時に行うべき初期化処理が行われ，生成された
タスクは実行できる状態になる【NGKI1046】．

静的APIにおいては，tskidはオブジェクト識別名，tskatr，itskpri，stkszは
整数定数式パラメータ，exinf，task，stkは一般定数式パラメータである
【NGKI1047】．コンフィギュレータは，静的APIのメモリ不足（E_NOMEM）エラー
を検出することができない【NGKI1048】．

〔stkにNULLを指定した場合〕

stkをNULLとした場合，stkszで指定したサイズのスタック領域が，コンフィギュ
レータまたはカーネルにより確保される【NGKI1049】．stkszにターゲット定義
の制約に合致しないサイズを指定した時には，ターゲット定義の制約に合致す
るように大きい方に丸めたサイズで確保される【NGKI1050】．

保護機能対応カーネルにおいて，生成するタスクがユーザタスクの場合，コン
フィギュレータまたはカーネルにより確保されるスタック領域（ユーザスタッ
ク領域）は，「2.11.6 ユーザタスクのユーザスタック領域」の節の規定に従っ
て，メモリオブジェクトとしてカーネルに登録される【NGKI1051】．

静的APIにより制約タスクを生成する場合（tskatrにTA_RSTRを指定して生成す
る場合），スタック領域は，制約タスクの起動時優先度毎に確保され，同じ起
動時優先度を持つ制約タスクで共有される【NGKI1052】．確保されるスタック
領域のサイズは，それを共有する制約タスクのスタック領域のサイズ（stksz）
の最大値となる【NGKI1053】．マルチプロセッサ対応カーネルでは，以上のス
タック領域の確保処理を，制約タスクの初期割付けプロセッサ毎に行う
【NGKI1054】．

〔stkにNULL以外を指定した場合〕

stkにNULL以外を指定した場合，stkとstkszで指定したスタック領域は，アプリ
ケーションで確保しておく必要がある【NGKI1055】．スタック領域をアプリケー
ションで確保する方法については，「2.15.3 カーネル共通マクロ」の節を参照
すること．その方法に従わず，stkやstkszにターゲット定義の制約に合致しな
い先頭番地やサイズを指定した時には，E_PARエラーとなる【NGKI1056】．

保護機能対応カーネルにおいて，生成するタスクがシステムタスクの場合に，
stkとstkszで指定したスタック領域がカーネル専用のメモリオブジェクトに含
まれない場合，E_OBJエラーとなる【NGKI1057】．

保護機能対応カーネルにおいて，生成するタスクがユーザタスクの場合，stkと
stkszで指定したスタック領域（ユーザスタック領域）は，「2.11.6 ユーザタ
スクのユーザスタック領域」の節の規定に従って，メモリオブジェクトとして
カーネルに登録される【NGKI1058】．そのため，上の方法を用いてスタック領
域を確保しても，ターゲット定義の制約に合致する先頭番地とサイズとなると
は限らず，スタック領域をアプリケーションで確保する方法は，ターゲット定
義である【NGKI1059】．また，stkとstkszで指定したスタック領域が，登録済
みのメモリオブジェクトとメモリ領域が重なる場合には，E_OBJエラーとなる
【NGKI1060】．

〔sstkとsstkszの扱い〕

保護機能対応カーネルにおけるsstkとsstkszの扱いは，生成するタスクがユー
ザタスクの場合とシステムタスクの場合で異なる．

生成するタスクがユーザタスクの場合の扱いは次の通り．

sstkの記述を省略するか，sstkをNULLとした場合，sstkszで指定したサイズの
システムスタック領域が，コンフィギュレータまたはカーネルにより確保され
る【NGKI1061】．sstkszにターゲット定義の制約に合致しないサイズを指定し
た時には，ターゲット定義の制約に合致するように大きい方に丸めたサイズで
確保される【NGKI1062】．sstkszの記述も省略した場合には，ターゲット定義
のデフォルトのサイズで確保される【NGKI1063】．

sstkにNULL以外を指定した場合，sstkとsstkszで指定したスタック領域は，ア
プリケーションで確保しておく必要がある【NGKI1064】．スタック領域をアプ
リケーションで確保する方法については，「2.15.3 カーネル共通マクロ」の節
を参照すること．その方法に従わず，sstkやsstkszにターゲット定義の制約に
合致しない先頭番地やサイズを指定した時には，E_PARエラーとなる
【NGKI1065】．また，stkとstkszで指定したシステムスタック領域がカーネル
専用のメモリオブジェクトに含まれない場合，E_OBJエラーとなる【NGKI1066】．

生成するタスクがシステムタスクの場合の扱いは次の通り．

sstkに指定することができるのは，NULLのみである．sstkにNULL以外を指定し
た場合には，E_PARエラーとなる【NGKI1068】．

sstkszに0以外の値を指定した場合で，stkがNULLの場合には，コンフィギュレー
タまたはカーネルにより確保されるスタック領域のサイズに，sstkszが加えら
れる【NGKI1069】．stkszにsstkszを加えた値が，ターゲット定義の制約に合致
しないサイズになる時には，ターゲット定義の制約に合致するように大きい方
に丸めたサイズで確保される【NGKI1070】．

sstkszに0以外の値を指定した場合で，stkがNULLでない場合には，E_PARエラー
となる【NGKI1071】．

sstkszに0を指定した場合，これらの処理は行わず，E_PARエラーにもならない
【NGKI1072】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，CRE_TSKのみをサポートする【ASPS0104】．ただし，動的生
成機能拡張パッケージでは，acre_tskもサポートする【ASPS0105】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，CRE_TSKのみをサポートする【FMPS0103】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，CRE_TSKのみをサポートする【HRPS0103】．

動的生成機能拡張パッケージでは，acre_tskもサポートする【HRPS0175】．た
だし，生成するタスクがユーザタスクの場合，stkにNULLが指定されるとカーネ
ルがスタック領域を確保する機能はサポートしない．stkにNULLを指定した場合
には，E_NOSPTエラーとなる【HRPS0176】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，CRE_TSKのみをサポートする【SSPS0107】．

SSPカーネルでは，複数のタスクに対して，同じ起動時優先度を設定することは
できない．設定した場合には，コンフィギュレータがE_PARエラーを報告する
【SSPS0109】．

SSPカーネルでは，制約タスクのみをサポートするため，タスク属性にTA_RSTR
を指定しない場合でも，生成されるタスクは制約タスクとなる【SSPS0110】．

SSPカーネルでは，stkにはNULLを指定しなくてはならず，その場合でも，コン
フィギュレータはタスクのスタック領域を確保しない【SSPS0111】．これは，
SSPカーネルでは，すべての処理単位が共有スタック領域を使用し，タスク毎に
スタック領域を持たないためである．stkにNULL以外を指定した場合には，
E_PARエラーとなる【SSPS0112】．

共有スタック領域の設定方法については，DEF_STKの項を参照すること．

【μITRON4.0仕様との関係】

taskのデータ型をTASKに，stkのデータ型をSTK_T *に変更した．COUNT_STK_Tと
ROUND_STK_Tを新設し，スタック領域をアプリケーションで確保する方法を規定
した．

【μITRON4.0/PX仕様との関係】

sstkのデータ型をSTK_T *に変更した．システムスタック領域をアプリケーショ
ンで確保する方法を規定した．

【未決定事項】

サービスコール（acre_tsk）により，stkにNULLを指定して制約タスクを生成し
た場合のスタック領域の確保方法については，今後の課題である．

【仕様決定の理由】

保護機能対応カーネルにおいて，sstkszおよびsstkの記述は省略することがで
きることとしたのは，保護機能対応でないカーネル用のシステムコンフィギュ
レーションファイルを，保護機能対応カーネルにも変更なしに使えるようにす
るためである．

[[API_AID_TSK]]
----
AID_TSK		割付け可能なタスクIDの数の指定〔SD〕【NGKI1073】
----

【静的API】
----
	AID_TSK(uint_t notsk)
----

【パラメータ】
----
	uint_t		notsk		割付け可能なタスクIDの数
----

【エラーコード】
----
	E_RSATR		予約属性
				・保護ドメインの囲みの中に記述されている〔P〕【NGKI3428】
				・クラスの囲みの中に記述されていない〔M〕【NGKI1075】
	E_PAR		パラメータエラー
				・notskが負の値【NGKI3276】
----

【機能】

notskで指定した数のタスクIDを，タスクを生成するサービスコールによって割
付け可能なタスクIDとして確保する【NGKI1076】．

notskは整数定数式パラメータである【NGKI1077】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルの動的生成機能拡張パッケージでは，AID_TSKをサポートする
【ASPS0210】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルの動的生成機能拡張パッケージでは，AID_TSKをサポートする
【HRPS0211】．

[[API_SAC_TSK]]
----
SAC_TSK		タスクのアクセス許可ベクタの設定〔SP〕【NGKI1078】
sac_tsk		タスクのアクセス許可ベクタの設定〔TPD〕【NGKI1079】
----

【静的API】
----
	SAC_TSK(ID tskid, { ACPTN acptn1, ACPTN acptn2,
										ACPTN acptn3, ACPTN acptn4 })
----

【C言語API】
----
	ER ercd = sac_tsk(ID tskid, const ACVCT *p_acvct)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
	ACVCT *		p_acvct		アクセス許可ベクタを入れたパケットへのポ
							インタ（静的APIを除く）

　＊アクセス許可ベクタ（パケットの内容）
	ACPTN		acptn1		通常操作1のアクセス許可パターン
	ACPTN		acptn2		通常操作2のアクセス許可パターン
	ACPTN		acptn3		管理操作のアクセス許可パターン
	ACPTN		acptn4		参照操作のアクセス許可パターン
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI1080】
				・CPUロック状態からの呼出し〔s〕【NGKI1081】
	E_ID		不正ID番号
				・tskidが有効範囲外〔s〕【NGKI1082】
	E_RSATR		予約属性
				・対象タスクが属する保護ドメインの囲みの中に記述されて
				　いない〔S〕【NGKI1083】
				・対象タスクが属するクラスの囲みの中に記述されていない
				　〔SM〕【NGKI1084】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録【NGKI1085】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する管理操作が許可されていない〔s〕【NGKI1086】
	E_MACV		メモリアクセス違反
				・p_acvctが指すメモリ領域への読出しアクセスが許可されて
				　いない〔s〕【NGKI1087】
	E_OBJ		オブジェクト状態エラー
				・対象タスクは静的APIで生成された〔s〕【NGKI1088】
				・対象タスクに対してアクセス許可ベクタが設定済み〔S〕
				　【NGKI1089】
----

【機能】

tskidで指定したタスク（対象タスク）のアクセス許可ベクタ（4つのアクセス
許可パターンの組）を，各パラメータで指定した値に設定する【NGKI1090】．

静的APIにおいては，tskidはオブジェクト識別名，acptn1〜acptn4は整数定数
式パラメータである【NGKI1091】．

sac_tskにおいてtskidにTSK_SELF（＝0）を指定すると，自タスクが対象タスク
となる【NGKI1092】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，SAC_TSKのみをサポートする【HRPS0104】．ただし，動的生
成機能拡張パッケージでは，sac_tskもサポートする【HRPS0177】．

[[DEF_EPR]]
----
DEF_EPR		タスクの実行時優先度の定義〔S〕【NGKI1093】
----

【静的API】
----
	DEF_EPR(ID tskid, { PRI exepri })
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
	PRI			exepri		タスクの実行時優先度
----

【エラーコード】
----
	E_PAR		パラメータエラー
				・exepriが有効範囲外【NGKI1094】
	E_ILUSE		サービスコール不正使用
				・条件については機能の項を参照
	E_OBJ		オブジェクト状態エラー
				・対象タスクに対して実行優先度が設定済み【NGKI1095】
----

【サポートするカーネル】

DEF_EPRは，TOPPERS/SSPカーネルのみがサポートする静的APIである．他のカー
ネルは，DEF_EPRをサポートしない【NGKI1096】．

【機能】

tskidで指定したタスク（対象タスク）の実行時優先度を，exepriで指定した優
先度に設定する【NGKI1097】．

tskidはオブジェクト識別名，exepriは整数定数式パラメータである【NGKI1098】．

exepriが，対象タスクの起動時優先度よりも低い場合には，E_ILUSEエラーとな
る【NGKI1099】．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていない静的APIである．

[[API_del_tsk]]
----
del_tsk		タスクの削除〔TD〕【NGKI1100】
----

【C言語API】
----
	ER ercd = del_tsk(ID tskid)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1101】
				・CPUロック状態からの呼出し【NGKI1102】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI1103】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録【NGKI1104】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する管理操作が許可されていない〔P〕【NGKI1105】
	E_OBJ		オブジェクト状態エラー
				・対象タスクが休止状態でない【NGKI1106】
				・対象タスクは静的APIで生成された【NGKI1107】
----

【機能】

tskidで指定したタスク（対象タスク）を削除する．具体的な振舞いは以下の通
り．

対象タスクが休止状態である場合には，対象タスクの登録が解除され，そのタ
スクIDが未使用の状態に戻される【NGKI1108】．また，タスクの生成時にタス
クのスタック領域およびシステムスタック領域がカーネルによって確保された
場合は，それらのメモリ領域が解放される【NGKI1109】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，del_tskをサポートしない【ASPS0107】．ただし，動的生成
機能拡張パッケージでは，del_tskをサポートする【ASPS0108】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，del_tskをサポートしない【FMPS0105】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，del_tskをサポートしない【HRPS0105】．ただし，動的生成
機能拡張パッケージでは，del_tskをサポートする【HRPS0178】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，del_tskをサポートしない【SSPS0114】．

[[API_act_tsk]]
----
act_tsk		タスクの起動〔T〕【NGKI1110】
iact_tsk	タスクの起動〔I〕【NGKI1111】
----

【C言語API】
----
	ER ercd = act_tsk(ID tskid)
	ER ercd = iact_tsk(ID tskid)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（act_tskの場合）【NGKI1112】
				・タスクコンテキストからの呼出し（iact_tskの場合）【NGKI1113】
				・CPUロック状態からの呼出し【NGKI1114】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI1115】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録〔D〕【NGKI1116】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する通常操作1が許可されていない（act_tsk
				　の場合）〔P〕【NGKI1117】
	E_QOVR		キューイングオーバフロー
				・条件については機能の項を参照
----

【機能】

tskidで指定したタスク（対象タスク）に対して起動要求を行う．具体的な振舞
いは以下の通り．

対象タスクが休止状態である場合には，対象タスクに対してタスク起動時に行
うべき初期化処理が行われ，対象タスクは実行できる状態になる【NGKI1118】．

対象タスクが休止状態でない場合には，対象タスクの起動要求キューイング数
に1が加えられる【NGKI1119】．起動要求キューイング数に1を加えると
TMAX_ACTCNTを超える場合には，E_QOVRエラーとなる【NGKI1120】．

act_tskにおいてtskidにTSK_SELF（＝0）を指定すると，自タスクが対象タスク
となる【NGKI1121】．

【補足説明】

マルチプロセッサ対応カーネルでは，act_tsk／iact_tskは，対象タスクの次回
起動時の割付けプロセッサを変更しない．

[[API_act_tsk]]
----
mact_tsk	割付けプロセッサ指定でのタスクの起動〔TM〕【NGKI1122】
imact_tsk	割付けプロセッサ指定でのタスクの起動〔IM〕【NGKI1123】
----

【C言語API】
----
	ER ercd = mact_tsk(ID tskid, ID prcid)
	ER ercd = imact_tsk(ID tskid, ID prcid)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
	ID			prcid		タスクの割付け対象のプロセッサのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（mact_tskの場合）
				　【NGKI1124】
				・タスクコンテキストからの呼出し（imact_tskの場合）
				　【NGKI1125】
				・CPUロック状態からの呼出し【NGKI1126】
	E_NOSPT		未サポート機能
				・対象タスクが制約タスク【NGKI1127】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI1128】
				・prcidが有効範囲外【NGKI1129】
	E_PAR		パラメータエラー
				・条件については機能の項を参照
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録〔D〕【NGKI1130】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する通常操作1が許可されていない（mact_tsk
				　の場合）〔P〕【NGKI1131】
	E_QOVR		キューイングオーバフロー
				・条件については機能の項を参照
----

【機能】

prcidで指定したプロセッサを割付けプロセッサとして，tskidで指定したタス
ク（対象タスク）に対して起動要求を行う．具体的な振舞いは以下の通り．

対象タスクが休止状態である場合には，対象タスクの割付けプロセッサが
prcidで指定したプロセッサに変更された後，対象タスクに対してタスク起動時
に行うべき初期化処理が行われ，対象タスクは実行できる状態になる
【NGKI1132】．

対象タスクが休止状態でない場合には，対象タスクの起動要求キューイング数
に1が加えられ，次回起動時の割付けプロセッサがprcidで指定したプロセッサ
に変更される【NGKI1133】．起動要求キューイング数に1を加えると
TMAX_ACTCNTを超える場合には，E_QOVRエラーとなる【NGKI1134】．

mact_tskにおいてtskidにTSK_SELF（＝0）を指定すると，自タスクが対象タス
クとなる【NGKI1135】．

対象タスクの属するクラスの割付け可能プロセッサが，prcidで指定したプロセッ
サを含んでいない場合には，E_PARエラーとなる【NGKI1136】．

prcidにTPRC_INI（＝0）を指定すると，対象タスクの割付けプロセッサを，そ
れが属するクラスの初期割付けプロセッサとする【NGKI1137】．

【補足説明】

TMAX_ACTCNTが2以上の場合でも，対象タスクが次に起動される時の割付けプロ
セッサは，キューイングされない．すなわち，プロセッサAに割り付けられた休
止状態でないタスクを対象として，プロセッサBを割付けプロセッサとして
mact_tskを呼び出し，さらにプロセッサCを割付けプロセッサとしてmact_tskを
呼び出すと，対象タスクの次回起動時の割付けプロセッサがプロセッサCに変更
され，対象タスクがプロセッサBで実行されることはない．なお，TMAX_ACTCNT
が1の場合には，プロセッサCを割付けプロセッサとした2回目のmact_tskが
E_QOVRエラーとなるため，次回起動時の割付けプロセッサはプロセッサBのまま
変更されない．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，mact_tsk，imact_tskをサポートしない【ASPS0109】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，mact_tsk，imact_tskをサポートしない【HRPS0106】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，mact_tsk，imact_tskをサポートしない【SSPS0115】．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていないサービスコールである．

[[API_can_act]]
----
can_act		タスク起動要求のキャンセル〔T〕【NGKI1138】
----

【C言語API】
----
	ER_UINT	actcnt = can_act(ID tskid)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
----

【リターンパラメータ】
----
	ER_UINT		actcnt		キューイングされていた起動要求の数（正の値
							または0）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1139】
				・CPUロック状態からの呼出し【NGKI1140】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI1141】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録〔D〕【NGKI1142】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する通常操作1が許可されていない〔P〕
				　【NGKI1143】
----

【機能】

tskidで指定したタスク（対象タスク）に対する処理されていない起動要求をす
べてキャンセルし，キャンセルした起動要求の数を返す．具体的な振舞いは以
下の通り．

対象タスクの起動要求キューイング数が0に設定され，0に設定する前の起動要
求キューイング数が，サービスコールの返値として返される【NGKI1144】．ま
た，マルチプロセッサ対応カーネルにおいては，対象タスクの次回起動時の割
付けプロセッサが未設定状態に戻される【NGKI1145】．

tskidにTSK_SELF（＝0）を指定すると，自タスクが対象タスクとなる
【NGKI1146】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，can_actをサポートしない【SSPS0116】．


[[API_mig_tsk]]
----
mig_tsk		タスクの割付けプロセッサの変更〔TM〕【NGKI1147】
----

【C言語API】
----
	ER ercd = mig_tsk(ID tskid, ID prcid)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
	ID			prcid		タスクの割付けプロセッサのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1148】
				・CPUロック状態からの呼出し【NGKI1149】
				・その他の条件については機能の項を参照
	E_NOSPT		未サポート機能
				・対象タスクが制約タスク【NGKI1150】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI1151】
				・prcidが有効範囲外【NGKI1152】
	E_PAR		パラメータエラー
				・条件については機能の項を参照
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録〔D〕【NGKI1153】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する通常操作1が許可されていない〔P〕
				　【NGKI1154】
	E_OBJ		オブジェクト状態エラー
				・条件については機能の項を参照
----

【機能】

tskidで指定したタスクの割付けプロセッサを，prcidで指定したプロセッサに
変更する．具体的な振舞いは以下の通り．

対象タスクが，自タスクが割り付けられたプロセッサに割り付けられている場
合には，対象タスクをprcidで指定したプロセッサに割り付ける【NGKI1155】．
対象タスクが実行できる状態の場合には，prcidで指定したプロセッサに割り付
けられた同じ優先度のタスクの中で，最も優先順位が低い状態となる
【NGKI1156】．

対象タスクが，自タスクが割付けられたプロセッサと異なるプロセッサに割り
付けられている場合には，E_OBJエラーとなる【NGKI1157】．

tskidにTSK_SELF（＝0）を指定すると，自タスクが対象タスクとなる
【NGKI1158】．

ディスパッチ保留状態で，対象タスクを自タスクとしてmig_tskを呼び出すと，
E_CTXエラーとなる【NGKI1159】．

対象タスクの属するクラスの割付け可能プロセッサが，prcidで指定したプロセッ
サを含んでいない場合には，E_PARエラーとなる【NGKI1160】．

prcidにTPRC_INI（＝0）を指定すると，対象タスクの割付けプロセッサを，そ
れが属するクラスの初期割付けプロセッサに変更する【NGKI1161】．

【補足説明】

この仕様では，タスクをマイグレーションさせることができるのは，そのタス
クと同じプロセッサに割り付けられたタスクのみである．そのため，CPUロック
状態やディスパッチ禁止状態を用いて，他のタスクへのディスパッチが起こら
ないようにすることで，自タスクが他のプロセッサへマイグレーションされる
のを防ぐことができる．

対象タスクが，最初からprcidで指定したプロセッサに割り付けられている場合
には，割付けプロセッサの変更は起こらないが，優先順位が同一優先度のタス
クの中で最低となる．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，mig_tskをサポートしない【ASPS0110】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，mig_tskをサポートしない【HRPS0107】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，mig_tskをサポートしない【SSPS0117】．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていないサービスコールである．


[[API_ext_tsk]]
----
ext_tsk		自タスクの終了〔T〕【NGKI1162】
----

【C言語API】
----
	ER ercd = ext_tsk()
----

【パラメータ】
----
	なし
----

【リターンパラメータ】
----
	ER			ercd		エラーコード
----

【エラーコード】
----
	E_SYS		システムエラー
				・カーネルの誤動作【NGKI1163】
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1164】
----

【機能】

自タスクを終了させる．具体的には，自タスクに対してタスク終了時に行うべ
き処理が行われる【NGKI3449】．

ext_tskは，CPUロック解除状態，割込み優先度マスク全解除状態，ディスパッ
チ許可状態で呼び出すのが原則であるが，そうでない状態で呼び出された場合
には，CPUロック解除状態，割込み優先度マスク全解除状態，ディスパッチ許可
状態に遷移させた後，自タスクを終了させる【NGKI1168】．

ext_tskが正常に処理された場合，ext_tskからはリターンしない【NGKI1169】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，ext_tskをサポートしない【SSPS0118】．自タスクを終了さ
せる場合には，タスクのメインルーチンからリターンする【SSPS0119】．

【μITRON4.0仕様との関係】

ext_tskを非タスクコンテキストから呼び出した場合に，E_CTXエラーが返るこ
ととした．μITRON4.0仕様においては，ext_tskからはリターンしないと規定さ
れている．


[[API_ter_tsk]]
----
ter_tsk		タスクの強制終了〔T〕【NGKI1170】
----

【C言語API】
----
	ER ercd = ter_tsk(ID tskid)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1171】
				・CPUロック状態からの呼出し【NGKI1172】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI1173】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録〔D〕【NGKI1174】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する通常操作2が許可されていない〔P〕
				　【NGKI1175】
	E_ILUSE		サービスコール不正使用
				・対象タスクが自タスク【NGKI1176】
	E_OBJ		オブジェクト状態エラー
				・対象タスクが休止状態【NGKI1177】
				・その他の条件については機能の項を参照
----

【機能】

tskidで指定したタスク（対象タスク）を終了させる．具体的には，対象タスク
が休止状態でない場合には，対象タスクに対してタスク終了時に行うべき処理
が行われる【NGKI3450】．

マルチプロセッサ対応カーネルでは，対象タスクは，自タスクと同じプロセッ
サに割り付けられているタスクに限られる．対象タスクが自タスクと異なるプ
ロセッサに割り付けられている場合には，E_OBJエラーとなる【NGKI1182】．

【TOPPERS/FMPカーネルにおける使用上の注意】

現時点のFMPカーネルの実装では，デッドロック回避のためのリトライ処理によ
り，サービスコールの処理時間に上限がないため，注意が必要である（ロック
方式にも依存する）．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，ter_tskをサポートしない【SSPS0120】．


[[API_chg_pri]]
----
chg_pri		タスクのベース優先度の変更〔T〕【NGKI1183】
----

【C言語API】
----
	ER ercd = chg_pri(ID tskid, PRI tskpri)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
	PRI			tskpri		ベース優先度
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1184】
				・CPUロック状態からの呼出し【NGKI1185】
	E_NOSPT		未サポート機能
				・対象タスクが制約タスク【NGKI1186】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI1187】
	E_PAR		パラメータエラー
				・tskpriが有効範囲外【NGKI1188】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録〔D〕【NGKI1189】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する通常操作2が許可されていない〔P〕
				　【NGKI1190】
	E_ILUSE		サービスコール不正使用
				・条件については機能の項を参照
	E_OBJ		オブジェクト状態エラー
				・対象タスクが休止状態【NGKI1191】
----

【機能】

tskidで指定したタスク（対象タスク）のベース優先度を，tskpriで指定した優
先度に変更する．具体的な振舞いは以下の通り．

対象タスクが休止状態でない場合には，対象タスクのベース優先度が，tskpri
で指定した優先度に変更される【NGKI1192】．それに伴って，対象タスクの現
在優先度も変更される【NGKI1193】．

対象タスクが，優先度上限ミューテックスをロックしていない場合には，次の
処理が行われる．対象タスクが実行できる状態の場合には，同じ優先度のタス
クの中で最低優先順位となる【NGKI1194】．対象タスクが待ち状態で，タスク
の優先度順の待ち行列につながれている場合には，対象タスクの変更後の現在
優先度に従って，その待ち行列中での順序が変更される【NGKI1195】．待ち行
列中に同じ現在優先度のタスクがある場合には，対象タスクの順序はそれらの
中で最後になる【NGKI1196】．

対象タスクが，優先度上限ミューテックスをロックしている場合には，対象タ
スクの現在優先度が変更されることはなく，優先順位も変更されない
【NGKI1197】．

tskidにTSK_SELF（＝0）を指定すると，自タスクが対象タスクとなる
【NGKI1198】．また，tskpriにTPRI_INI（＝0）を指定すると，対象タスクのベー
ス優先度が，起動時優先度に変更される【NGKI1199】．

対象タスクが優先度上限ミューテックスをロックしているかロックを待ってい
る場合，tskpriは，それらのミューテックスの上限優先度と同じかそれより低
くなければならない．そうでない場合には，E_ILUSEエラーとなる【NGKI1201】．

保護機能対応カーネルで，chg_priを呼び出した処理単位がユーザドメインに属
する場合，tskpriは，そのユーザドメインが指定できる最高のタスク優先度と
同じかそれより低くなければならない．そうでない場合には，E_ILUSEエラーと
なる【NGKI3440】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，chg_priをサポートしない【SSPS0121】．

【μITRON4.0仕様との関係】

対象タスクが，同じ優先度のタスクの中で最低の優先順位となる（対象タスク
が待ち状態で，タスクの優先度順の待ち行列につながれている場合には，同じ
優先度のタスクの中での順序が最後になる）条件を変更した．


[[API_get_pri]]
----
get_pri		タスク優先度の参照〔T〕【NGKI1202】
----

【C言語API】
----
	ER ercd = get_pri(ID tskid, PRI *p_tskpri)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
	PRI *		p_tskpri	現在優先度を入れるメモリ領域へのポインタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
	PRI			tskpri		現在優先度
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1203】
				・CPUロック状態からの呼出し【NGKI1204】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI1205】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録〔D〕【NGKI1206】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する参照操作が許可されていない〔P〕【NGKI1207】
	E_MACV		メモリアクセス違反
				・p_tskpriが指すメモリ領域への書込みアクセスが許可され
				　ていない〔P〕【NGKI1208】
	E_OBJ		オブジェクト状態エラー
				・対象タスクが休止状態【NGKI1209】
----

【機能】

tskidで指定したタスク（対象タスク）の現在優先度を参照する．具体的な振舞
いは以下の通り．

対象タスクが休止状態でない場合には，対象タスクの現在優先度が，p_tskpri
が指すメモリ領域に返される【NGKI1210】．

tskidにTSK_SELF（＝0）を指定すると，自タスクが対象タスクとなる
【NGKI1211】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，get_priをサポートしない【SSPS0122】．


[[API_get_inf]]
----
get_inf		自タスクの拡張情報の参照〔T〕【NGKI1212】
----

【C言語API】
----
	ER ercd = get_inf(intptr_t *p_exinf)
----

【パラメータ】
----
	intptr_t *	p_exinf		拡張情報を入れるメモリ領域へのポインタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
	intptr_t	exinf		拡張情報
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1213】
				・CPUロック状態からの呼出し【NGKI1214】
	E_MACV		メモリアクセス違反
				・p_exinfが指すメモリ領域への書込みアクセスが許可されて
				　いない〔P〕【NGKI1215】
----

【機能】

自タスクの拡張情報を参照する．参照した拡張情報は，p_exinfが指すメモリ領
域に返される【NGKI1216】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，get_infをサポートしない【SSPS0123】．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていないサービスコールである．


[[API_ref_tsk]]
----
ref_tsk		タスクの状態参照〔T〕【NGKI1217】
----

【C言語API】
----
	ER ercd = ref_tsk(ID tskid, T_RTSK *pk_rtsk)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
	T_RTSK *	pk_rtsk		タスクの現在状態を入れるパケットへのポインタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード

　＊タスクの現在状態（パケットの内容）
	STAT		tskstat		タスク状態
	PRI			tskpri		タスクの現在優先度
	PRI			tskbpri		タスクのベース優先度
	STAT		tskwait		タスクの待ち要因
	ID			wobjid		タスクの待ち対象のオブジェクトのID
	TMO			lefttmo		タスクがタイムアウトするまでの時間
	uint_t		actcnt		タスクの起動要求キューイング数
	uint_t		wupcnt		タスクの起床要求キューイング数
	bool_t		texmsk		タスクがタスク例外処理マスク状態か否か（保
							護機能対応カーネルの場合）
	bool_t		waifbd		タスクが待ち禁止状態か否か（保護機能対応カー
							ネルの場合）
	uint_t		svclevel	タスクの拡張サービスコールのネストレベル（保
							護機能対応カーネルの場合）
	ID			prcid		タスクの割付けプロセッサのID（マルチプロセッ
							サ対応カーネルの場合）
	ID			actprc		タスクの次回起動時の割付けプロセッサのID（マ
							ルチプロセッサ対応カーネルの場合）
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1218】
				・CPUロック状態からの呼出し【NGKI1219】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI1220】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録〔D〕【NGKI1221】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する参照操作が許可されていない〔P〕【NGKI1222】
	E_MACV		メモリアクセス違反
				・pk_rtskが指すメモリ領域への書込みアクセスが許可されて
				　いない〔P〕【NGKI1223】
----

【機能】

tskidで指定したタスク（対象タスク）の現在状態を参照する．参照した現在状
態は，pk_rtskで指定したメモリ領域に返される【NGKI1224】．

tskstatには，対象タスクの現在のタスク状態を表す次のいずれかの値が返され
る【NGKI1225】．

	TTS_RUN		0x01U		実行状態
	TTS_RDY		0x02U		実行可能状態
	TTS_WAI		0x04U		待ち状態
	TTS_SUS		0x08U		強制待ち状態
	TTS_WAS		0x0cU		二重待ち状態
	TTS_DMT		0x10U		休止状態

マルチプロセッサ対応カーネルでは，対象タスクが自タスクの場合にも，
tskstatがTTS_SUSとなる場合がある【NGKI1226】．この状況は，自タスクに対
してref_tskを発行するのと同じタイミングで，他のプロセッサで実行されてい
るタスクから同じタスクに対してsus_tskが発行された場合に発生する可能性が
ある．

対象タスクが休止状態でない場合には，tskpriには対象タスクの現在優先度が，
tskbpriには対象タスクのベース優先度が返される【NGKI1227】．対象タスクが
休止状態である場合には，tskpriとtskbpriの値は保証されない【NGKI1228】．

対象タスクが待ち状態である場合には，tskwaitには，対象タスクが何を待って
いる状態であるかを表す次のいずれかの値が返される【NGKI1229】．

	TTW_SLP		0x0001U		起床待ち
	TTW_DLY		0x0002U		時間経過待ち
	TTW_SEM		0x0004U		セマフォの資源獲得待ち
	TTW_FLG		0x0008U		イベントフラグ待ち
	TTW_SDTQ	0x0010U		データキューへの送信待ち
	TTW_RDTQ	0x0020U		データキューからの受信待ち
	TTW_SPDQ	0x0100U		優先度データキューへの送信待ち
	TTW_RPDQ	0x0200U		優先度データキューからの受信待ち
	TTW_MBX		0x0040U		メールボックスからの受信待ち
	TTW_MTX		0x0080U		ミューテックスのロック待ち状態
	TTW_SMBF	0x0400U		メッセージバッファへの送信待ち
	TTW_RMBF	0x0800U		メッセージバッファからの受信待ち
	TTW_MPF		0x2000U		固定長メモリブロックの獲得待ち

対象タスクが待ち状態でない場合には，tskwaitの値は保証されない
【NGKI1230】．

対象タスクが起床待ち状態および時間経過待ち状態以外の待ち状態である場合
には，wobjidに，対象タスクが待っているオブジェクトのID番号が返される
【NGKI1231】．対象タスクが待ち状態でない場合や，起床待ち状態または時間
経過待ち状態である場合には，wobjidの値は保証されない【NGKI1232】．

対象タスクが時間経過待ち状態以外の待ち状態である場合には，lefttmoに，タ
スクがタイムアウトを起こすまでの相対時間が返される【NGKI1233】．タスク
がタイムアウトを起こさない場合には，TMO_FEVR（＝-1）が返される
【NGKI1234】．

対象タスクが時間経過待ち状態である場合には，lefttmoに，タスクの遅延時間
が経過して待ち解除されるまでの相対時間が返される【NGKI1235】．ただし，
返されるべき相対時間がTMO型に格納することができない場合がありうる．この
場合には，相対時間（RELTIM型，uint_t型に定義される）をTMO型（int_t型に
定義される）に型キャストした値が返される【NGKI1236】．

対象タスクが待ち状態でない場合には，lefttmoの値は保証されない
【NGKI1237】．

actcntには，対象タスクの起動要求キューイング数が返される【NGKI1238】．

対象タスクが休止状態でない場合には，wupcntに，タスクの起床要求キューイ
ング数が返される【NGKI1239】．対象タスクが休止状態である場合には，
wupcntの値は保証されない【NGKI1240】．

保護機能対応カーネルで，対象タスクが休止状態でない場合には，texmskに，
対象タスクがタスク例外処理マスク状態の場合にtrue，そうでない場合に
falseが返される【NGKI1241】．waifbdには，対象タスクが待ち禁止状態の場合
にtrue，そうでない場合にfalseが返される【NGKI1242】．またsvclevelには，
対象タスクが拡張サービスコールを呼び出していない場合には0，呼び出してい
る場合には，実行中の拡張サービスコールがネスト段数が返される
【NGKI1243】．対象タスクが休止状態である場合には，texmsk，waifbd，
svclevelの値は保証されない【NGKI1244】．

マルチプロセッサ対応カーネルでは，prcidに，対象タスクの割付けプロセッサ
のID番号が返される【NGKI1245】．またactprcには，対象タスクの次回起動時
の割付けプロセッサのID番号が返される【NGKI1246】．次回起動時の割付けプ
ロセッサが未設定の場合には，actprcにTPRC_NONE（＝0）が返される
【NGKI1247】．

tskidにTSK_SELF（＝0）を指定すると，自タスクが対象タスクとなる
【NGKI1248】．

【補足説明】

対象タスクが時間経過待ち状態である場合に，lefttmo（TMO型）に返される値
をRELTIM型に型キャストすることで，タスクが待ち解除されるまでの相対時間
を正しく得ることができる．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，tskwaitにTTW_MTX，TTW_SMBF，TTW_RMBFが返ることはない
【ASPS0111】．ただし，ミューテックス機能拡張パッケージを用いると，
tskwaitにTTW_MTXが返る場合がある【ASPS0112】．また，メッセージバッファ
機能拡張パッケージを用いると，tskwaitにTTW_SMBFとTTW_RMBFが返る場合があ
る【ASPS0208】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，tskwaitにTTW_MTX，TTW_SMBF，TTW_RMBFが返ることはない
【FMPS0106】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，tskwaitにTTW_MBX，TTW_SMBF，TTW_RMBFが返ることはない
【HRPS0108】．ただし，メッセージバッファ機能拡張パッケージを用いると，
tskwaitにTTW_SMBFとTTW_RMBFが返る場合がある【HRPS0174】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，ref_tskをサポートしない【SSPS0124】．

【使用上の注意】

ref_tskはデバッグ時向けの機能であり，その他の目的に使用することは推奨し
ない．これは，ref_tskを呼び出し，対象タスクの現在状態を参照した直後に割
込みが発生した場合，ref_tskから戻ってきた時には対象タスクの状態が変化し
ている可能性があるためである．

【μITRON4.0仕様との関係】

対象タスクが時間経過待ち状態の時にlefttmoに返される値について規定した．
また，参照できるタスクの状態から，強制待ち要求ネスト数（suscnt）を除外
した．

マルチプロセッサ対応カーネルで参照できる情報として，割付けプロセッサの
ID（prcid）と次回起動時の割付けプロセッサのID（actprc）を追加した．

【μITRON4.0/PX仕様との関係】

保護機能対応カーネルで参照できる情報として，タスク例外処理マスク状態か
否か（texmsk），待ち禁止状態か否か（waifbd），拡張サービスコールのネス
トレベル（svclevel）を追加した．


=== タスク付属同期機能

タスク付属同期機能は，タスクとタスクの間，または非タスクコンテキストの
処理とタスクの間で同期を取るために，タスク単独で持っている機能である．

タスク付属同期機能に関連して，各タスクが持つ情報は次の通り【NGKI1249】．

* 起床要求キューイング数

タスクの起床要求キューイング数は，処理されていないタスクの起床要求の数
であり，タスクの起動時に0に初期化される【NGKI1250】．

タスク付属同期機能に関連するカーネル構成マクロは次の通り．

	TMAX_WUPCNT		タスクの起床要求キューイング数の最大値【NGKI1251】

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，TMAX_WUPCNTは1に固定されている【ASPS0113】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，TMAX_WUPCNTは1に固定されている【FMPS0107】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，TMAX_WUPCNTは1に固定されている【HRPS0109】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，タスク付属同期機能をサポートしない【SSPS0125】．

【μITRON4.0仕様との関係】

この仕様では，強制待ち要求をネストする機能をサポートしないこととした．
言い換えると，強制待ち要求ネスト数の最大値を1に固定する．これに伴い，強
制待ち状態から強制再開するサービスコール（frsm_tsk）とタスクの強制待ち
要求ネスト数の最大値を表すカーネル構成マクロ（TMAX_SUSCNT）は廃止した．
また，ref_tskで参照できる情報（T_RTSKのフィールド）から，強制待ち要求ネ
スト数（suscnt）を除外した．


[[API_slp_tsk]]
----
slp_tsk		起床待ち〔T〕【NGKI1252】
tslp_tsk	起床待ち（タイムアウト付き）〔T〕【NGKI1253】
----

【C言語API】
----
	ER ercd = slp_tsk()
	ER ercd = tslp_tsk(TMO tmout)
----

【パラメータ】
----
	TMO			tmout		タイムアウト時間（tslp_tskの場合）
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・ディスパッチ保留状態からの呼出し【NGKI1254】
	E_NOSPT		未サポート機能
				・制約タスクからの呼出し【NGKI1255】
	E_PAR		パラメータエラー
				・tmoutが無効（tslp_tskの場合）【NGKI1256】
	E_TMOUT		ポーリング失敗またはタイムアウト（slp_tskを除く）【NGKI1257】
	E_RLWAI		待ち禁止状態または待ち状態の強制解除【NGKI1258】
----

【機能】

自タスクを起床待ちさせる．具体的な振舞いは以下の通り．

自タスクの起床要求キューイング数が0でない場合には，起床要求キューイング
数から1が減ぜられる【NGKI1259】．起床要求キューイング数が0の場合には，
自タスクは起床待ち状態となる【NGKI1260】．

【補足説明】

自タスクの起床要求キューイング数が0でない場合には，自タスクは実行できる
状態を維持し，自タスクの優先順位は変化しない．


[[API_wup_tsk]]
----
wup_tsk		タスクの起床〔T〕【NGKI1261】
iwup_tsk	タスクの起床〔I〕【NGKI1262】
----

【C言語API】
----
	ER ercd = wup_tsk(ID tskid)
	ER ercd = iwup_tsk(ID tskid)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（wup_tskの場合）【NGKI1263】
				・タスクコンテキストからの呼出し（iwup_tskの場合）【NGKI1264】
				・CPUロック状態からの呼出し【NGKI1265】
	E_NOSPT		未サポート機能
				・対象タスクが制約タスク【NGKI1266】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI1267】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録〔D〕【NGKI1268】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する通常操作1が許可されていない（wup_tsk
				　の場合）〔P〕【NGKI1269】
	E_OBJ		オブジェクト状態エラー
				・対象タスクが休止状態【NGKI1270】
	E_QOVR		キューイングオーバフロー
				・条件については機能の項を参照
----

【機能】

tskidで指定したタスク（対象タスク）を起床する．具体的な振舞いは以下の通
り．

対象タスクが起床待ち状態である場合には，対象タスクが待ち解除される
【NGKI1271】．待ち解除されたタスクには，待ち状態となったサービスコール
からE_OKが返る【NGKI1272】．

対象タスクが起床待ち状態でなく，休止状態でもない場合には，対象タスクの
起床要求キューイング数に1が加えられる【NGKI1273】．起床要求キューイング
数に1を加えるとTMAX_WUPCNTを超える場合には，E_QOVRエラーとなる
【NGKI1274】．

wup_tskにおいてtskidにTSK_SELF（＝0）を指定すると，自タスクが対象タスク
となる【NGKI1275】．


[[API_can_wup]]
----
can_wup		タスク起床要求のキャンセル〔T〕【NGKI1276】
----

【C言語API】
----
	ER_UINT wupcnt = can_wup(ID tskid)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
----

【リターンパラメータ】
----
	ER_UINT		wupcnt		キューイングされていた起床要求の数（正の値
							または0）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1277】
				・CPUロック状態からの呼出し【NGKI1278】
	E_NOSPT		未サポート機能
				・対象タスクが制約タスク【NGKI1279】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI1280】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録〔D〕【NGKI1281】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する通常操作1が許可されていない〔P〕
				　【NGKI1282】
	E_OBJ		オブジェクト状態エラー
				・対象タスクが休止状態【NGKI1283】
----

【機能】

tskidで指定したタスク（対象タスク）に対する処理されていない起床要求をす
べてキャンセルし，キャンセルした起床要求の数を返す．具体的な振舞いは以
下の通り．

対象タスクが休止状態でない場合には，対象タスクの起床要求キューイング数
が0に設定され，0に設定する前の起床要求キューイング数が，サービスコール
の返値として返される【NGKI1284】．

tskidにTSK_SELF（＝0）を指定すると，自タスクが対象タスクとなる
【NGKI1285】．


[[API_rel_wai]]
----
rel_wai		強制的な待ち解除〔T〕【NGKI1286】
irel_wai	強制的な待ち解除〔I〕【NGKI1287】
----

【C言語API】
----
	ER ercd = rel_wai(ID tskid)
	ER ercd = irel_wai(ID tskid)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（rel_waiの場合）【NGKI1288】
				・タスクコンテキストからの呼出し（irel_waiの場合）【NGKI1289】
				・CPUロック状態からの呼出し【NGKI1290】
	E_NOSPT		未サポート機能
				・対象タスクが制約タスク【NGKI1291】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI1292】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録〔D〕【NGKI1293】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する通常操作2が許可されていない（rel_wai
				　の場合）〔P〕【NGKI1294】
	E_OBJ		オブジェクト状態エラー
				・対象タスクが待ち状態でない【NGKI1295】
----

【機能】

tskidで指定したタスク（対象タスク）を，強制的に待ち解除する．具体的な振
舞いは以下の通り．

対象タスクが待ち状態である場合には，対象タスクが待ち解除される
【NGKI1296】．待ち解除されたタスクには，待ち状態となったサービスコール
からE_RLWAIが返る【NGKI1297】．


[[API_sus_tsk]]
----
sus_tsk		強制待ち状態への遷移〔T〕【NGKI1298】
----

【C言語API】
----
	ER ercd = sus_tsk(ID tskid)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1299】
				・CPUロック状態からの呼出し【NGKI1300】
				・その他の条件については機能の項を参照
	E_NOSPT		未サポート機能
				・対象タスクが制約タスク【NGKI1301】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI1302】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録〔D〕【NGKI1303】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する通常操作2が許可されていない〔P〕
				　【NGKI1304】
	E_OBJ		オブジェクト状態エラー
				・対象タスクが休止状態【NGKI1305】
	E_QOVR		キューイングオーバフロー
				・対象タスクが強制待ち状態（二重待ち状態を含む）【NGKI1306】
----

【機能】

tskidで指定したタスク（対象タスク）を強制待ちにする．具体的な振舞いは以
下の通り．

対象タスクが実行できる状態である場合には，対象タスクは強制待ち状態とな
る【NGKI1307】．また，待ち状態（二重待ち状態を除く）である場合には，二
重待ち状態となる【NGKI1308】．

マルチプロセッサ対応カーネルでは，対象タスクが自タスクの場合にも，
E_QOVRエラーとなる場合がある【NGKI1309】．この状況は，自タスクに対して
sus_tskを発行するのと同じタイミングで，他のプロセッサで実行されているタ
スクから同じタスクに対してsus_tskが発行された場合に発生する可能性がある．

tskidにTSK_SELF（＝0）を指定すると，自タスクが対象タスクとなる
【NGKI1310】．

ディスパッチ保留状態で，対象タスクを自タスクとしてsus_tskを呼び出すと，
E_CTXエラーとなる【NGKI1311】．なお，sus_tskは，自タスクを広義の待ち状
態に遷移させる可能性のあるサービスコールであるが，対象タスクが自タスク
でない場合には，割込み優先度マスクが全解除でない状態やディスパッチ禁止
状態で呼び出しても，E_CTXエラーにはならない【NGKI3604】．これは，
［NGKI0175］と［NGKI0179］の原則の例外となっている．


[[API_rsm_tsk]]
----
rsm_tsk		強制待ち状態からの再開〔T〕【NGKI1312】
----

【C言語API】
----
	ER ercd = rsm_tsk(ID tskid)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1313】
				・CPUロック状態からの呼出し【NGKI1314】
	E_NOSPT		未サポート機能
				・対象タスクが制約タスク【NGKI1315】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI1316】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録〔D〕【NGKI1317】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する通常操作2が許可されていない〔P〕
				　【NGKI1318】
	E_OBJ		オブジェクト状態エラー
				・対象タスクが強制待ち状態（二重待ち状態を含む）でない
				　【NGKI1319】
----

【機能】

tskidで指定したタスク（対象タスク）を，強制待ちから再開する．具体的な振
舞いは以下の通り．

対象タスクが強制待ち状態である場合には，対象タスクは強制待ちから再開さ
れる【NGKI1320】．


[[API_dis_wai]]
----
dis_wai		待ち禁止状態への遷移〔TP〕【NGKI1321】
idis_wai	待ち禁止状態への遷移〔IP〕【NGKI1322】
----

【C言語API】
----
	ER ercd = dis_wai(ID tskid)
	ER ercd = idis_wai(ID tskid)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（dis_waiの場合）【NGKI1323】
				・タスクコンテキストからの呼出し（idis_waiの場合）【NGKI1324】
				・CPUロック状態からの呼出し【NGKI1325】
	E_NOSPT		未サポート機能
				・対象タスクが制約タスク【NGKI1326】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI1327】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録〔D〕【NGKI1328】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する通常操作2が許可されていない（dis_wai
				　の場合）【NGKI1329】
	E_OBJ		オブジェクト状態エラー
				・対象タスクが休止状態【NGKI1330】
				・対象タスクがタスク例外処理マスク状態でない【NGKI1331】
	E_QOVR		キューイングオーバフロー
				・対象タスクが待ち禁止状態【NGKI1332】
----

【機能】

tskidで指定したタスク（対象タスク）を待ち禁止状態にする．具体的な振舞い
は以下の通り．

対象タスクがタスク例外処理マスク状態であり，待ち禁止状態でない場合には，
対象タスクは待ち禁止状態になる【NGKI1333】．

dis_waiにおいてtskidにTSK_SELF（＝0）を指定すると，自タスクが対象タスク
となる【NGKI1334】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，dis_waiをサポートしない【ASPS0114】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，dis_waiをサポートしない【FMPS0108】．

【補足説明】

dis_waiは，対象タスクの待ち解除は行わない．対象タスクを待ち禁止状態にす
ることに加えて待ち解除したい場合には，dis_waiを呼び出した後に，rel_wai
を呼び出せばよい．

【未決定事項】

マルチプロセッサ対応カーネルでは，対象タスクを，自タスクと同じプロセッ
サに割り付けられているタスクに限るなどの制限を導入する可能性があるが，
現時点では未決定である．

【μITRON4.0/PX仕様との関係】

μITRON4.0/PX仕様に定義されていないサービスコールである．


[[API_ena_wai]]
----
ena_wai		待ち禁止状態の解除〔TP〕【NGKI1335】
iena_wai	待ち禁止状態の解除〔IP〕【NGKI1336】
----

【C言語API】
----
	ER ercd = ena_wai(ID tskid)
	ER ercd = iena_wai(ID tskid)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（ena_waiの場合）【NGKI1337】
				・タスクコンテキストからの呼出し（iena_waiの場合）【NGKI1338】
				・CPUロック状態からの呼出し【NGKI1339】
	E_NOSPT		未サポート機能
				・対象タスクが制約タスク【NGKI1340】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI1341】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録〔D〕【NGKI1342】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する通常操作2が許可されていない（ena_wai
				　の場合）【NGKI1343】
	E_OBJ		オブジェクト状態エラー
				・対象タスクが休止状態【NGKI1344】
				・対象タスクが待ち禁止状態でない【NGKI1345】
----

【機能】

tskidで指定したタスク（対象タスク）の待ち禁止状態を解除する．具体的な振
舞いは以下の通り．

対象タスクが待ち禁止状態である場合には，待ち禁止状態は解除される
【NGKI1346】．

ena_waiにおいてtskidにTSK_SELF（＝0）を指定すると，自タスクが対象タスク
となる【NGKI1347】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，ena_waiをサポートしない【ASPS0115】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，ena_waiをサポートしない【FMPS0109】．

【未決定事項】

マルチプロセッサ対応カーネルでは，対象タスクを，自タスクと同じプロセッ
サに割り付けられているタスクに限るなどの制限を導入する可能性があるが，
現時点では未決定である．

【μITRON4.0/PX仕様との関係】

μITRON4.0/PX仕様に定義されていないサービスコールである．


[[API_dly_tsk]]
----
dly_tsk		自タスクの遅延〔T〕【NGKI1348】
----

【C言語API】
----
	ER ercd = dly_tsk(RELTIM dlytim)
----

【パラメータ】
----
	RELTIM		dlytim		遅延時間
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・ディスパッチ保留状態からの呼出し【NGKI1349】
	E_NOSPT		未サポート機能
				・制約タスクからの呼出し【NGKI1350】
	E_PAR		パラメータエラー
				・dlytimがTMAX_RELTIMより大きい【NGKI1351】
	E_RLWAI		待ち禁止状態または待ち状態の強制解除【NGKI1352】
----

【機能】

dlytimで指定した時間，自タスクを遅延させる．具体的な振舞いは以下の通り．

自タスクは，dlytimで指定した時間が経過するまでの間，時間経過待ち状態と
なる【NGKI1353】．dly_tskを呼び出してからdlytimで指定した相対時間後に，
自タスクは待ち解除され，dly_tskからE_OKが返る【NGKI1354】．


=== タスク例外処理機能

タスク例外処理ルーチンは，カーネルが実行を制御する処理単位で，タスクと
同一のコンテキスト内で実行される．タスク例外処理ルーチンは，各タスクに
1つのみ登録できるため，タスクIDによって識別する【NGKI1355】．

タスク例外処理機能に関連して，各タスクが持つ情報は次の通り【NGKI1356】．

* タスク例外処理ルーチン属性
* タスク例外処理禁止フラグ
* 保留例外要因
* タスク例外処理ルーチンの先頭番地

タスク例外処理ルーチン属性に指定できる属性はない【NGKI1357】．そのため，
タスク例外処理ルーチン属性には，TA_NULLを指定しなければならない
【NGKI1358】．

タスクは，タスク例外処理ルーチンの実行を保留するためのタスク例外処理禁
止フラグを持つ【NGKI1359】．タスク例外処理禁止フラグがセットされた状態
をタスク例外処理禁止状態，クリアされた状態をタスク例外処理許可状態と呼
ぶ．タスク例外処理禁止フラグは，タスクの起動時に，セットした状態に初期
化される【NGKI1361】．

タスクの保留例外要因は，タスクに対して要求された例外要因を蓄積するため
のビットマップであり，タスクの起動時に0に初期化される【NGKI1362】．

タスク例外処理ルーチンは，「タスク例外処理許可状態である」「保留例外要
因が0でない」「タスクが実行状態である」「タスクコンテキストが実行されて
いる」「割込み優先度マスク全解除状態である」「CPUロック状態でない」の6
つの条件が揃った場合に実行が開始される【NGKI1363】．保護機能対応カーネ
ルにおいては，さらに，「タスク例外処理マスク状態でない」という条件が追
加される【NGKI1364】．タスク例外処理マスク状態については，「2.6.5 タス
ク例外処理マスク状態と待ち禁止状態」の節を参照すること．

タスク例外処理ルーチンの実行が開始される時，タスク例外処理禁止フラグは
セットされ，保留例外要因は0にクリアされる【NGKI1365】．また，タスク例外
処理ルーチンからのリターン時には，タスク例外処理禁止フラグはクリアされ
る【NGKI1366】．

保護機能対応カーネルでは，ユーザタスクのタスク例外処理ルーチンの実行開
始時に，リターン先の番地やシステム状態等が，ユーザスタック上に保存され
る【NGKI1367】．ここで，ユーザスタック領域に十分な空きがない場合や，ユー
ザスタックポインタがユーザスタック領域以外を指している場合，カーネルは，
エミュレートされたCPU例外を発生させる【NGKI1368】．これを，タスク例外実
行開始時スタック不正例外と呼ぶ．

逆に，タスク例外処理ルーチンからのリターン時には，リターン先の番地やシ
ステム状態等が，ユーザスタック上から取り出される【NGKI1369】．ここで，
ユーザスタック領域に積まれている情報が足りない場合や，ユーザスタックポ
インタがユーザスタック領域以外を指している場合，カーネルは，エミュレー
トされたCPU例外を発生させる【NGKI1370】．これを，タスク例外リターン時ス
タック不正例外と呼ぶ．

タスク例外実行開始時スタック不正例外またはタスク例外リターン時スタック
不正例外を起こしたタスクの実行を継続した場合の動作は保証されないため，
アプリケーションは，これらのCPU例外を処理するCPU例外ハンドラで，
「2.8.1 CPU例外処理の流れ」の節の(b)または(d)の方法でリカバリ処理を行う
必要がある【NGKI1371】．この方法に従わなかった場合の動作は，保証されな
い【NGKI1372】．

保護機能対応カーネルにおいて，タスク例外処理ルーチンは，タスクと同じ保
護ドメインに属する【NGKI1373】．

タスク例外処理機能に用いるデータ型は次の通り．

----
	TEXPTN		タスク例外要因のビットパターン（符号無し整数，uint_tに
				定義）【NGKI1374】
----

C言語によるタスク例外処理ルーチンの記述形式は次の通り【NGKI1375】．

[source,c]
----
	void task_exception_routine(TEXPTN texptn, intptr_t exinf)
	{
		タスク例外処理ルーチン本体
	}
----

texptnにはタスク例外処理ルーチン起動時の保留例外要因が，exinfにはタスク
の拡張情報が，それぞれ渡される【NGKI1376】．

タスク例外処理機能に関連するカーネル構成マクロは次の通り．

----
	TBIT_TEXPTN		タスク例外要因のビット数（TEXPTNの有効ビット数）
					【NGKI1377】
----

【補足説明】

保護機能対応でないカーネルでは，タスク例外処理ルーチンの実行開始条件の
内，「CPUロック状態でない」は省いても同じ結果になる．これは，CPUロック
状態で他の条件が揃うことはないためである．一方，保護機能対応カーネルで
は，CPUロック状態で拡張サービスコールからリターンした場合（言い換えると，
タスク例外処理マスク状態が解除された場合）に，CPUロック状態で他の条件が
揃うことになる．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，タスク例外要因のビット数（TBIT_TEXPTN）は16以上である
【ASPS0116】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，タスク例外要因のビット数（TBIT_TEXPTN）は16以上である
【FMPS0110】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，タスク例外要因のビット数（TBIT_TEXPTN）は16以上である
【HRPS0110】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，タスク例外処理機能をサポートしない【SSPS0126】．

【μITRON4.0仕様との関係】

割込み優先度マスク全解除状態でない場合には，タスク例外処理ルーチンの実
行が開始されないという仕様に変更した．

【μITRON4.0/PX仕様との関係】

ユーザタスクのタスク例外処理ルーチンの実行開始時とリターン時にユーザス
タックが不正となる問題に関して，μITRON4.0/PX仕様では考慮されていない．

【仕様変更の経緯】

この仕様のRelease 1.2以前では，タスク例外処理ルーチンの実行開始条件に
「割込み優先度マスク全解除状態である」の条件がなかったが，Release1.3以
降で追加した．これは，マルチプロセッサ対応カーネルにおいて，他プロセッ
サで実行中のタスクに対してタスク例外処理を要求した場合に，割込み優先度
マスクが全解除でないと，タスク例外処理ルーチンをただちに実行開始するこ
とができないためである．なお，ASPカーネル Release 1.6以前と，FMPカーネ
ル Release 1.1.1以前のバージョンは，古い仕様に従って実装されている．


[[API_DEF_TEX]]
----
DEF_TEX		タスク例外処理ルーチンの定義〔S〕【NGKI1378】
def_tex		タスク例外処理ルーチンの定義〔TD〕【NGKI1379】
----

【静的API】
----
	DEF_TEX(ID tskid, { ATR texatr, TEXRTN texrtn })
----

【C言語API】
----
	ER ercd = def_tex(ID tskid, const T_DTEX *pk_dtex)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
	T_DTEX *	pk_dtex		タスク例外処理ルーチンの定義情報を入れたパ
							ケットへのポインタ（静的APIを除く）

　＊タスク例外処理ルーチンの定義情報（パケットの内容）
	ATR			texatr		タスク例外処理ルーチン属性
	TEXRTN		texrtn		タスク例外処理ルーチンの先頭番地
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI1380】
				・CPUロック状態からの呼出し〔s〕【NGKI1381】
	E_ID		不正ID番号
				・tskidが有効範囲外〔s〕【NGKI1382】
	E_RSATR		予約属性
				・texatrが無効【NGKI1383】
				・その他の条件については機能の項を参照
	E_PAR		パラメータエラー
				・texrtnがプログラムの先頭番地として正しくない【NGKI1384】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録【NGKI1385】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する管理操作が許可されていない〔sP〕
				　【NGKI1386】
	E_MACV		メモリアクセス違反
				・pk_dtexが指すメモリ領域への読出しアクセスが許可されて
				　いない〔sP〕【NGKI1387】
	E_OBJ		オブジェクト状態エラー
				・対象タスクは静的APIで生成された〔s〕【NGKI1388】
				・その他の条件については機能の項を参照
----

【機能】

tskidで指定したタスク（対象タスク）に対して，各パラメータで指定したタス
ク例外処理ルーチン定義情報に従って，タスク例外処理ルーチンを定義する
【NGKI1389】．

ただし，def_texにおいてpk_dtexをNULLにした場合には，対象タスクに対する
タスク例外処理ルーチンの定義を解除する【NGKI1390】．また，対象タスクの
タスク例外処理禁止フラグをセットし，保留例外要因を0に初期化する
【NGKI1391】．

静的APIにおいては，tskidはオブジェクト識別名，texatrは整数定数式パラメー
タ，texrtnは一般定数式パラメータである【NGKI1392】．

タスク例外処理ルーチンを定義する場合（DEF_TEXの場合およびdef_texにおい
てpk_dtexをNULL以外にした場合）で，対象タスクに対してすでにタスク例外処
理ルーチンが定義されている場合には，E_OBJエラーとなる【NGKI1393】．

保護機能対応カーネルにおいて，DEF_TEXは，対象タスクが属する保護ドメイン
の囲みの中に記述しなければならない．そうでない場合には，E_RSATRエラーと
なる【NGKI1395】．また，def_texでタスク例外処理ルーチンを定義する場合に
は，タスク例外処理ルーチンの属する保護ドメインを設定する必要はなく，タ
スク例外処理ルーチン属性にTA_DOM(domid)を指定した場合にはE_RSATRエラー
となる【NGKI1396】．ただし，TA_DOM(TDOM_SELF)を指定した場合には，指定が
無視され，E_RSATRエラーは検出されない【NGKI1397】．

マルチプロセッサ対応カーネルにおいて，DEF_TEXは，対象タスクが属するクラ
スの囲みの中に記述しなければならない．そうでない場合には，E_RSATRエラー
となる【NGKI1399】．また，def_texでタスク例外処理ルーチンを定義する場合
には，タスク例外処理ルーチンの属するクラスを設定する必要はなく，タスク
例外処理ルーチン属性にTA_CLS(clsid)を指定した場合にはE_RSATRエラーとな
る【NGKI1400】．ただし，TA_CLS(CLS_SELF)を指定した場合には，指定が無視
され，E_RSATRエラーは検出されない【NGKI1401】．

タスク例外処理ルーチンの定義を解除する場合（def_texにおいてpk_dtexを
NULLにした場合）で，対象タスクに対してタスク例外処理ルーチンが定義され
ていない場合には，E_OBJエラーとなる【NGKI1402】．

def_texにおいてtskidにTSK_SELF（＝0）を指定すると，自タスクが対象タスク
となる【NGKI1403】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，DEF_TEXのみをサポートする【ASPS0117】．ただし，動的生
成機能拡張パッケージでは，def_texもサポートする【ASPS0118】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，DEF_TEXのみをサポートする【FMPS0111】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，DEF_TEXのみをサポートする【HRPS0111】．ただし，動的生
成機能拡張パッケージでは，def_texもサポートする【HRPS0179】．

【μITRON4.0仕様との関係】

texrtnのデータ型をTEXRTNに変更した．

def_texによって，定義済みのタスク例外処理ルーチンを再定義しようとした場
合に，E_OBJエラーとすることにした．


[[API_ras_tex]]
----
ras_tex		タスク例外処理の要求〔T〕【NGKI1404】
iras_tex	タスク例外処理の要求〔I〕【NGKI1405】
----

【C言語API】
----
	ER ercd = ras_tex(ID tskid, TEXPTN rasptn)
	ER ercd = iras_tex(ID tskid, TEXPTN rasptn)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
	TEXPTN		rasptn		要求するタスク例外処理のタスク例外要因
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（ras_texの場合）【NGKI1406】
				・タスクコンテキストからの呼出し（iras_texの場合）【NGKI1407】
				・CPUロック状態からの呼出し【NGKI1408】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI1409】
	E_PAR		パラメータエラー
				・rasptnが0【NGKI1410】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録〔D〕【NGKI1411】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する通常操作2が許可されていない（ras_tex
				　の場合）〔P〕【NGKI1412】
	E_OBJ		オブジェクト状態エラー
				・対象タスクが休止状態【NGKI1413】
				・対象タスクに対してタスク例外処理ルーチンが定義されてい
				　ない【NGKI1414】
----

【機能】

tskidで指定したタスク（対象タスク）に対して，rasptnで指定したタスク例外
要因のタスク例外処理を要求する．対象タスクの保留例外要因が，それまでの
値とrasptnで指定した値のビット毎論理和（C言語の"|"）に更新される
【NGKI1415】．

ras_texにおいてtskidにTSK_SELF（＝0）を指定すると，自タスクが対象タスク
となる【NGKI1416】．


[[API_dis_tex]]
----
dis_tex		タスク例外処理の禁止〔T〕【NGKI1417】
----

【C言語API】
----
	ER ercd = dis_tex()
----

【パラメータ】
----
	なし
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1419】
				・CPUロック状態からの呼出し【NGKI1420】
	E_OBJ		オブジェクト状態エラー
				・自タスクに対してタスク例外処理ルーチンが定義されていな
				　い【NGKI1421】
----

【機能】

自タスクのタスク例外処理禁止フラグをセットする【NGKI1422】．すなわち，
自タスクをタスク例外処理禁止状態に遷移させる．


[[API_ena_tex]]
----
ena_tex		タスク例外処理の許可〔T〕【NGKI1423】
----

【C言語API】
----
	ER ercd = ena_tex()
----

【パラメータ】
----
	なし
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1424】
				・CPUロック状態からの呼出し【NGKI1425】
	E_OBJ		オブジェクト状態エラー
				・自タスクに対してタスク例外処理ルーチンが定義されていな
				　い【NGKI1426】
----

【機能】

自タスクのタスク例外処理禁止フラグをクリアする【NGKI1427】．すなわち，
自タスクをタスク例外処理許可状態に遷移させる．

【補足説明】

タスク例外処理ルーチン中でena_texを呼び出すことにより，タスク例外処理ルー
チンの多重起動を行うことができる．ただし，多重起動の最大段数を制限する
のは，アプリケーションの責任である．


[[API_sns_tex]]
----
sns_tex		タスク例外処理禁止状態の参照〔TI〕【NGKI1428】
----

【C言語API】
----
	bool_t state = sns_tex()
----

【パラメータ】
----
	なし
----

【リターンパラメータ】
----
	bool_t		state		タスク例外処理禁止状態
----

【機能】

実行状態のタスクのタスク例外処理禁止フラグを参照する．具体的な振舞いは
以下の通り．

実行状態のタスクが，タスク例外処理禁止状態の場合にtrue，タスク例外処理
許可状態の場合にfalseが返る【NGKI1429】．sns_texを非タスクコンテキスト
から呼び出した場合で，実行状態のタスクがない場合には，trueが返る
【NGKI1430】．

マルチプロセッサ対応カーネルにおいては，サービスコールを呼び出した処理
単位を実行しているプロセッサにおいて実行状態のタスクのタスク例外処理禁
止フラグを参照する【NGKI1431】．

【補足説明】

sns_texをタスクコンテキストから呼び出した場合，実行状態のタスクは自タス
クに一致する．


[[API_ref_tex]]
----
ref_tex		タスク例外処理の状態参照〔T〕【NGKI1432】
----

【C言語API】
----
	ER ercd = ref_tex(ID tskid, T_RTEX *pk_rtex)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
	T_RTEX *	pk_rtex		タスク例外処理の現在状態を入れるパケットへ
							のポインタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード

　＊タスク例外処理の現在状態（パケットの内容）
	STAT		texstat		タスク例外処理の状態
	TEXPTN		pndptn		タスクの保留例外要因
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1433】
				・CPUロック状態からの呼出し【NGKI1434】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI1435】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録〔D〕【NGKI1436】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する参照操作が許可されていない〔P〕【NGKI1437】
	E_MACV		メモリアクセス違反
				・pk_rtexが指すメモリ領域への書込みアクセスが許可されて
				　いない〔P〕【NGKI1438】
	E_OBJ		オブジェクト状態エラー
				・対象タスクが休止状態【NGKI1439】
				・対象タスクに対してタスク例外処理ルーチンが定義されてい
				　ない【NGKI1440】
----

【機能】

tskidで指定したタスク（対象タスク）のタスク例外処理に関する現在状態を参
照する．参照した現在状態は，pk_rtexで指定したパケットに返される
【NGKI1441】．

texstatには，対象タスクの現在のタスク例外処理禁止フラグを表す次のいずれ
かの値が返される【NGKI1442】．

	TTEX_ENA	0x01U		タスク例外処理許可状態
	TTEX_DIS	0x02U		タスク例外処理禁止状態

pndptnには，対象タスクの現在の保留例外要因が返される【NGKI1443】．

tskidにTSK_SELF（＝0）を指定すると，自タスクが対象タスクとなる
【NGKI1444】．


=== 同期・通信機能

同期・通信機能は，タスクとは独立したオブジェクトにより，タスクとタスク
の間，または非タスクコンテキストの処理とタスクの間で同期・通信を行うた
めの機能である．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，同期・通信機能をサポートしない【SSPS0127】．

【μITRON4.0仕様との関係】

この仕様では，ランデブ機能はサポートしていない．今後の検討により，ラン
デブ機能をサポートすることに変更する可能性もある．

==== セマフォ

セマフォは，資源の数を表す0以上の整数値を取るカウンタ（資源数）を介して，
排他制御やイベント通知を行うための同期・通信オブジェクトである．セマフォ
の資源数から1を減ずることを資源の獲得，資源数に1を加えることを資源の返
却と呼ぶ．セマフォは，セマフォIDと呼ぶID番号によって識別する【NGKI1445】．

各セマフォが持つ情報は次の通り【NGKI1446】．

* セマフォ属性
* 資源数（の現在値）
* 待ち行列（セマフォの資源獲得待ち状態のタスクのキュー）
* 初期資源数
* 最大資源数
* アクセス許可ベクタ（保護機能対応カーネルの場合）
* 属する保護ドメイン（保護機能対応カーネルの場合）
* 属するクラス（マルチプロセッサ対応カーネルの場合）

待ち行列は，セマフォの資源が獲得できるまで待っている状態（セマフォの資
源獲得待ち状態）のタスクが，資源を獲得できる順序でつながれているキュー
である．

セマフォの初期資源数は，セマフォを生成または再初期化した際の，資源数の
初期値である．また，セマフォの最大資源数は，資源数が取りうる最大値であ
る．資源数が最大資源数に一致している時に資源を返却しようとすると，
E_QOVRエラーとなる【NGKI1447】．

セマフォ属性には，次の属性を指定することができる【NGKI1448】．

	TA_TPRI		0x01U	待ち行列をタスクの優先度順にする

TA_TPRIを指定しない場合，待ち行列はFIFO順になる【NGKI1449】．

セマフォ機能に関連するカーネル構成マクロは次の通り．

	TMAX_MAXSEM		セマフォの最大資源数の最大値（＝UINT_MAX）【NGKI1450】

	TNUM_SEMID		登録できるセマフォの数（動的生成対応でないカーネル
					では，静的APIによって登録されたセマフォの数に一致）
					【NGKI1451】

【μITRON4.0仕様との関係】

TNUM_SEMIDは，μITRON4.0仕様に規定されていないカーネル構成マクロである．


[[API_CRE_SEM]]
----
CRE_SEM		セマフォの生成〔S〕【NGKI1452】
acre_sem	セマフォの生成〔TD〕【NGKI1453】
----

【静的API】
----
	CRE_SEM(ID semid, { ATR sematr, uint_t isemcnt, uint_t maxsem })
----

【C言語API】
----
	ER_ID semid = acre_sem(const T_CSEM *pk_csem)
----

【パラメータ】
----
	ID			semid		生成するセマフォのID番号（CRE_SEMの場合）
	T_CSEM *	pk_csem		セマフォの生成情報を入れたパケットへのポイ
							ンタ（静的APIを除く）

　＊セマフォの生成情報（パケットの内容）
	ATR			sematr		セマフォ属性
	uint_t		isemcnt		セマフォの初期資源数
	uint_t		maxsem		セマフォの最大資源数
----

【リターンパラメータ】
----
	ER_ID		semid		生成されたセマフォのID番号（正の値）または
							エラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI1454】
				・CPUロック状態からの呼出し〔s〕【NGKI1455】
	E_RSATR		予約属性
				・sematrが無効【NGKI1456】
				・属する保護ドメインの指定が有効範囲外〔sP〕【NGKI1457】
				・属するクラスの指定が有効範囲外〔sM〕【NGKI1458】
				・クラスの囲みの中に記述されていない〔SM〕【NGKI1459】
	E_PAR		パラメータエラー
				・maxsemが有効範囲（1以上TMAX_MAXSEM以下）外【NGKI1468】
				・isemcntが有効範囲（0以上maxsem以下）外【NGKI1466】
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する管理操作が許可されていない〔sP〕
				　【NGKI1460】
	E_MACV		メモリアクセス違反
				・pk_csemが指すメモリ領域への読出しアクセスが許可されて
				　いない〔sP〕【NGKI1461】
	E_NOID		ID番号不足
				・割り付けられるセマフォIDがない〔sD〕【NGKI1462】
	E_OBJ		オブジェクト状態エラー
				・semidで指定したセマフォが登録済み（CRE_SEMの場合）
				　【NGKI1463】
----

【機能】

各パラメータで指定したセマフォ生成情報に従って，セマフォを生成する．生
成されたセマフォの資源数は初期資源数に，待ち行列は空の状態に初期化され
る【NGKI1464】．

静的APIにおいては，semidはオブジェクト識別名，sematr，isemcnt，maxsemは
整数定数式パラメータである【NGKI1465】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，CRE_SEMのみをサポートする【ASPS0119】．ただし，動的生
成機能拡張パッケージでは，acre_semもサポートする【ASPS0120】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，CRE_SEMのみをサポートする【FMPS0112】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，CRE_SEMのみをサポートする【HRPS0112】．ただし，動的生
成機能拡張パッケージでは，acre_semもサポートする【HRPS0180】．

[[API_AID_SEM]]
----
AID_SEM		割付け可能なセマフォIDの数の指定〔SD〕【NGKI1469】
----

【静的API】
----
	AID_SEM(uint_t nosem)
----

【パラメータ】
----
	uint_t		nosem		割付け可能なセマフォIDの数
----

【エラーコード】
----
	E_RSATR		予約属性
				・保護ドメインの囲みの中に記述されている〔P〕【NGKI3429】
				・クラスの囲みの中に記述されていない〔M〕【NGKI1470】
	E_PAR		パラメータエラー
				・nosemが負の値【NGKI3277】
----

【機能】

nosemで指定した数のセマフォIDを，セマフォを生成するサービスコールによっ
て割付け可能なセマフォIDとして確保する【NGKI1471】．

nosemは整数定数式パラメータである【NGKI1472】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルの動的生成機能拡張パッケージでは，AID_SEMをサポートする
【ASPS0211】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルの動的生成機能拡張パッケージでは，AID_SEMをサポートする
【HRPS0212】．

[[API_SAC_SEM]]
----
SAC_SEM		セマフォのアクセス許可ベクタの設定〔SP〕【NGKI1473】
sac_sem		セマフォのアクセス許可ベクタの設定〔TPD〕【NGKI1474】
----

【静的API】
----
	SAC_SEM(ID semid, { ACPTN acptn1, ACPTN acptn2,
										ACPTN acptn3, ACPTN acptn4 })
----

【C言語API】
----
	ER ercd = sac_sem(ID semid, const ACVCT *p_acvct)
----

【パラメータ】
----
	ID			semid		対象セマフォのID番号
	ACVCT *		p_acvct		アクセス許可ベクタを入れたパケットへのポ
							インタ（静的APIを除く）

　＊アクセス許可ベクタ（パケットの内容）
	ACPTN		acptn1		通常操作1のアクセス許可パターン
	ACPTN		acptn2		通常操作2のアクセス許可パターン
	ACPTN		acptn3		管理操作のアクセス許可パターン
	ACPTN		acptn4		参照操作のアクセス許可パターン
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI1475】
				・CPUロック状態からの呼出し〔s〕【NGKI1476】
	E_ID		不正ID番号
				・semidが有効範囲外〔s〕【NGKI1477】
	E_RSATR		予約属性
				・対象セマフォが属する保護ドメインの囲みの中（対象セマ
				　フォが無所属の場合は，保護ドメインの囲みの外）に記述
				　されていない〔S〕【NGKI1478】
				・対象セマフォが属するクラスの囲みの中に記述されていな
				　い〔SM〕【NGKI1479】
	E_NOEXS		オブジェクト未登録
				・対象セマフォが未登録【NGKI1480】
	E_OACV		オブジェクトアクセス違反
				・対象セマフォに対する管理操作が許可されていない〔s〕
				　【NGKI1481】
	E_MACV		メモリアクセス違反
				・p_acvctが指すメモリ領域への読出しアクセスが許可されて
				　いない〔s〕【NGKI1482】
	E_OBJ		オブジェクト状態エラー
				・対象セマフォは静的APIで生成された〔s〕【NGKI1483】
				・対象セマフォに対してアクセス許可ベクタが設定済み〔S〕
				　【NGKI1484】
----

【機能】

semidで指定したセマフォ（対象セマフォ）のアクセス許可ベクタ（4つのアク
セス許可パターンの組）を，各パラメータで指定した値に設定する
【NGKI1485】．

静的APIにおいては，semidはオブジェクト識別名，acptn1〜acptn4は整数定数
式パラメータである【NGKI1486】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，SAC_SEMのみをサポートする【HRPS0113】．ただし，動的生
成機能拡張パッケージでは，sac_semもサポートする【HRPS0181】．

[[API_del_sem]]
----
del_sem		セマフォの削除〔TD〕【NGKI1487】
----

【C言語API】
----
	ER ercd = del_sem(ID semid)
----

【パラメータ】
----
	ID			semid		対象セマフォのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1488】
				・CPUロック状態からの呼出し【NGKI1489】
	E_ID		不正ID番号
				・semidが有効範囲外【NGKI1490】
	E_NOEXS		オブジェクト未登録
				・対象セマフォが未登録【NGKI1491】
	E_OACV		オブジェクトアクセス違反
				・対象セマフォに対する管理操作が許可されていない〔P〕
				　【NGKI1492】
	E_OBJ		オブジェクト状態エラー
				・対象セマフォは静的APIで生成された【NGKI1493】
----

【機能】

semidで指定したセマフォ（対象セマフォ）を削除する．具体的な振舞いは以下
の通り．

対象セマフォの登録が解除され，そのセマフォIDが未使用の状態に戻される
【NGKI1494】．また，対象セマフォの待ち行列につながれたタスクは，待ち行
列の先頭のタスクから順に待ち解除される【NGKI1495】．待ち解除されたタス
クには，待ち状態となったサービスコールからE_DLTエラーが返る【NGKI1496】．

【使用上の注意】

del_semにより複数のタスクが待ち解除される場合，サービスコールの処理時間
およびカーネル内での割込み禁止時間が，待ち解除されるタスクの数に比例し
て長くなる．特に，多くのタスクが待ち解除される場合，カーネル内での割込
み禁止時間が長くなるため，注意が必要である．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，del_semをサポートしない【ASPS0122】．ただし，動的生成
機能拡張パッケージでは，del_semをサポートする【ASPS0123】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，del_semをサポートしない【FMPS0114】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，del_semをサポートしない【HRPS0114】．ただし，動的生成
機能拡張パッケージでは，del_semをサポートする【HRPS0182】．


[[API_sig_sem]]
----
sig_sem		セマフォの資源の返却〔T〕【NGKI1497】
isig_sem	セマフォの資源の返却〔I〕【NGKI1498】
----

【C言語API】
----
	ER ercd = sig_sem(ID semid)
	ER ercd = isig_sem(ID semid)
----

【パラメータ】
----
	ID			semid		対象セマフォのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（sig_semの場合）【NGKI1499】
				・タスクコンテキストからの呼出し（isig_semの場合）【NGKI1500】
				・CPUロック状態からの呼出し【NGKI1501】
	E_ID		不正ID番号
				・semidが有効範囲外【NGKI1502】
	E_NOEXS		オブジェクト未登録
				・対象セマフォが未登録〔D〕【NGKI1503】
	E_OACV		オブジェクトアクセス違反
				・対象セマフォに対する通常操作1が許可されていない（sig_sem
				　の場合）〔P〕【NGKI1504】
	E_QOVR		キューイングオーバフロー
				・条件については機能の項を参照
----

【機能】

semidで指定したセマフォ（対象セマフォ）に資源を返却する．具体的な振舞い
は以下の通り．

対象セマフォの待ち行列にタスクが存在する場合には，待ち行列の先頭のタス
クが待ち解除される【NGKI1505】．この時，待ち解除されたタスクが資源を獲
得したことになるため，対象セマフォの資源数は変化しない【NGKI1506】．待
ち解除されたタスクには，待ち状態となったサービスコールからE_OKが返る
【NGKI1507】．

待ち行列にタスクが存在しない場合には，対象セマフォの資源数に1が加えられ
る【NGKI1508】．資源数に1を加えるとそのセマフォの最大資源数を越える場合
には，E_QOVRエラーとなる【NGKI1509】．

[[API_wai_sem]]
----
wai_sem		セマフォの資源の獲得〔T〕【NGKI1510】
pol_sem		セマフォの資源の獲得（ポーリング）〔T〕【NGKI1511】
twai_sem	セマフォの資源の獲得（タイムアウト付き）〔T〕【NGKI1512】
----

【C言語API】
----
	ER ercd = wai_sem(ID semid)
	ER ercd = pol_sem(ID semid)
	ER ercd = twai_sem(ID semid, TMO tmout)
----

【パラメータ】
----
	ID			semid		対象セマフォのID番号
	TMO			tmout		タイムアウト時間（twai_semの場合）
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1513】
				・CPUロック状態からの呼出し【NGKI1514】
				・ディスパッチ保留状態からの呼出し（pol_semを除く）【NGKI1515】
	E_NOSPT		未サポート機能
				・制約タスクからの呼出し（pol_semを除く）【NGKI1516】
	E_ID		不正ID番号
				・semidが有効範囲外【NGKI1517】
	E_PAR		パラメータエラー
				・tmoutが無効（twai_semの場合）【NGKI1518】
	E_NOEXS		オブジェクト未登録
				・対象セマフォが未登録〔D〕【NGKI1519】
	E_OACV		オブジェクトアクセス違反
				・対象セマフォに対する通常操作2が許可されていない〔P〕
				　【NGKI1520】
	E_TMOUT		ポーリング失敗またはタイムアウト（wai_semを除く）【NGKI1521】
	E_RLWAI		待ち禁止状態または待ち状態の強制解除（pol_semを除く）
				【NGKI1522】
	E_DLT		待ちオブジェクトの削除または再初期化（pol_semを除く）
				【NGKI1523】
----

【機能】

semidで指定したセマフォ（対象セマフォ）から資源を獲得する．具体的な振舞
いは以下の通り．

対象セマフォの資源数が1以上の場合には，資源数から1が減ぜられる
【NGKI1524】．資源数が0の場合には，自タスクはセマフォの資源獲得待ち状態
となり，対象セマフォの待ち行列につながれる【NGKI1525】．


[[API_ini_sem]]
----
ini_sem		セマフォの再初期化〔T〕【NGKI1526】
----

【C言語API】
----
	ER ercd = ini_sem(ID semid)
----

【パラメータ】
----
	ID			semid		対象セマフォのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1527】
				・CPUロック状態からの呼出し【NGKI1528】
	E_ID		不正ID番号
				・semidが有効範囲外【NGKI1529】
	E_NOEXS		オブジェクト未登録
				・対象セマフォが未登録〔D〕【NGKI1530】
	E_OACV		オブジェクトアクセス違反
				・対象セマフォに対する管理操作が許可されていない〔P〕
				　【NGKI1531】
----

【機能】

semidで指定したセマフォ（対象セマフォ）を再初期化する．具体的な振舞いは
以下の通り．

対象セマフォの資源数は，初期資源数に初期化される【NGKI1532】．また，対
象セマフォの待ち行列につながれたタスクは，待ち行列の先頭のタスクから順
に待ち解除される【NGKI1533】．待ち解除されたタスクには，待ち状態となっ
たサービスコールからE_DLTエラーが返る【NGKI1534】．

【使用上の注意】

ini_semにより複数のタスクが待ち解除される場合，サービスコールの処理時間
およびカーネル内での割込み禁止時間が，待ち解除されるタスクの数に比例し
て長くなる．特に，多くのタスクが待ち解除される場合，カーネル内での割込
み禁止時間が長くなるため，注意が必要である．

セマフォを再初期化した場合に，アプリケーションとの整合性を保つのは，ア
プリケーションの責任である．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていないサービスコールである．


[[API_ref_sem]]
----
ref_sem		セマフォの状態参照〔T〕【NGKI1535】
----

【C言語API】
----
	ER ercd = ref_sem(ID semid, T_RSEM *pk_rsem)
----

【パラメータ】
----
	ID			semid		対象セマフォのID番号
	T_RSEM *	pk_rsem		セマフォの現在状態を入れるパケットへのポイ
							ンタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード

　＊セマフォの現在状態（パケットの内容）
	ID			wtskid		セマフォの待ち行列の先頭のタスクのID番号
	uint_t		semcnt		セマフォの資源数
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1536】
				・CPUロック状態からの呼出し【NGKI1537】
	E_ID		不正ID番号
				・semidが有効範囲外【NGKI1538】
	E_NOEXS		オブジェクト未登録
				・対象セマフォが未登録〔D〕【NGKI1539】
	E_OACV		オブジェクトアクセス違反
				・対象セマフォに対する参照操作が許可されていない〔P〕
				　【NGKI1540】
	E_MACV		メモリアクセス違反
				・pk_rsemが指すメモリ領域への書込みアクセスが許可されて
				　いない〔P〕【NGKI1541】
----

【機能】

semidで指定したセマフォ（対象セマフォ）の現在状態を参照する．参照した現
在状態は，pk_rsemで指定したパケットに返される【NGKI1542】．

対象セマフォの待ち行列にタスクが存在しない場合，wtskidにはTSK_NONE（＝
0）が返る【NGKI1543】．

【使用上の注意】

ref_semはデバッグ時向けの機能であり，その他の目的に使用することは推奨し
ない．これは，ref_semを呼び出し，対象セマフォの現在状態を参照した直後に
割込みが発生した場合，ref_semから戻ってきた時には対象セマフォの状態が変
化している可能性があるためである．


==== イベントフラグ

イベントフラグは，イベントの発生の有無を表すビットの集合（ビットパター
ン）を介して，イベント通知を行うための同期・通信オブジェクトである．イ
ベントが発生している状態を1，発生していない状態を0とし，ビットパターン
により複数のイベントの発生の有無を表す【NGKI1544】．イベントフラグは，
イベントフラグIDと呼ぶID番号によって識別する【NGKI1545】．

1つまたは複数のビットをセットする1にする（セットする）ことを，イベント
フラグをセットするといい，0にする（クリアする）ことを，イベントフラグを
クリアするという．イベントフラグによりイベントを通知する側のタスクは，
イベントフラグをセットまたはクリアすることで，イベントの発生を通知する．

イベントフラグによりイベントの通知を受ける側のタスクは，待ちビットパター
ンと待ちモードにより，どのビットがセットされるのを待つかを指定する．待
ちモードにTWF_ORW（＝0x01U）を指定した場合，待ちビットパターンに含まれ
るいずれかのビットがセットされるのを待つ【NGKI1546】．待ちモードに
TWF_ANDW（＝0x02U）を指定した場合，待ちビットパターンに含まれるすべての
ビットがセットされるのを待つ【NGKI1547】．この条件を，イベントフラグの
待ち解除の条件と呼ぶ．

各イベントフラグが持つ情報は次の通り【NGKI1548】．

* イベントフラグ属性
* ビットパターン（の現在値）
* 待ち行列（イベントフラグ待ち状態のタスクのキュー）
* 初期ビットパターン
* アクセス許可ベクタ（保護機能対応カーネルの場合）
* 属する保護ドメイン（保護機能対応カーネルの場合）
* 属するクラス（マルチプロセッサ対応カーネルの場合）

待ち行列は，イベントフラグが指定した待ち解除の条件を満たすまで待ってい
る状態（イベントフラグ待ち状態）のタスクがつながれているキューである．
待ち行列につながれたタスクの待ち解除は，待ち解除の条件を満たした中で，
待ち行列の前方につながれたものから順に行われる（〔NGKI0216〕に該当）
【NGKI1549】．

イベントフラグの初期ビットパターンは，イベントフラグを生成または再初期
化した際の，ビットパターンの初期値である．

イベントフラグ属性には，次の属性を指定することができる【NGKI1550】．

	TA_TPRI		0x01U	待ち行列をタスクの優先度順にする
	TA_WMUL		0x02U	複数のタスクが待つのを許す
	TA_CLR		0x04U	タスクの待ち解除時にイベントフラグをクリアする

TA_TPRIを指定しない場合，待ち行列はFIFO順になる【NGKI1551】．TA_WMULを
指定しない場合，1つのイベントフラグに複数のタスクが待つことを禁止する
【NGKI1552】．

TA_CLRを指定した場合，タスクの待ち解除時に，イベントフラグのビットパター
ンを0にクリアする【NGKI1553】．TA_CLRを指定しない場合，タスクの待ち解除
時にイベントフラグをクリアしない【NGKI1554】．

イベントフラグ機能に用いるデータ型は次の通り．

	FLGPTN		イベントフラグのビットパターン（符号無し整数，uint_tに
				定義）【NGKI1555】

イベントフラグ機能に関連するカーネル構成マクロは次の通り．

	TBIT_FLGPTN		イベントフラグのビット数（FLGPTNの有効ビット数）
					【NGKI1556】

	TNUM_FLGID		登録できるイベントフラグの数（動的生成対応でないカー
					ネルでは，静的APIによって登録されたイベントフラグの
					数に一致）【NGKI1557】

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，イベントフラグのビット数（TBIT_FLGPTN）は16以上である
【ASPS0124】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，イベントフラグのビット数（TBIT_FLGPTN）は16以上である
【FMPS0115】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，イベントフラグのビット数（TBIT_FLGPTN）は16以上である
【HRPS0115】．

【μITRON4.0仕様との関係】

TNUM_FLGIDは，μITRON4.0仕様に規定されていないカーネル構成マクロである．

[[API_CRE_FLG]]
----
CRE_FLG		イベントフラグの生成〔S〕【NGKI1558】
acre_flg	イベントフラグの生成〔TD〕【NGKI1559】
----

【静的API】
----
	CRE_FLG(ID flgid, { ATR flgatr, FLGPTN iflgptn })
----

【C言語API】
----
	ER_ID flgid = acre_flg(const T_CFLG *pk_cflg)
----

【パラメータ】
----
	ID			flgid		生成するイベントフラグのID番号（CRE_FLGの
							場合）
	T_CFLG *	pk_cflg		イベントフラグの生成情報を入れたパケットへ
							のポインタ（静的APIを除く）

　＊イベントフラグの生成情報（パケットの内容）
	ATR			flgatr		イベントフラグ属性
	FLGPTN		iflgptn		イベントフラグの初期ビットパターン
----

【リターンパラメータ】
----
	ER_ID		flgid		生成されたイベントフラグのID番号（正の値）
							またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI1560】
				・CPUロック状態からの呼出し〔s〕【NGKI1561】
	E_RSATR		予約属性
				・flgatrが無効【NGKI1562】
				・属する保護ドメインの指定が有効範囲外〔sP〕【NGKI1563】
				・属するクラスの指定が有効範囲外〔sM〕【NGKI1564】
				・クラスの囲みの中に記述されていない〔SM〕【NGKI1565】
	E_PAR		パラメータエラー
				・iflgptnがFLGPTNに格納できない〔S〕【NGKI3275】
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する管理操作が許可されていない〔sP〕
				　【NGKI1566】
	E_MACV		メモリアクセス違反
				・pk_cflgが指すメモリ領域への読出しアクセスが許可されて
				　いない〔sP〕【NGKI1567】
	E_NOID		ID番号不足
				・割り付けられるイベントフラグIDがない〔sD〕【NGKI1568】
	E_OBJ		オブジェクト状態エラー
				・flgidで指定したイベントフラグが登録済み（CRE_FLGの場合）
				　【NGKI1569】
----

【機能】

各パラメータで指定したイベントフラグ生成情報に従って，イベントフラグを
生成する．生成されたイベントフラグのビットパターンは初期ビットパターン
に，待ち行列は空の状態に初期化される【NGKI1570】．

静的APIにおいては，flgidはオブジェクト識別名，flgatrとiflgptnは整数定数
式パラメータである【NGKI1571】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，CRE_FLGのみをサポートする【ASPS0125】．ただし，動的生
成機能拡張パッケージでは，acre_flgもサポートする【ASPS0126】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，CRE_FLGのみをサポートする【FMPS0116】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，CRE_FLGのみをサポートする【HRPS0116】．ただし，動的生
成機能拡張パッケージでは，acre_flgもサポートする【HRPS0183】．


[[API_AID_FLG]]
----
AID_FLG		割付け可能なイベントフラグIDの数の指定〔SD〕【NGKI1572】
----

【静的API】
----
	AID_FLG(uint_t noflg)
----

【パラメータ】
----
	uint_t		noflg		割付け可能なイベントフラグIDの数
----

【エラーコード】
----
	E_RSATR		予約属性
				・保護ドメインの囲みの中に記述されている〔P〕【NGKI3430】
				・クラスの囲みの中に記述されていない〔M〕【NGKI1573】
	E_PAR		パラメータエラー
				・noflgが負の値【NGKI3278】
----

【機能】

noflgで指定した数のイベントフラグIDを，イベントフラグを生成するサービス
コールによって割付け可能なイベントフラグIDとして確保する【NGKI1574】．

noflgは整数定数式パラメータである【NGKI1575】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルの動的生成機能拡張パッケージでは，AID_FLGをサポートする
【ASPS0212】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルの動的生成機能拡張パッケージでは，AID_FLGをサポートする
【HRPS0213】．


[[API_SAC_FLG]]
----
SAC_FLG		イベントフラグのアクセス許可ベクタの設定〔SP〕【NGKI1576】
sac_flg		イベントフラグのアクセス許可ベクタの設定〔TPD〕【NGKI1577】
----

【静的API】
----
	SAC_FLG(ID flgid, { ACPTN acptn1, ACPTN acptn2,
										ACPTN acptn3, ACPTN acptn4 })
----

【C言語API】
----
	ER ercd = sac_flg(ID flgid, const ACVCT *p_acvct)
----

【パラメータ】
----
	ID			flgid		対象イベントフラグのID番号
	ACVCT *		p_acvct		アクセス許可ベクタを入れたパケットへのポ
							インタ（静的APIを除く）

　＊アクセス許可ベクタ（パケットの内容）
	ACPTN		acptn1		通常操作1のアクセス許可パターン
	ACPTN		acptn2		通常操作2のアクセス許可パターン
	ACPTN		acptn3		管理操作のアクセス許可パターン
	ACPTN		acptn4		参照操作のアクセス許可パターン
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI1578】
				・CPUロック状態からの呼出し〔s〕【NGKI1579】
	E_ID		不正ID番号
				・flgidが有効範囲外〔s〕【NGKI1580】
	E_RSATR		予約属性
				・対象イベントフラグが属する保護ドメインの囲みの中（対
				　象イベントフラグが無所属の場合は，保護ドメインの囲み
				　の外）に記述されていない〔S〕【NGKI1581】
				・対象イベントフラグが属するクラスの囲みの中に記述され
				　ていない〔SM〕【NGKI1582】
	E_NOEXS		オブジェクト未登録
				・対象イベントフラグが未登録【NGKI1583】
	E_OACV		オブジェクトアクセス違反
				・対象イベントフラグに対する管理操作が許可されていない〔s〕
				　【NGKI1584】
	E_MACV		メモリアクセス違反
				・p_acvctが指すメモリ領域への読出しアクセスが許可されて
				　いない〔s〕【NGKI1585】
	E_OBJ		オブジェクト状態エラー
				・対象イベントフラグは静的APIで生成された〔s〕【NGKI1586】
				・対象イベントフラグに対してアクセス許可ベクタが設定済
				　み〔S〕【NGKI1587】
----

【機能】

flgidで指定したイベントフラグ（対象イベントフラグ）のアクセス許可ベクタ
（4つのアクセス許可パターンの組）を，各パラメータで指定した値に設定する
【NGKI1588】．

静的APIにおいては，flgidはオブジェクト識別名，acptn1〜acptn4は整数定数
式パラメータである【NGKI1589】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，SAC_FLGのみをサポートする【HRPS0117】．ただし，動的生
成機能拡張パッケージでは，sac_flgもサポートする【HRPS0184】．


[[API_del_flg]]
----
del_flg		イベントフラグの削除〔TD〕【NGKI1590】
----

【C言語API】
----
	ER ercd = del_flg(ID flgid)
----

【パラメータ】
----
	ID			flgid		対象イベントフラグのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1591】
				・CPUロック状態からの呼出し【NGKI1592】
	E_ID		不正ID番号
				・flgidが有効範囲外【NGKI1593】
	E_NOEXS		オブジェクト未登録
				・対象イベントフラグが未登録【NGKI1594】
	E_OACV		オブジェクトアクセス違反
				・対象イベントフラグに対する管理操作が許可されていない〔P〕
				　【NGKI1595】
	E_OBJ		オブジェクト状態エラー
				・対象イベントフラグは静的APIで生成された【NGKI1596】
----

【機能】

flgidで指定したイベントフラグ（対象イベントフラグ）を削除する．具体的な
振舞いは以下の通り．

対象イベントフラグの登録が解除され，そのイベントフラグIDが未使用の状態
に戻される【NGKI1597】．また，対象イベントフラグの待ち行列につながれた
タスクは，待ち行列の先頭のタスクから順に待ち解除される【NGKI1598】．待
ち解除されたタスクには，待ち状態となったサービスコールからE_DLTエラーが
返る【NGKI1599】．

【使用上の注意】

del_flgにより複数のタスクが待ち解除される場合，サービスコールの処理時間
およびカーネル内での割込み禁止時間が，待ち解除されるタスクの数に比例し
て長くなる．特に，多くのタスクが待ち解除される場合，カーネル内での割込
み禁止時間が長くなるため，注意が必要である．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，del_flgをサポートしない【ASPS0128】．ただし，動的生成
機能拡張パッケージでは，del_flgをサポートする【ASPS0129】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，del_flgをサポートしない【FMPS0118】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，del_flgをサポートしない【HRPS0118】．ただし，動的生成
機能拡張パッケージでは，del_flgをサポートする【HRPS0185】．


[[API_set_flg]]
----
set_flg		イベントフラグのセット〔T〕【NGKI1600】
iset_flg	イベントフラグのセット〔I〕【NGKI1601】
----

【C言語API】
----
	ER ercd = set_flg(ID flgid, FLGPTN setptn)
	ER ercd = iset_flg(ID flgid, FLGPTN setptn)
----

【パラメータ】
----
	ID			flgid		対象イベントフラグのID番号
	FLGPTN		setptn		セットするビットパターン
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（set_flgの場合）【NGKI1602】
				・タスクコンテキストからの呼出し（iset_flgの場合）【NGKI1603】
				・CPUロック状態からの呼出し【NGKI1604】
	E_ID		不正ID番号
				・flgidが有効範囲外【NGKI1605】
	E_NOEXS		オブジェクト未登録
				・対象イベントフラグが未登録〔D〕【NGKI1606】
	E_OACV		オブジェクトアクセス違反
				・対象イベントフラグに対する通常操作1が許可されていない
				　（set_flgの場合）〔P〕【NGKI1607】
----

【機能】

flgidで指定したイベントフラグ（対象イベントフラグ）のsetptnで指定したビッ
トをセットする．具体的な振舞いは以下の通り．

対象イベントフラグのビットパターンは，それまでの値とsetptnで指定した値
のビット毎論理和（C言語の"|"）に更新される【NGKI1608】．対象イベントフ
ラグの待ち行列にタスクが存在する場合には，待ち解除の条件を満たしたタス
クが，待ち行列の前方につながれたものから順に待ち解除される【NGKI1609】．
待ち解除されたタスクには，待ち状態となったサービスコールからE_OKが返る
【NGKI1610】．

ただし，対象イベントフラグがTA_CLR属性である場合には，待ち解除の条件を
満たしたタスクを1つ待ち解除した時点で，対象イベントフラグのビットパター
ンが0にクリアされるため，他のタスクが待ち解除されることはない．

【使用上の注意】

対象イベントフラグが，TA_WMUL属性であり，TA_CLR属性でない場合，set_flg
またはiset_flgにより複数のタスクが待ち解除される場合がある．この場合，
サービスコールの処理時間およびカーネル内での割込み禁止時間が，待ち解除
されるタスクの数に比例して長くなる．特に，多くのタスクが待ち解除される
場合，カーネル内での割込み禁止時間が長くなるため，注意が必要である．


[[API_clr_flg]]
----
clr_flg		イベントフラグのクリア〔T〕【NGKI1611】
----

【C言語API】
----
	ER ercd = clr_flg(ID flgid, FLGPTN clrptn)
----

【パラメータ】
----
	ID			flgid		対象イベントフラグのID番号
	FLGPTN		clrptn		クリアするビットパターン（クリアしないビッ
							トを1，クリアするビットを0とする）
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1612】
				・CPUロック状態からの呼出し【NGKI1613】
	E_ID		不正ID番号
				・flgidが有効範囲外【NGKI1614】
	E_NOEXS		オブジェクト未登録
				・対象イベントフラグが未登録〔D〕【NGKI1615】
	E_OACV		オブジェクトアクセス違反
				・対象イベントフラグに対する通常操作1が許可されていない〔P〕
				　【NGKI1616】
----

【機能】

flgidで指定したイベントフラグ（対象イベントフラグ）のclrptnで指定したビッ
トをクリアする．対象イベントフラグのビットパターンは，それまでの値と
clrptnで指定した値のビット毎論理積（C言語の"&"）に更新される
【NGKI1617】．


[[API_wai_flg]]
----
wai_flg		イベントフラグ待ち〔T〕【NGKI1618】
pol_flg		イベントフラグ待ち（ポーリング）〔T〕【NGKI1619】
twai_flg	イベントフラグ待ち（タイムアウト付き）〔T〕【NGKI1620】
----

【C言語API】
----
	ER ercd = wai_flg(ID flgid, FLGPTN waiptn, MODE wfmode, FLGPTN *p_flgptn)
	ER ercd = pol_flg(ID flgid, FLGPTN waiptn, MODE wfmode, FLGPTN *p_flgptn)
	ER ercd = twai_flg(ID flgid, FLGPTN waiptn,
									MODE wfmode, FLGPTN *p_flgptn, TMO tmout)
----

【パラメータ】
----
	ID			flgid		対象イベントフラグのID番号
	FLGPTN		waiptn		待ちビットパターン
	MODE		wfmode		待ちモード
	FLGPTN *	p_flgptn	待ち解除時のビットパターンを入れるメモリ領
							域へのポインタ
	TMO			tmout		タイムアウト時間（twai_flgの場合）
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
	FLGPTN		flgptn		待ち解除時のビットパターン
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1621】
				・CPUロック状態からの呼出し【NGKI1622】
				・ディスパッチ保留状態からの呼出し（pol_flgを除く）【NGKI1623】
	E_NOSPT		未サポート機能
				・制約タスクからの呼出し（pol_flgを除く）【NGKI1624】
	E_ID		不正ID番号
				・flgidが有効範囲外【NGKI1625】
	E_PAR		パラメータエラー
				・waiptnが0【NGKI1626】
				・wfmodeが無効（TWF_ORWまたはTWF_ANDWでない）【NGKI1627】
				・tmoutが無効（twai_flgの場合）【NGKI1628】
	E_NOEXS		オブジェクト未登録
				・対象イベントフラグが未登録〔D〕【NGKI1629】
	E_OACV		オブジェクトアクセス違反
				・対象イベントフラグに対する通常操作2が許可されていない〔P〕
				　【NGKI1630】
	E_MACV		メモリアクセス違反
				・p_flgptnが指すメモリ領域への書込みアクセスが許可され
				　ていない〔P〕【NGKI1631】
	E_ILUSE		サービスコール不正使用
				・TA_WMUL属性でないイベントフラグで待ちタスクあり【NGKI1632】
	E_TMOUT		ポーリング失敗またはタイムアウト（wai_flgを除く）【NGKI1633】
	E_RLWAI		待ち禁止状態または待ち状態の強制解除（pol_flgを除く）
				【NGKI1634】
	E_DLT		待ちオブジェクトの削除または再初期化（pol_flgを除く）
				【NGKI1635】
----

【機能】

flgidで指定したイベントフラグ（対象イベントフラグ）が，waiptnとwfmodeで
指定した待ち解除の条件を満たすのを待つ．具体的な振舞いは以下の通り．

対象イベントフラグが，waiptnとwfmodeで指定した待ち解除の条件を満たして
いる場合には，対象イベントフラグのビットパターンの現在値がp_flgptnが指
すメモリ領域に返される【NGKI1636】．対象イベントフラグがTA_CLR属性であ
る場合には，対象イベントフラグのビットパターンが0にクリアされる
【NGKI1637】．

待ち解除の条件を満たしていない場合には，自タスクはイベントフラグ待ち状
態となり，対象イベントフラグの待ち行列につながれる【NGKI1638】．


[[API_ini_flg]]
----
ini_flg		イベントフラグの再初期化〔T〕【NGKI1639】
----

【C言語API】
----
	ER ercd = ini_flg(ID flgid)
----

【パラメータ】
----
	ID			flgid		対象イベントフラグのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1640】
				・CPUロック状態からの呼出し【NGKI1641】
	E_ID		不正ID番号
				・flgidが有効範囲外【NGKI1642】
	E_NOEXS		オブジェクト未登録
				・対象イベントフラグが未登録〔D〕【NGKI1643】
	E_OACV		オブジェクトアクセス違反
				・対象イベントフラグに対する管理操作が許可されていない〔P〕
				　【NGKI1644】
----

【機能】

flgidで指定したイベントフラグ（対象イベントフラグ）を再初期化する．具体
的な振舞いは以下の通り．

対象イベントフラグのビットパターンは，初期ビットパターンに初期化される
【NGKI1645】．また，対象イベントフラグの待ち行列につながれたタスクは，
待ち行列の先頭のタスクから順に待ち解除される【NGKI1646】．待ち解除され
たタスクには，待ち状態となったサービスコールからE_DLTエラーが返る
【NGKI1647】．

【使用上の注意】

ini_flgにより複数のタスクが待ち解除される場合，サービスコールの処理時間
およびカーネル内での割込み禁止時間が，待ち解除されるタスクの数に比例し
て長くなる．特に，多くのタスクが待ち解除される場合，カーネル内での割込
み禁止時間が長くなるため，注意が必要である．

イベントフラグを再初期化した場合に，アプリケーションとの整合性を保つの
は，アプリケーションの責任である．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていないサービスコールである．


[[API_ref_flg]]
----
ref_flg		イベントフラグの状態参照〔T〕【NGKI1648】
----

【C言語API】
----
	ER ercd = ref_flg(ID flgid, T_RFLG *pk_rflg)
----

【パラメータ】
----
	ID			flgid		対象イベントフラグのID番号
	T_RFLG *	pk_rflg		イベントフラグの現在状態を入れるパケットへ
							のポインタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード

　＊イベントフラグの現在状態（パケットの内容）
	ID			wtskid		イベントフラグの待ち行列の先頭のタスクのID
							番号
	uint_t		flgptn		イベントフラグのビットパターン
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1649】
				・CPUロック状態からの呼出し【NGKI1650】
	E_ID		不正ID番号
				・flgidが有効範囲外【NGKI1651】
	E_NOEXS		オブジェクト未登録
				・対象イベントフラグが未登録〔D〕【NGKI1652】
	E_OACV		オブジェクトアクセス違反
				・対象イベントフラグに対する参照操作が許可されていない
				　〔P〕【NGKI1653】
	E_MACV		メモリアクセス違反
				・pk_rflgが指すメモリ領域への書込みアクセスが許可されて
				　いない〔P〕【NGKI1654】
----

【機能】

flgidで指定したイベントフラグ（対象イベントフラグ）の現在状態を参照する．
参照した現在状態は，pk_rflgで指定したパケットに返される【NGKI1655】．

対象イベントフラグの待ち行列にタスクが存在しない場合，wtskidには
TSK_NONE（＝0）が返る【NGKI1656】．

【使用上の注意】

ref_flgはデバッグ時向けの機能であり，その他の目的に使用することは推奨し
ない．これは，ref_flgを呼び出し，対象イベントフラグの現在状態を参照した
直後に割込みが発生した場合，ref_flgから戻ってきた時には対象イベントフラ
グの状態が変化している可能性があるためである．


==== データキュー

データキューは，1ワードのデータをメッセージとして，FIFO順で送受信するた
めの同期・通信オブジェクトである．より大きいサイズのメッセージを送受信
したい場合には，メッセージを置いたメモリ領域へのポインタを1ワードのデー
タとして送受信する方法がある．データキューは，データキューIDと呼ぶID番
号によって識別する【NGKI1657】．

各データキューが持つ情報は次の通り【NGKI1658】．

* データキュー属性
* データキュー管理領域
* 送信待ち行列（データキューへの送信待ち状態のタスクのキュー）
* 受信待ち行列（データキューからの受信待ち状態のタスクのキュー）
* アクセス許可ベクタ（保護機能対応カーネルの場合）
* 属する保護ドメイン（保護機能対応カーネルの場合）
* 属するクラス（マルチプロセッサ対応カーネルの場合）

データキュー管理領域は，データキューに送信されたデータを，送信された順
に格納しておくためのメモリ領域である．データキュー生成時に，データキュー
管理領域に格納できるデータ数を0とすることで，データキュー管理領域のサイ
ズを0とすることができる【NGKI1659】．

保護機能対応カーネルにおいて，データキュー管理領域は，カーネルの用いる
オブジェクト管理領域として扱われる【NGKI1660】．

送信待ち行列は，データキューに対してデータが送信できるまで待っている状
態（データキューへの送信待ち状態）のタスクが，データを送信できる順序で
つながれているキューである．また，受信待ち行列は，データキューからデー
タが受信できるまで待っている状態（データキューからの受信待ち状態）のタ
スクが，データを受信できる順序でつながれているキューである．

データキュー属性には，次の属性を指定することができる【NGKI1661】．

	TA_TPRI		0x01U	送信待ち行列をタスクの優先度順にする

TA_TPRIを指定しない場合，送信待ち行列はFIFO順になる【NGKI1662】．受信待
ち行列は，FIFO順に固定されている【NGKI1663】．

データキュー機能に関連するカーネル構成マクロは次の通り．

	TNUM_DTQID		登録できるデータキューの数（動的生成対応でないカー
					ネルでは，静的APIによって登録されたデータキューの数
					に一致）【NGKI1664】

【μITRON4.0仕様との関係】

TNUM_DTQIDは，μITRON4.0仕様に規定されていないカーネル構成マクロである．


[[API_CRE_DTQ]]
----
CRE_DTQ		データキューの生成〔S〕【NGKI1665】
acre_dtq	データキューの生成〔TD〕【NGKI1666】
----

【静的API】
----
	CRE_DTQ(ID dtqid, { ATR dtqatr, uint_t dtqcnt, void *dtqmb })
----

【C言語API】
----
	ER_ID dtqid = acre_dtq(const T_CDTQ *pk_cdtq)
----

【パラメータ】
----
	ID			dtqid		生成するデータキューのID番号（CRE_DTQの場合）
	T_CDTQ *	pk_cdtq		データキューの生成情報を入れたパケットへの
							ポインタ（静的APIを除く）

　＊データキューの生成情報（パケットの内容）
	ATR			dtqatr		データキュー属性
	uint_t		dtqcnt		データキュー管理領域に格納できるデータ数
	void *		dtqmb		データキュー管理領域の先頭番地
----

【リターンパラメータ】
----
	ER_ID		dtqid		生成されたデータキューのID番号（正の値）ま
							たはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI1667】
				・CPUロック状態からの呼出し〔s〕【NGKI1668】
	E_RSATR		予約属性
				・dtqatrが無効【NGKI1669】
				・属する保護ドメインの指定が有効範囲外〔sP〕【NGKI1670】
				・属するクラスの指定が有効範囲外〔sM〕【NGKI1671】
				・クラスの囲みの中に記述されていない〔SM〕【NGKI1672】
	E_NOSPT		未サポート機能
				・条件については各カーネルにおける規定の項を参照
	E_PAR		パラメータエラー
				・dtqcntが負の値〔S〕【NGKI3288】
				・その他の条件については機能の項を参照
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する管理操作が許可されていない〔sP〕
				　【NGKI1673】
	E_MACV		メモリアクセス違反
				・pk_cdtqが指すメモリ領域への読出しアクセスが許可されて
				　いない〔sP〕【NGKI1674】
	E_NOID		ID番号不足
				・割り付けられるデータキューIDがない〔sD〕【NGKI1675】
	E_NOMEM		メモリ不足
				・データキュー管理領域が確保できない【NGKI1676】
	E_OBJ		オブジェクト状態エラー
				・dtqidで指定したデータキューが登録済み（CRE_DTQの場合）
				　【NGKI1677】
				・その他の条件については機能の項を参照
----

【機能】

各パラメータで指定したデータキュー生成情報に従って，データキューを生成
する．dtqcntとdtqmbからデータキュー管理領域が設定され，格納されているデー
タがない状態に初期化される【NGKI1678】．また，送信待ち行列と受信待ち行
列は，空の状態に初期化される【NGKI1679】．

静的APIにおいては，dtqidはオブジェクト識別名，dtqatrとdtqcntは整数定数
式パラメータ，dtqmbは一般定数式パラメータである【NGKI1680】．コンフィギュ
レータは，静的APIのメモリ不足（E_NOMEM）エラーを検出することができない
【NGKI1681】．

dtqmbをNULLとした場合，dtqcntで指定した数のデータを格納できるデータキュー
管理領域が，コンフィギュレータまたはカーネルにより確保される【NGKI1682】．

〔dtqmbにNULL以外を指定した場合〕

dtqmbにNULL以外を指定した場合，dtqmbを先頭番地とするデータキュー管理領
域は，アプリケーションで確保しておく必要がある【NGKI1683】．データキュー
管理領域をアプリケーションで確保するために，次のマクロを用意している
【NGKI1684】．

	TSZ_DTQMB(dtqcnt)	dtqcntで指定した数のデータを格納できるデータ
						キュー管理領域のサイズ（バイト数）
	TCNT_DTQMB(dtqcnt)	dtqcntで指定した数のデータを格納できるデータ
						キュー管理領域を確保するために必要なMB_T型の配
						列の要素数

これらを用いてデータキュー管理領域を確保する方法は次の通り【NGKI1685】．

MB_T	<データキュー管理領域の変数名>[TCNT_DTQMB(dtqcnt)];

この時，dtqmbには<データキュー管理領域の変数名>を指定する【NGKI1686】．

この方法に従わず，dtqmbにターゲット定義の制約に合致しない先頭番地を指定
した時には，E_PARエラーとなる【NGKI1687】．また，保護機能対応カーネルに
おいて，dtqmbで指定したデータキュー管理領域がカーネル専用のメモリオブジェ
クトに含まれない場合，E_OBJエラーとなる【NGKI1688】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，CRE_DTQのみをサポートする【ASPS0130】．また，dtqmbには
NULLのみを指定することができる．NULL以外を指定した場合には，E_NOSPTエラー
となる【ASPS0132】．ただし，動的生成機能拡張パッケージでは，acre_dtqも
サポートする【ASPS0133】．acre_dtqに対しては，dtqmbにNULL以外を指定でき
ないという制限はない【ASPS0134】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，CRE_DTQのみをサポートする【FMPS0119】．また，dtqmbには
NULLのみを指定することができる．NULL以外を指定した場合には，E_NOSPTエラー
となる【FMPS0121】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，CRE_DTQのみをサポートする【HRPS0119】．また，dtqmbに
はNULLのみを指定することができる．NULL以外を指定した場合には，E_NOSPTエ
ラーとなる【HRPS0121】．ただし，動的生成機能拡張パッケージでは，
acre_dtqもサポートする【HRPS0186】．acre_dtqに対しては，dtqmbにNULL以外
を指定できないという制限はない【HRPS0187】．

【μITRON4.0仕様との関係】

μITRON4.0/PX仕様にあわせて，データキュー生成情報の最後のパラメータを，
dtq（データキュー領域の先頭番地）から，dtqmb（データキュー管理領域の先
頭番地）に改名した．また，TSZ_DTQをTSZ_DTQMBに改名した．

TCNT_DTQMBを新設し，データキュー管理領域をアプリケーションで確保する方
法を規定した．


[[API_AID_DTQ]]
----
AID_DTQ		割付け可能なデータキューIDの数の指定〔SD〕【NGKI1689】
----

【静的API】
----
	AID_DTQ(uint_t nodtq)
----

【パラメータ】
----
	uint_t		nodtq		割付け可能なデータキューIDの数
----

【エラーコード】
----
	E_RSATR		予約属性
				・保護ドメインの囲みの中に記述されている〔P〕【NGKI3431】
				・クラスの囲みの中に記述されていない〔M〕【NGKI1690】
	E_PAR		パラメータエラー
				・nodtqが負の値【NGKI3279】
----

【機能】

nodtqで指定した数のデータキューIDを，データキューを生成するサービスコー
ルによって割付け可能なデータキューIDとして確保する【NGKI1691】．

nodtqは整数定数式パラメータである【NGKI1692】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルの動的生成機能拡張パッケージでは，AID_DTQをサポートする
【ASPS0213】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルの動的生成機能拡張パッケージでは，AID_DTQをサポートする
【HRPS0214】．

[[API_SAC_DTQ]]
----
SAC_DTQ		データキューのアクセス許可ベクタの設定〔SP〕【NGKI1693】
sac_dtq		データキューのアクセス許可ベクタの設定〔TPD〕【NGKI1694】
----

【静的API】
----
	SAC_DTQ(ID dtqid, { ACPTN acptn1, ACPTN acptn2,
										ACPTN acptn3, ACPTN acptn4 })
----

【C言語API】
----
	ER ercd = sac_dtq(ID dtqid, const ACVCT *p_acvct)
----

【パラメータ】
----
	ID			dtqid		対象データキューのID番号
	ACVCT *		p_acvct		アクセス許可ベクタを入れたパケットへのポ
							インタ（静的APIを除く）

　＊アクセス許可ベクタ（パケットの内容）
	ACPTN		acptn1		通常操作1のアクセス許可パターン
	ACPTN		acptn2		通常操作2のアクセス許可パターン
	ACPTN		acptn3		管理操作のアクセス許可パターン
	ACPTN		acptn4		参照操作のアクセス許可パターン
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI1695】
				・CPUロック状態からの呼出し〔s〕【NGKI1696】
	E_ID		不正ID番号
				・dtqidが有効範囲外〔s〕【NGKI1697】
	E_RSATR		予約属性
				・対象データキューが属する保護ドメインの囲みの中（対象
				　データキューが無所属の場合は，保護ドメインの囲みの外）
				　に記述されていない〔S〕【NGKI1698】
				・対象データキューが属するクラスの囲みの中に記述されて
				　いない〔SM〕【NGKI1699】
	E_NOEXS		オブジェクト未登録
				・対象データキューが未登録【NGKI1700】
	E_OACV		オブジェクトアクセス違反
				・対象データキューに対する管理操作が許可されていない〔s〕
				　【NGKI1701】
	E_MACV		メモリアクセス違反
				・p_acvctが指すメモリ領域への読出しアクセスが許可されて
				　いない〔s〕【NGKI1702】
	E_OBJ		オブジェクト状態エラー
				・対象データキューは静的APIで生成された〔s〕【NGKI1703】
				・対象データキューに対してアクセス許可ベクタが設定済み〔S〕
				　【NGKI1704】
----

【機能】

dtqidで指定したデータキュー（対象データキュー）のアクセス許可ベクタ（4
つのアクセス許可パターンの組）を，各パラメータで指定した値に設定する
【NGKI1705】．

静的APIにおいては，dtqidはオブジェクト識別名，acptn1〜acptn4は整数定数
式パラメータである【NGKI1706】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，SAC_DTQのみをサポートする【HRPS0122】．ただし，動的生
成機能拡張パッケージでは，sac_dtqもサポートする【HRPS0188】．


[[API_del_dtq]]
----
del_dtq		データキューの削除〔TD〕【NGKI1707】
----

【C言語API】
----
	ER ercd = del_dtq(ID dtqid)
----

【パラメータ】
----
	ID			dtqid		対象データキューのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1708】
				・CPUロック状態からの呼出し【NGKI1709】
	E_ID		不正ID番号
				・dtqidが有効範囲外【NGKI1710】
	E_NOEXS		オブジェクト未登録
				・対象データキューが未登録【NGKI1711】
	E_OACV		オブジェクトアクセス違反
				・対象データキューに対する管理操作が許可されていない〔P〕
				　【NGKI1712】
	E_OBJ		オブジェクト状態エラー
				・対象データキューは静的APIで生成された【NGKI1713】
----

【機能】

dtqidで指定したデータキュー（対象データキュー）を削除する．具体的な振舞
いは以下の通り．

対象データキューの登録が解除され，そのデータキューIDが未使用の状態に戻
される【NGKI1714】．また，対象データキューの送信待ち行列と受信待ち行列
につながれたタスクは，それぞれの待ち行列の先頭のタスクから順に待ち解除
される【NGKI1715】．待ち解除されたタスクには，待ち状態となったサービス
コールからE_DLTエラーが返る【NGKI1716】．

データキューの生成時に，データキュー管理領域がカーネルによって確保され
た場合は，そのメモリ領域が解放される【NGKI1717】．

【補足説明】

送信待ち行列と受信待ち行列の両方にタスクがつながれていることはないため，
別の待ち行列で待っていたタスクの間の待ち解除の順序は，規定する必要がな
い．

【使用上の注意】

del_dtqにより複数のタスクが待ち解除される場合，サービスコールの処理時間
およびカーネル内での割込み禁止時間が，待ち解除されるタスクの数に比例し
て長くなる．特に，多くのタスクが待ち解除される場合，カーネル内での割込
み禁止時間が長くなるため，注意が必要である．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，del_dtqをサポートしない【ASPS0136】．ただし，動的生成
機能拡張パッケージでは，del_dtqをサポートする【ASPS0137】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，del_dtqをサポートしない【FMPS0123】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，del_dtqをサポートしない【HRPS0123】．ただし，動的生成
機能拡張パッケージでは，del_dtqをサポートする【HRPS0189】．

[[API_snd_dtq]]
----
snd_dtq		データキューへの送信〔T〕【NGKI1718】
psnd_dtq	データキューへの送信（ポーリング）〔T〕【NGKI1719】
ipsnd_dtq	データキューへの送信（ポーリング）〔I〕【NGKI1720】
tsnd_dtq	データキューへの送信（タイムアウト付き）〔T〕【NGKI1721】
----

【C言語API】
----
	ER ercd = snd_dtq(ID dtqid, intptr_t data)
	ER ercd = psnd_dtq(ID dtqid, intptr_t data)
	ER ercd = ipsnd_dtq(ID dtqid, intptr_t data)
	ER ercd = tsnd_dtq(ID dtqid, intptr_t data, TMO tmout)
----

【パラメータ】
----
	ID			dtqid		対象データキューのID番号
	intptr_t	data		送信データ
	TMO			tmout		タイムアウト時間（tsnd_dtqの場合）
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（ipsnd_dtqを除く）
				　【NGKI1722】
				・タスクコンテキストからの呼出し（ipsnd_dtqの場合）
				　【NGKI1723】
				・CPUロック状態からの呼出し【NGKI1724】
				・ディスパッチ保留状態からの呼出し（snd_dtqとtsnd_dtqの
				　場合）【NGKI1725】
	E_NOSPT		未サポート機能
				・制約タスクからの呼出し（snd_dtqとtsnd_dtqの場合）【NGKI1726】
	E_ID		不正ID番号
				・dtqidが有効範囲外【NGKI1727】
	E_PAR		パラメータエラー
				・tmoutが無効（tsnd_dtqの場合）【NGKI1728】
	E_NOEXS		オブジェクト未登録
				・対象データキューが未登録〔D〕【NGKI1729】
	E_OACV		オブジェクトアクセス違反
				・対象データキューに対する通常操作1が許可されていない
				　（ipsnd_dtqを除く）〔P〕【NGKI1730】
	E_TMOUT		ポーリング失敗またはタイムアウト（snd_dtqを除く）【NGKI1731】
	E_RLWAI		待ち禁止状態または待ち状態の強制解除（snd_dtqとtsnd_dtq
				の場合）【NGKI1732】
	E_DLT		待ちオブジェクトの削除または再初期化（snd_dtqとtsnd_dtq
				の場合）【NGKI1733】
----

【機能】

dtqidで指定したデータキュー（対象データキュー）に，dataで指定したデータ
を送信する．具体的な振舞いは以下の通り．

対象データキューの受信待ち行列にタスクが存在する場合には，受信待ち行列
の先頭のタスクが，dataで指定したデータを受信し，待ち解除される
【NGKI1734】．待ち解除されたタスクには，待ち状態となったサービスコール
からE_OKが返る【NGKI1735】．

対象データキューの受信待ち行列にタスクが存在せず，データキュー管理領域
にデータを格納するスペースがある場合には，dataで指定したデータが，FIFO
順でデータキュー管理領域に格納される【NGKI1736】．

対象データキューの受信待ち行列にタスクが存在せず，データキュー管理領域
にデータを格納するスペースがない場合には，自タスクはデータキューへの送
信待ち状態となり，対象データキューの送信待ち行列につながれる
【NGKI1737】．


[[API_fsnd_dtq]]
----
fsnd_dtq	データキューへの強制送信〔T〕【NGKI1738】
ifsnd_dtq	データキューへの強制送信〔I〕【NGKI1739】
----

【C言語API】
----
	ER ercd = fsnd_dtq(ID dtqid, intptr_t data)
	ER ercd = ifsnd_dtq(ID dtqid, intptr_t data)
----

【パラメータ】
----
	ID			dtqid		対象データキューのID番号
	intptr_t	data		送信データ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（fsnd_dtqの場合）【NGKI1740】
				・タスクコンテキストからの呼出し（ifsnd_dtqの場合）【NGKI1741】
				・CPUロック状態からの呼出し【NGKI1742】
	E_ID		不正ID番号
				・dtqidが有効範囲外【NGKI1743】
	E_NOEXS		オブジェクト未登録
				・対象データキューが未登録〔D〕【NGKI1744】
	E_OACV		オブジェクトアクセス違反
				・対象データキューに対する通常操作1が許可されていない
				　（fsnd_dtqの場合）〔P〕【NGKI1745】
	E_ILUSE		サービスコール不正使用
				・対象データキューのデータキュー管理領域のサイズが0【NGKI1746】
----

【機能】

dtqidで指定したデータキュー（対象データキュー）に，dataで指定したデータ
を強制送信する．具体的な振舞いは以下の通り．

対象データキューの受信待ち行列にタスクが存在する場合には，受信待ち行列
の先頭のタスクが，dataで指定したデータを受信し，待ち解除される
【NGKI1747】．待ち解除されたタスクには，待ち状態となったサービスコール
からE_OKが返る【NGKI1748】．

対象データキューの受信待ち行列にタスクが存在せず，データキュー管理領域
にデータを格納するスペースがある場合には，dataで指定したデータが，FIFO
順でデータキュー管理領域に格納される【NGKI1749】．

対象データキューの受信待ち行列にタスクが存在せず，データキュー管理領域
にデータを格納するスペースがない場合には，データキュー管理領域の先頭に
格納されたデータを削除し，空いたスペースを用いて，dataで指定したデータ
が，FIFO順でデータキュー管理領域に格納される【NGKI1750】．

[[API_rcv_dtq]]
----
rcv_dtq		データキューからの受信〔T〕【NGKI1751】
prcv_dtq	データキューからの受信（ポーリング）〔T〕【NGKI1752】
trcv_dtq	データキューからの受信（タイムアウト付き）〔T〕【NGKI1753】
----

【C言語API】
----
	ER ercd = rcv_dtq(ID dtqid, intptr_t *p_data)
	ER ercd = prcv_dtq(ID dtqid, intptr_t *p_data)
	ER ercd = trcv_dtq(ID dtqid, intptr_t *p_data, TMO tmout)
----

【パラメータ】
----
	ID			dtqid		対象データキューのID番号
	intptr_t *	p_data		受信データを入れるメモリ領域へのポインタ
	TMO			tmout		タイムアウト時間（trcv_dtqの場合）
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
	intptr_t	data		受信データ
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1754】
				・CPUロック状態からの呼出し【NGKI1755】
				・ディスパッチ保留状態からの呼出し（prcv_dtqを除く）
				　【NGKI1756】
	E_NOSPT		未サポート機能
				・制約タスクからの呼出し（prcv_dtqを除く）【NGKI1757】
	E_ID		不正ID番号
				・dtqidが有効範囲外【NGKI1758】
	E_PAR		パラメータエラー
				・tmoutが無効（trcv_dtqの場合）【NGKI1759】
	E_NOEXS		オブジェクト未登録
				・対象データキューが未登録〔D〕【NGKI1760】
	E_OACV		オブジェクトアクセス違反
				・対象データキューに対する通常操作2が許可されていない〔P〕
				　【NGKI1761】
	E_MACV		メモリアクセス違反
				・p_dataが指すメモリ領域への書込みアクセスが許可されて
				　いない〔P〕【NGKI1762】
	E_TMOUT		ポーリング失敗またはタイムアウト（rcv_dtqを除く）【NGKI1763】
	E_RLWAI		待ち禁止状態または待ち状態の強制解除（prcv_dtqを除く）
				【NGKI1764】
	E_DLT		待ちオブジェクトの削除または再初期化（prcv_dtqを除く）
				【NGKI1765】
----

【機能】

dtqidで指定したデータキュー（対象データキュー）からデータを受信する．デー
タの受信に成功した場合，受信したデータはp_dataが指すメモリ領域に返され
る【NGKI3421】．具体的な振舞いは以下の通り．

対象データキューのデータキュー管理領域にデータが格納されている場合には，
データキュー管理領域の先頭に格納されたデータを受信する【NGKI1766】．ま
た，送信待ち行列にタスクが存在する場合には，送信待ち行列の先頭のタスク
の送信データが，FIFO順でデータキュー管理領域に格納され，そのタスクは待
ち解除される【NGKI1767】．待ち解除されたタスクには，待ち状態となったサー
ビスコールからE_OKが返る【NGKI1768】．

対象データキューのデータキュー管理領域にデータが格納されておらず，送信
待ち行列にタスクが存在する場合には，送信待ち行列の先頭のタスクの送信デー
タを受信する【NGKI1769】．送信待ち行列の先頭のタスクは，待ち解除される
【NGKI3422】．待ち解除されたタスクには，待ち状態となったサービスコール
からE_OKが返る【NGKI1770】．

対象データキューのデータキュー管理領域にデータが格納されておらず，送信
待ち行列にタスクが存在しない場合には，自タスクはデータキューからの受信
待ち状態となり，対象データキューの受信待ち行列につながれる【NGKI1771】．


[[API_ini_dtq]]
----
ini_dtq		データキューの再初期化〔T〕【NGKI1772】
----

【C言語API】
----
	ER ercd = ini_dtq(ID dtqid)
----

【パラメータ】
----
	ID			dtqid		対象データキューのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1773】
				・CPUロック状態からの呼出し【NGKI1774】
	E_ID		不正ID番号
				・dtqidが有効範囲外【NGKI1775】
	E_NOEXS		オブジェクト未登録
				・対象データキューが未登録〔D〕【NGKI1776】
	E_OACV		オブジェクトアクセス違反
				・対象データキューに対する管理操作が許可されていない〔P〕
				　【NGKI1777】
----

【機能】

dtqidで指定したデータキュー（対象データキュー）を再初期化する．具体的な
振舞いは以下の通り．

対象データキューのデータキュー管理領域は，格納されているデータがない状
態に初期化される【NGKI1778】．また，対象データキューの送信待ち行列と受
信待ち行列につながれたタスクは，それぞれの待ち行列の先頭のタスクから順
に待ち解除される【NGKI1779】．待ち解除されたタスクには，待ち状態となっ
たサービスコールからE_DLTエラーが返る【NGKI1780】．

【補足説明】

送信待ち行列と受信待ち行列の両方にタスクがつながれていることはないため，
別の待ち行列で待っていたタスクの間の待ち解除の順序は，規定する必要がな
い．

【使用上の注意】

ini_dtqにより複数のタスクが待ち解除される場合，サービスコールの処理時間
およびカーネル内での割込み禁止時間が，待ち解除されるタスクの数に比例し
て長くなる．特に，多くのタスクが待ち解除される場合，カーネル内での割込
み禁止時間が長くなるため，注意が必要である．

データキューを再初期化した場合に，アプリケーションとの整合性を保つのは，
アプリケーションの責任である．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていないサービスコールである．


[[API_ref_dtq]]
----
ref_dtq		データキューの状態参照〔T〕【NGKI1781】
----

【C言語API】
----
	ER ercd = ref_dtq(ID dtqid, T_RDTQ *pk_rdtq)
----

【パラメータ】
----
	ID			dtqid		対象データキューのID番号
	T_RDTQ *	pk_rdtq		データキューの現在状態を入れるパケットへの
							ポインタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード

　＊データキューの現在状態（パケットの内容）
	ID			stskid		データキューの送信待ち行列の先頭のタスクの
							ID番号
	ID			rtskid		データキューの受信待ち行列の先頭のタスクの
							ID番号
	uint_t		sdtqcnt		データキュー管理領域に格納されているデータ
							の数
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1782】
				・CPUロック状態からの呼出し【NGKI1783】
	E_ID		不正ID番号
				・dtqidが有効範囲外【NGKI1784】
	E_NOEXS		オブジェクト未登録
				・対象データキューが未登録〔D〕【NGKI1785】
	E_OACV		オブジェクトアクセス違反
				・対象データキューに対する参照操作が許可されていない〔P〕
				　【NGKI1786】
	E_MACV		メモリアクセス違反
				・pk_rdtqが指すメモリ領域への書込みアクセスが許可されて
				　いない〔P〕【NGKI1787】
----

【機能】

dtqidで指定したデータキュー（対象データキュー）の現在状態を参照する．参
照した現在状態は，pk_rdtqで指定したパケットに返される【NGKI1788】．

対象データキューの送信待ち行列にタスクが存在しない場合，stskidには
TSK_NONE（＝0）が返る【NGKI1789】．また，受信待ち行列にタスクが存在しな
い場合，rtskidにはTSK_NONE（＝0）が返る【NGKI1790】．

【使用上の注意】

ref_dtqはデバッグ時向けの機能であり，その他の目的に使用することは推奨し
ない．これは，ref_dtqを呼び出し，対象データキューの現在状態を参照した直
後に割込みが発生した場合，ref_dtqから戻ってきた時には対象データキューの
状態が変化している可能性があるためである．


==== 優先度データキュー

優先度データキューは，1ワードのデータをメッセージとして，データの優先度
順で送受信するための同期・通信カーネルオブジェクトである．より大きいサ
イズのメッセージを送受信したい場合には，メッセージを置いたメモリ領域へ
のポインタを1ワードのデータとして送受信する方法がある．優先度データキュー
は，優先度データキューIDと呼ぶID番号によって識別する【NGKI1791】．

各優先度データキューが持つ情報は次の通り【NGKI1792】．

* 優先度データキュー属性
* 優先度データキュー管理領域
* 送信待ち行列（優先度データキューへの送信待ち状態のタスクのキュー）
* 受信待ち行列（優先度データキューからの受信待ち状態のタスクのキュー）
* 送信できるデータ優先度の最大値
* アクセス許可ベクタ（保護機能対応カーネルの場合）
* 属する保護ドメイン（保護機能対応カーネルの場合）
* 属するクラス（マルチプロセッサ対応カーネルの場合）

優先度データキュー管理領域は，優先度データキューに送信されたデータを，
データの優先度順に格納しておくためのメモリ領域である．優先度データキュー
生成時に，優先度データキュー管理領域に格納できるデータ数を0とすることで，
優先度データキュー管理領域のサイズを0とすることができる【NGKI1793】．

保護機能対応カーネルにおいて，優先度データキュー管理領域は，カーネルの
用いるオブジェクト管理領域として扱われる【NGKI1794】．

送信待ち行列は，優先度データキューに対してデータが送信できるまで待って
いる状態（優先度データキューへの送信待ち状態）のタスクが，データを送信
できる順序でつながれているキューである．また，受信待ち行列は，優先度デー
タキューからデータが受信できるまで待っている状態（優先度データキューか
らの受信待ち状態）のタスクが，データを受信できる順序でつながれている
キューである．

優先度データキュー属性には，次の属性を指定することができる【NGKI1795】．

	TA_TPRI		0x01U	送信待ち行列をタスクの優先度順にする

TA_TPRIを指定しない場合，送信待ち行列はFIFO順になる【NGKI1796】．受信待
ち行列は，FIFO順に固定されている【NGKI1797】．

優先度データキュー機能に関連するカーネル構成マクロは次の通り．

	TMIN_DPRI		データ優先度の最小値（＝1）	【NGKI1798】
	TMAX_DPRI		データ優先度の最大値

	TNUM_PDQID		登録できる優先度データキューの数（動的生成対応でな
					いカーネルでは，静的APIによって登録された優先度デー
					タキューの数に一致）【NGKI1799】

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，データ優先度の最大値（TMAX_DPRI）は16に固定されている
【ASPS0138】．ただし，タスク優先度拡張パッケージでは，TMAX_DPRIを256に
拡張する【ASPS0139】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，データ優先度の最大値（TMAX_DPRI）は16に固定されている
【FMPS0124】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，データ優先度の最大値（TMAX_DPRI）は16に固定されている
【HRPS0124】．

【使用上の注意】

データの優先度が使われるのは，データが優先度データキュー管理領域に格納
される場合のみであり，データを送信するタスクが送信待ち行列につながれて
いる間には使われない．そのため，送信待ち行列につながれているタスクが，
優先度データキュー管理領域に格納されているデータよりも高い優先度のデー
タを送信しようとしている場合でも，最初に送信されるのは，優先度データ
キュー管理領域に格納されているデータである．また，TA_TPRI属性の優先度デー
タキューにおいても，送信待ち行列はタスクの優先度順となり，タスクが送信
しようとしているデータの優先度順となるわけではない．

【μITRON4.0仕様との関係】

μITRON4.0仕様に規定されていない機能である．

[[API_CRE_PDQ]]
----
CRE_PDQ		優先度データキューの生成〔S〕【NGKI1800】
acre_pdq	優先度データキューの生成〔TD〕【NGKI1801】
----

【静的API】
----
	CRE_PDQ(ID pdqid, { ATR pdqatr, uint_t pdqcnt, PRI maxdpri, void *pdqmb })
----

【C言語API】
----
	ER_ID pdqid = acre_pdq(const T_CPDQ *pk_cpdq)
----

【パラメータ】
----
	ID			pdqid		生成する優先度データキューのID番号（CRE_PDQ
							の場合）
	T_CPDQ *	pk_cpdq		優先度データキューの生成情報を入れたパケッ
							トへのポインタ（静的APIを除く）

　＊優先度データキューの生成情報（パケットの内容）
	ATR			pdqatr		優先度データキュー属性
	uint_t		pdqcnt		優先度データキュー管理領域に格納できるデー
							タ数
	PRI			maxdpri		優先度データキューに送信できるデータ優先度
							の最大値
	void *		pdqmb		優先度データキュー管理領域の先頭番地
----

【リターンパラメータ】
----
	ER_ID		pdqid		生成された優先度データキューのID番号（正の
							値）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI1802】
				・CPUロック状態からの呼出し〔s〕【NGKI1803】
	E_RSATR		予約属性
				・pdqatrが無効【NGKI1804】
				・属する保護ドメインの指定が有効範囲外〔sP〕【NGKI1805】
				・属するクラスの指定が有効範囲外〔sM〕【NGKI1806】
				・クラスの囲みの中に記述されていない〔SM〕【NGKI1807】
	E_NOSPT		未サポート機能
				・条件については各カーネルにおける規定の項を参照
	E_PAR		パラメータエラー
				・pdqcntが負の値〔S〕【NGKI3289】
				・maxdpriがTMIN_DPRIより小さい，またはTMAX_DPRIより大き
				　い【NGKI1819】
				・その他の条件については機能の項を参照
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する管理操作が許可されていない〔sP〕
				　【NGKI1808】
	E_MACV		メモリアクセス違反
				・pk_cpdqが指すメモリ領域への読出しアクセスが許可されて
				　いない〔sP〕【NGKI1809】
	E_NOID		ID番号不足
				・割り付けられる優先度データキューIDがない〔sD〕【NGKI1810】
	E_NOMEM		メモリ不足
				・優先度データキュー管理領域が確保できない【NGKI1811】
	E_OBJ		オブジェクト状態エラー
				・pdqidで指定した優先度データキューが登録済み（CRE_PDQ
				　の場合）【NGKI1812】
				・その他の条件については機能の項を参照
----

【機能】

各パラメータで指定した優先度データキュー生成情報に従って，優先度データ
キューを生成する．pdqcntとpdqmbから優先度データキュー管理領域が設定され，
格納されているデータがない状態に初期化される【NGKI1813】．また，送信待
ち行列と受信待ち行列は，空の状態に初期化される【NGKI1814】．

静的APIにおいては，pdqidはオブジェクト識別名，pdqatr，pdqcnt，maxdpriは
整数定数式パラメータ，pdqmbは一般定数式パラメータである【NGKI1815】．コ
ンフィギュレータは，静的APIのメモリ不足（E_NOMEM）エラーを検出すること
ができない【NGKI1816】．

pdqmbをNULLとした場合，pdqcntで指定した数のデータを格納できる優先度デー
タキュー管理領域が，コンフィギュレータまたはカーネルにより確保される
【NGKI1817】．

〔pdqmbにNULL以外を指定した場合〕

pdqmbにNULL以外を指定した場合，pdqmbを先頭番地とする優先度データキュー
管理領域は，アプリケーションで確保しておく必要がある【NGKI1820】．優先
度データキュー管理領域をアプリケーションで確保するために，次のマクロを
用意している【NGKI1821】．

	TSZ_PDQMB(pdqcnt)	pdqcntで指定した数のデータを格納できる優先度デー
						タキュー管理領域のサイズ（バイト数）
	TCNT_PDQMB(pdqcnt)	pdqcntで指定した数のデータを格納できる優先度デー
						タキュー管理領域を確保するために必要なMB_T型の
						配列の要素数

これらを用いて優先度データキュー管理領域を確保する方法は次の通り
【NGKI1822】．

MB_T	<優先度データキュー管理領域の変数名>[TCNT_PDQMB(pdqcnt)];

この時，pdqmbには<優先度データキュー管理領域の変数名>を指定する
【NGKI1823】．

この方法に従わず，pdqmbにターゲット定義の制約に合致しない先頭番地を指定
した時には，E_PARエラーとなる【NGKI1824】．また，保護機能対応カーネルに
いて，pdqmbで指定した優先度データキュー管理領域がカーネル専用のメモリ
オブジェクトに含まれない場合，E_OBJエラーとなる【NGKI1825】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，CRE_PDQのみをサポートする【ASPS0140】．また，pdqmbには
NULLのみを指定することができる．NULL以外を指定した場合には，E_NOSPTエラー
となる【ASPS0142】．ただし，動的生成機能拡張パッケージでは，acre_pdqも
サポートする【ASPS0143】．acre_pdqに対しては，pdqmbにNULL以外を指定でき
ないという制限はない【ASPS0144】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，CRE_PDQのみをサポートする【FMPS0125】．また，pdqmbには
NULLのみを指定することができる．NULL以外を指定した場合には，E_NOSPTエラー
となる【FMPS0127】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，CRE_PDQのみをサポートする【HRPS0125】．また，pdqmbに
はNULLのみを指定することができる．NULL以外を指定した場合には，E_NOSPTエ
ラーとなる【HRPS0127】．ただし，動的生成機能拡張パッケージでは，
acre_pdqもサポートする【HRPS0190】．acre_pdqに対しては，pdqmbにNULL以外
を指定できないという制限はない【HRPS0191】．


[[API_AID_PDQ]]
----
AID_PDQ		割付け可能な優先度データキューIDの数の指定〔SD〕【NGKI1826】
----

【静的API】
----
	AID_PDQ(uint_t nopdq)
----

【パラメータ】
----
	uint_t		nopdq		割付け可能な優先度データキューIDの数
----

【エラーコード】
----
	E_RSATR		予約属性
				・保護ドメインの囲みの中に記述されている〔P〕【NGKI3432】
				・クラスの囲みの中に記述されていない〔M〕【NGKI1827】
	E_PAR		パラメータエラー
				・nopdqが負の値【NGKI3280】
----

【機能】

nopdqで指定した数の優先度データキューIDを，優先度データキューを生成する
サービスコールによって割付け可能な優先度データキューIDとして確保する
【NGKI1828】．

nopdqは整数定数式パラメータである【NGKI1829】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルの動的生成機能拡張パッケージでは，AID_PDQをサポートする
【ASPS0214】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルの動的生成機能拡張パッケージでは，AID_PDQをサポートする
【HRPS0215】．

[[API_SAC_PDQ]]
----
SAC_PDQ		優先度データキューのアクセス許可ベクタの設定〔SP〕【NGKI1830】
sac_pdq		優先度データキューのアクセス許可ベクタの設定〔TPD〕【NGKI1831】
----

【静的API】
----
	SAC_PDQ(ID pdqid, { ACPTN acptn1, ACPTN acptn2,
										ACPTN acptn3, ACPTN acptn4 })
----

【C言語API】
----
	ER ercd = sac_pdq(ID pdqid, const ACVCT *p_acvct)
----

【パラメータ】
----
	ID			pdqid		対象優先度データキューのID番号
	ACVCT *		p_acvct		アクセス許可ベクタを入れたパケットへのポ
							インタ（静的APIを除く）

　＊アクセス許可ベクタ（パケットの内容）
	ACPTN		acptn1		通常操作1のアクセス許可パターン
	ACPTN		acptn2		通常操作2のアクセス許可パターン
	ACPTN		acptn3		管理操作のアクセス許可パターン
	ACPTN		acptn4		参照操作のアクセス許可パターン
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI1832】
				・CPUロック状態からの呼出し〔s〕【NGKI1833】
	E_ID		不正ID番号
				・pdqidが有効範囲外〔s〕【NGKI1834】
	E_RSATR		予約属性
				・対象優先度データキューが属する保護ドメインの囲みの中
				　（対象優先度データキューが無所属の場合は，保護ドメイ
				　ンの囲みの外）に記述されていない〔S〕【NGKI1835】
				・対象優先度データキューが属するクラスの囲みの中に記述
				　されていない〔SM〕【NGKI1836】
	E_NOEXS		オブジェクト未登録
				・対象優先度データキューが未登録【NGKI1837】
	E_OACV		オブジェクトアクセス違反
				・対象優先度データキューに対する管理操作が許可されてい
				　ない〔s〕【NGKI1838】
	E_MACV		メモリアクセス違反
				・p_acvctが指すメモリ領域への読出しアクセスが許可されて
				　いない〔s〕【NGKI1839】
	E_OBJ		オブジェクト状態エラー
				・対象優先度データキューは静的APIで生成された〔s〕【NGKI1840】
				・対象優先度データキューに対してアクセス許可ベクタが設
				　定済み〔S〕【NGKI1841】
----

【機能】

pdqidで指定した優先度データキュー（対象優先度データキュー）のアクセス許
可ベクタ（4つのアクセス許可パターンの組）を，各パラメータで指定した値に
設定する【NGKI1842】．

静的APIにおいては，pdqidはオブジェクト識別名，acptn1〜acptn4は整数定数
式パラメータである【NGKI1843】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，SAC_PDQのみをサポートする【HRPS0128】．ただし，動的生
成機能拡張パッケージでは，sac_pdqもサポートする【HRPS0192】．


[[API_del_pdq]]
----
del_pdq		優先度データキューの削除〔TD〕【NGKI1844】
----

【C言語API】
----
	ER ercd = del_pdq(ID pdqid)
----

【パラメータ】
----
	ID			pdqid		対象優先度データキューのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1845】
				・CPUロック状態からの呼出し【NGKI1846】
	E_ID		不正ID番号
				・pdqidが有効範囲外【NGKI1847】
	E_NOEXS		オブジェクト未登録
				・対象優先度データキューが未登録【NGKI1848】
	E_OACV		オブジェクトアクセス違反
				・対象優先度データキューに対する管理操作が許可されてい
				　ない〔P〕【NGKI1849】
	E_OBJ		オブジェクト状態エラー
				・対象優先度データキューは静的APIで生成された【NGKI1850】
----

【機能】

pdqidで指定した優先度データキュー（対象優先度データキュー）を削除する．
具体的な振舞いは以下の通り．

対象優先度データキューの登録が解除され，その優先度データキューIDが未使
用の状態に戻される【NGKI1851】．また，対象優先度データキューの送信待ち
行列と受信待ち行列につながれたタスクは，それぞれの待ち行列の先頭のタス
クから順に待ち解除される【NGKI1852】．待ち解除されたタスクには，待ち状
態となったサービスコールからE_DLTエラーが返る【NGKI1853】．

優先度データキューの生成時に，優先度データキュー管理領域がカーネルによっ
て確保された場合は，そのメモリ領域が解放される【NGKI1854】．

【補足説明】

送信待ち行列と受信待ち行列の両方にタスクがつながれていることはないため，
別の待ち行列で待っていたタスクの間の待ち解除の順序は，規定する必要がな
い．

【使用上の注意】

del_pdqにより複数のタスクが待ち解除される場合，サービスコールの処理時間
およびカーネル内での割込み禁止時間が，待ち解除されるタスクの数に比例し
て長くなる．特に，多くのタスクが待ち解除される場合，カーネル内での割込
み禁止時間が長くなるため，注意が必要である．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，del_pdqをサポートしない【ASPS0146】．ただし，動的生成
機能拡張パッケージでは，del_pdqをサポートする【ASPS0147】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，del_pdqをサポートしない【FMPS0129】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，del_pdqをサポートしない【HRPS0129】．ただし，動的生成
機能拡張パッケージでは，del_pdqをサポートする【HRPS0193】．


[[API_snd_pdq]]
----
snd_pdq		優先度データキューへの送信〔T〕【NGKI1855】
psnd_pdq	優先度データキューへの送信（ポーリング）〔T〕【NGKI1856】
ipsnd_pdq	優先度データキューへの送信（ポーリング）〔I〕【NGKI1857】
tsnd_pdq	優先度データキューへの送信（タイムアウト付き）〔T〕【NGKI1858】
----

【C言語API】
----
	ER ercd = snd_pdq(ID pdqid, intptr_t data, PRI datapri)
	ER ercd = psnd_pdq(ID pdqid, intptr_t data, PRI datapri)
	ER ercd = ipsnd_pdq(ID pdqid, intptr_t data, PRI datapri)
	ER ercd = tsnd_pdq(ID pdqid, intptr_t data, PRI datapri, TMO tmout)
----

【パラメータ】
----
	ID			pdqid		対象優先度データキューのID番号
	intptr_t	data		送信データ
	PRI			datapri		送信データの優先度
	TMO			tmout		タイムアウト時間（tsnd_pdqの場合）
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（ipsnd_pdqを除く）
				　【NGKI1859】
				・タスクコンテキストからの呼出し（ipsnd_pdqの場合）【NGKI1860】
				・CPUロック状態からの呼出し【NGKI1861】
				・ディスパッチ保留状態からの呼出し（snd_pdqとtsnd_pdqの
				　場合）【NGKI1862】
	E_NOSPT		未サポート機能
				・制約タスクからの呼出し（snd_pdqとtsnd_pdqの場合）【NGKI1863】
	E_ID		不正ID番号
				・pdqidが有効範囲外【NGKI1864】
	E_PAR		パラメータエラー
				・tmoutが無効（tsnd_pdqの場合）【NGKI1865】
				・その他の条件については機能の項を参照
	E_NOEXS		オブジェクト未登録
				・対象優先度データキューが未登録〔D〕【NGKI1866】
	E_OACV		オブジェクトアクセス違反
				・対象優先度データキューに対する通常操作1が許可されてい
				　ない（ipsnd_pdqを除く）〔P〕【NGKI1867】
	E_TMOUT		ポーリング失敗またはタイムアウト（snd_pdqを除く）【NGKI1868】
	E_RLWAI		待ち禁止状態または待ち状態の強制解除（snd_pdqとtsnd_pdq
				の場合）【NGKI1869】
	E_DLT		待ちオブジェクトの削除または再初期化（snd_pdqとtsnd_pdq
				の場合）【NGKI1870】
----

【機能】

pdqidで指定した優先度データキュー（対象優先度データキュー）に，dataで指
定したデータを，datapriで指定した優先度で送信する．具体的な振舞いは以下
の通り．

対象優先度データキューの受信待ち行列にタスクが存在する場合には，受信待
ち行列の先頭のタスクが，dataで指定したデータを受信し，待ち解除される
【NGKI1871】．待ち解除されたタスクには，待ち状態となったサービスコール
からE_OKが返る【NGKI1872】．

対象優先度データキューの受信待ち行列にタスクが存在せず，優先度データ
キュー管理領域にデータを格納するスペースがある場合には，dataで指定した
データが，datapriで指定したデータの優先度順で優先度データキュー管理領域
に格納される【NGKI1873】．

対象優先度データキューの受信待ち行列にタスクが存在せず，優先度データ
キュー管理領域にデータを格納するスペースがない場合には，自タスクは優先
度データキューへの送信待ち状態となり，対象優先度データキューの送信待ち
行列につながれる【NGKI1874】．

datapriは，TMIN_DPRI以上で，対象データキューに送信できるデータ優先度の
最大値以下でなければならない．そうでない場合には，E_PARエラーとなる
【NGKI1876】．


[[API_rcv_pdq]]
----
rcv_pdq		優先度データキューからの受信〔T〕【NGKI1877】
prcv_pdq	優先度データキューからの受信（ポーリング）〔T〕【NGKI1878】
trcv_pdq	優先度データキューからの受信（タイムアウト付き）〔T〕【NGKI1879】
----

【C言語API】
----
	ER ercd = rcv_pdq(ID pdqid, intptr_t *p_data, PRI *p_datapri)
	ER ercd = prcv_pdq(ID pdqid, intptr_t *p_data, PRI *p_datapri)
	ER ercd = trcv_pdq(ID pdqid, intptr_t *p_data, PRI *p_datapri, TMO tmout)
----

【パラメータ】
----
	ID			pdqid		対象優先度データキューのID番号
	intptr_t *	p_data		受信データを入れるメモリ領域へのポインタ
	PRI *		p_datapri	受信データの優先度を入れるメモリ領域へのポ
							インタ
	TMO			tmout		タイムアウト時間（trcv_pdqの場合）
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
	intptr_t	data		受信データ
	PRI			datapri		受信データの優先度
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1880】
				・CPUロック状態からの呼出し【NGKI1881】
				・ディスパッチ保留状態からの呼出し（prcv_pdqを除く）【NGKI1882】
	E_NOSPT		未サポート機能
				・制約タスクからの呼出し（prcv_pdqを除く）【NGKI1883】
	E_ID		不正ID番号
				・pdqidが有効範囲外【NGKI1884】
	E_PAR		パラメータエラー
				・tmoutが無効（trcv_pdqの場合）【NGKI1885】
	E_NOEXS		オブジェクト未登録
				・対象優先度データキューが未登録〔D〕【NGKI1886】
	E_OACV		オブジェクトアクセス違反
				・対象優先度データキューに対する通常操作2が許可されてい
				　ない〔P〕【NGKI1887】
	E_MACV		メモリアクセス違反
				・p_dataが指すメモリ領域への書込みアクセスが許可されて
				　いない〔P〕【NGKI1888】
				・p_datapriが指すメモリ領域への書込みアクセスが許可され
				　ていない〔P〕【NGKI1889】
	E_TMOUT		ポーリング失敗またはタイムアウト（rcv_pdqを除く）【NGKI1890】
	E_RLWAI		待ち禁止状態または待ち状態の強制解除（prcv_pdqを除く）
				【NGKI1891】
	E_DLT		待ちオブジェクトの削除または再初期化（prcv_pdqを除く）
				【NGKI1892】
----

【機能】

pdqidで指定した優先度データキュー（対象優先度データキュー）からデータを
受信する．データの受信に成功した場合，受信したデータはp_dataが指すメモ
リ領域に，その優先度はp_datapriが指すメモリ領域に返される【NGKI1894】．
具体的な振舞いは以下の通り．

対象優先度データキューの優先度データキュー管理領域にデータが格納されて
いる場合には，優先度データキュー管理領域の先頭に格納されたデータを受信
する【NGKI1893】．また，送信待ち行列にタスクが存在する場合には，送信待
ち行列の先頭のタスクの送信データが，データの優先度順で優先度データキュー
管理領域に格納され，そのタスクは待ち解除される【NGKI1895】．待ち解除さ
れたタスクには，待ち状態となったサービスコールからE_OKが返る
【NGKI1896】．

対象優先度データキューの優先度データキュー管理領域にデータが格納されて
おらず，送信待ち行列にタスクが存在する場合には，送信待ち行列の先頭のタ
スクの送信データを受信する【NGKI1897】．送信待ち行列の先頭のタスクは，
待ち解除される【NGKI1899】．待ち解除されたタスクには，待ち状態となった
サービスコールからE_OKが返る【NGKI1900】．

対象優先度データキューの優先度データキュー管理領域にデータが格納されて
おらず，送信待ち行列にタスクが存在しない場合には，自タスクは優先度デー
タキューからの受信待ち状態となり，対象優先度データキューの受信待ち行列
につながれる【NGKI1901】．


[[API_ini_pdq]]
----
ini_pdq		優先度データキューの再初期化〔T〕【NGKI1902】
----

【C言語API】
----
	ER ercd = ini_pdq(ID pdqid)
----

【パラメータ】
----
	ID			pdqid		対象優先度データキューのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1903】
				・CPUロック状態からの呼出し【NGKI1904】
	E_ID		不正ID番号
				・pdqidが有効範囲外【NGKI1905】
	E_NOEXS		オブジェクト未登録
				・対象優先度データキューが未登録〔D〕【NGKI1906】
	E_OACV		オブジェクトアクセス違反
				・対象優先度データキューに対する管理操作が許可されてい
				　ない〔P〕【NGKI1907】
----

【機能】

pdqidで指定した優先度データキュー（対象優先度データキュー）を再初期化す
る．具体的な振舞いは以下の通り．

対象優先度データキューの優先度データキュー管理領域は，格納されているデー
タがない状態に初期化される【NGKI1908】．また，対象優先度データキューの
送信待ち行列と受信待ち行列につながれたタスクは，それぞれの待ち行列の先
頭のタスクから順に待ち解除される【NGKI1909】．待ち解除されたタスクには，
待ち状態となったサービスコールからE_DLTエラーが返る【NGKI1910】．

【補足説明】

送信待ち行列と受信待ち行列の両方にタスクがつながれていることはないため，
別の待ち行列で待っていたタスクの間の待ち解除の順序は，規定する必要がな
い．

【使用上の注意】

ini_pdqにより複数のタスクが待ち解除される場合，サービスコールの処理時間
およびカーネル内での割込み禁止時間が，待ち解除されるタスクの数に比例し
て長くなる．特に，多くのタスクが待ち解除される場合，カーネル内での割込
み禁止時間が長くなるため，注意が必要である．

優先度データキューを再初期化した場合に，アプリケーションとの整合性を保
つのは，アプリケーションの責任である．


[[API_ref_pdq]]
----
ref_pdq		優先度データキューの状態参照〔T〕【NGKI1911】
----

【C言語API】
----
	ER ercd = ref_pdq(ID pdqid, T_RPDQ *pk_rpdq)
----

【パラメータ】
----
	ID			pdqid		対象優先度データキューのID番号
	T_RPDQ *	pk_rpdq		優先度データキューの現在状態を入れるパケッ
							トへのポインタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード

　＊優先度データキューの現在状態（パケットの内容）
	ID			stskid		優先度データキューの送信待ち行列の先頭のタ
							スクのID番号
	ID			rtskid		優先度データキューの受信待ち行列の先頭のタ
							スクのID番号
	uint_t		spdqcnt		優先度データキュー管理領域に格納されている
							データの数
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1912】
				・CPUロック状態からの呼出し【NGKI1913】
	E_ID		不正ID番号
				・pdqidが有効範囲外【NGKI1914】
	E_NOEXS		オブジェクト未登録
				・対象優先度データキューが未登録〔D〕【NGKI1915】
	E_OACV		オブジェクトアクセス違反
				・対象優先度データキューに対する参照操作が許可されてい
				　ない〔P〕【NGKI1916】
	E_MACV		メモリアクセス違反
				・pk_rpdqが指すメモリ領域への書込みアクセスが許可されて
				　いない〔P〕【NGKI1917】
----

【機能】

pdqidで指定した優先度データキュー（対象優先度データキュー）の現在状態を
参照する．参照した現在状態は，pk_rpdqで指定したパケットに返される
【NGKI1918】．

対象優先度データキューの送信待ち行列にタスクが存在しない場合，stskidに
はTSK_NONE（＝0）が返る【NGKI1919】．また，受信待ち行列にタスクが存在し
ない場合，rtskidにはTSK_NONE（＝0）が返る【NGKI1920】．

【使用上の注意】

ref_pdqはデバッグ時向けの機能であり，その他の目的に使用することは推奨し
ない．これは，ref_pdqを呼び出し，対象優先度データキューの現在状態を参照
した直後に割込みが発生した場合，ref_pdqから戻ってきた時には対象優先度デー
タキューの状態が変化している可能性があるためである．


==== メールボックス

メールボックスは，共有メモリ上に置いたメッセージを，FIFO順またはメッセー
ジの優先度順で送受信するための同期・通信オブジェクトである．メールボッ
クスは，メールボックスIDと呼ぶID番号によって識別する【NGKI1921】．

各メールボックスが持つ情報は次の通り【NGKI1922】．

* メールボックス属性
* メッセージキュー
* 待ち行列（メールボックスからの受信待ち状態のタスクのキュー）
* 送信できるメッセージ優先度の最大値
* 優先度別のメッセージキューヘッダ領域
* 属するクラス（マルチプロセッサ対応カーネルの場合）

メッセージキューは，メールボックスに送信されたメッセージを，FIFO順また
はメッセージの優先度順につないでおくためのキューである．

待ち行列は，メールボックスからメッセージが受信できるまで待っている状態
（メールボックスからの受信待ち状態）のタスクが，メッセージを受信できる
順序でつながれているキューである．

メールボックス属性には，次の属性を指定することができる【NGKI1923】．

	TA_TPRI		0x01U	待ち行列をタスクの優先度順にする
	TA_MPRI		0x02U	メッセージキューをメッセージの優先度順にする

TA_TPRIを指定しない場合，待ち行列はFIFO順になる【NGKI1924】．TA_MPRIを
指定しない場合，メッセージキューはFIFO順になる【NGKI1925】．

優先度別のメッセージキューヘッダ領域は，TA_MPRI属性のメールボックスに対
して，メッセージキューを優先度別に設ける場合に使用する領域である．

カーネルは，メールボックスに送信されたメッセージをメッセージキューにつ
なぐために，メッセージの先頭のメモリ領域を使用する【NGKI1926】．そのた
めアプリケーションは，メールボックスに送信するメッセージの先頭に，カー
ネルが利用するためのメッセージヘッダを置かなければならない【NGKI1927】．
メッセージヘッダのデータ型として，メールボックス属性にTA_MPRIが指定され
ているか否かにより，以下のいずれかを用いる【NGKI1928】．

	T_MSG			TA_MPRI属性でないメールボックス用のメッセージヘッダ
	T_MSG_PRI		TA_MPRI属性のメールボックス用のメッセージヘッダ

メッセージヘッダの領域は，メッセージがメッセージキューにつながれている
間（すなわち，メールボックスに送信してから受信するまでの間），カーネル
によって使用される【NGKI1929】．そのため，メッセージキューにつながれて
いるメッセージのメッセージヘッダの領域をアプリケーションが書き換えた場
合や，メッセージキューにつながれているメッセージを再度メールボックスに
送信した場合の動作は保証されない【NGKI1930】．

TA_MPRI属性のメールボックスにメッセージを送信する場合，アプリケーション
は，メッセージの優先度を，T_MSG_PRI型のメッセージヘッダ中のmsgpriフィー
ルドに設定する【NGKI1931】．

保護機能対応カーネルでは，メールボックス機能はサポートしない【NGKI1932】．

メールボックス機能に関連するカーネル構成マクロは次の通り．

	TMIN_MPRI		メッセージ優先度の最小値（＝1）	【NGKI1933】
	TMAX_MPRI		メッセージ優先度の最大値

	TNUM_MBXID		登録できるメールボックスの数（動的生成対応でないカー
					ネルでは，静的APIによって登録されたメールボックスの
					数に一致）【NGKI1934】

【補足説明】

TOPPERS新世代カーネルの現時点の実装では，優先度別のメッセージキューヘッ
ダ領域は用いていない．

【使用上の注意】

メールボックス機能は，μITRON4.0仕様との互換性のために残した機能であり，
保護機能対応カーネルではサポートしないため，使用することは推奨しない．
メールボックス機能は，ほとんどの場合に，データキュー機能または優先度デー
タキュー機能を用いて，メッセージを置いたメモリ領域へのポインタを送受信
する方法で置き換えることができる．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，メールボックス機能をサポートする【ASPS0147】．メッセー
ジ優先度の最大値（TMAX_MPRI）は16に固定されている【ASPS0148】．ただし，
タスク優先度拡張パッケージでは，TMAX_MPRIを256に拡張する【ASPS0149】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，メールボックス機能をサポートする【FMPS0130】．メッセー
ジ優先度の最大値（TMAX_MPRI）は16に固定されている【FMPS0131】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，メールボックス機能をサポートしない【HRPS0130】．

【μITRON4.0仕様との関係】

TNUM_MBXIDは，μITRON4.0仕様に規定されていないカーネル構成マクロである．

[[API_CRE_MBX]]
----
CRE_MBX		メールボックスの生成〔Sp〕【NGKI1935】
acre_mbx	メールボックスの生成〔TpD〕【NGKI1936】
----

【静的API】
----
	CRE_MBX(ID mbxid, { ATR mbxatr, PRI maxmpri, void *mprihd })
----

【C言語API】
----
	ER_ID mbxid = acre_mbx(const T_CMBX *pk_cmbx)
----

【パラメータ】
----
	ID			mbxid		生成するメールボックスのID番号（CRE_MBXの場
							合）
	T_CMBX *	pk_cmbx		メールボックスの生成情報を入れたパケットへ
							のポインタ（静的APIを除く）

　＊メールボックスの生成情報（パケットの内容）
	ATR			mbxatr		メールボックス属性
	PRI			maxmpri		優先度メールボックスに送信できるメッセージ
							優先度の最大値
	void *		mprihd		優先度別のメッセージキューヘッダ領域の先頭
							番地
----

【リターンパラメータ】
----
	ER_ID		mbxid		生成されたメールボックスのID番号（正の値）
							またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI1937】
				・CPUロック状態からの呼出し〔s〕【NGKI1938】
	E_RSATR		予約属性
				・mbxatrが無効【NGKI1939】
				・属するクラスの指定が有効範囲外〔sM〕【NGKI1940】
				・クラスの囲みの中に記述されていない〔SM〕【NGKI1941】
	E_NOSPT		未サポート機能
				・条件については各カーネルにおける規定の項を参照
	E_PAR		パラメータエラー
				・maxmpriがTMIN_MPRIより小さい，またはTMAX_MPRIより大き
				　い【NGKI1951】
	E_NOID		ID番号不足
				・割り付けられるメールボックスIDがない〔sD〕【NGKI1942】
	E_NOMEM		メモリ不足
				・優先度別のメッセージキューヘッダ領域が確保できない
				　【NGKI1943】
	E_OBJ		オブジェクト状態エラー
				・mbxidで指定したメールボックスが登録済み（CRE_MBXの場
				　合）【NGKI1944】
----

【機能】

各パラメータで指定したメールボックス生成情報に従って，メールボックスを
生成する．メッセージキューはつながれているメッセージがない状態に初期化
され，mprihdとmaxmpriから優先度別のメッセージキューヘッダ領域が設定され
る【NGKI1945】．また，待ち行列は空の状態に初期化される【NGKI1946】．

静的APIにおいては，mbxidはオブジェクト識別名，mbxatrとmaxmpriは整数定数
式パラメータ，mprihdは一般定数式パラメータである【NGKI1947】．コンフィ
ギュレータは，静的APIのメモリ不足（E_NOMEM）エラーを検出することができ
ない【NGKI1948】．

mprihdをNULLとした場合，maxmpriの指定に合致したサイズの優先度別のメッセー
ジキューヘッダ領域が，コンフィギュレータまたはカーネルにより確保される
【NGKI1949】．

【未決定事項】

mprihdにNULL以外を指定した場合の扱いについては，この仕様では規定してい
ない．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，CRE_MBXのみをサポートする【ASPS0150】．また，優先度別
のメッセージキューヘッダ領域は使用しておらず，mprihdにはNULLのみを指定
することができる．NULL以外を指定した場合には，E_NOSPTエラーとなる
【ASPS0152】．ただし，動的生成機能拡張パッケージでは，acre_mbxもサポー
トする【ASPS0153】．acre_mbxに対しても，mprihdにはNULLのみを指定するこ
とができる【ASPS0154】．優先度別のメッセージキューヘッダ領域を使用しな
いため，E_NOMEMが返ることはない【ASPS0155】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，CRE_MBXのみをサポートする【FMPS0132】．また，優先度別
のメッセージキューヘッダ領域は使用しておらず，mprihdにはNULLのみを指定
することができる．NULL以外を指定した場合には，E_NOSPTエラーとなる
【FMPS0134】．優先度別のメッセージキューヘッダ領域を使用しないため，
E_NOMEMが返ることはない【FMPS0135】．


[[API_AID_MBX]]
----
AID_MBX		割付け可能なメールボックスIDの数の指定〔SpD〕【NGKI1952】
----

【静的API】
----
	AID_MBX(uint_t nombx)
----

【パラメータ】
----
	uint_t		nombx		割付け可能なメールボックスIDの数
----

【エラーコード】
----
	E_RSATR		予約属性
				・クラスの囲みの中に記述されていない〔M〕【NGKI1953】
	E_PAR		パラメータエラー
				・nombxが負の値【NGKI3281】
----

【機能】

nombxで指定した数のメールボックスIDを，メールボックスを生成するサービス
コールによって割付け可能なメールボックスIDとして確保する【NGKI1954】．

nombxは整数定数式パラメータである【NGKI1955】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルの動的生成機能拡張パッケージでは，AID_MBXをサポートする
【ASPS0215】．


[[API_del_mbx]]
----
del_mbx		メールボックスの削除〔TpD〕【NGKI1956】
----

【C言語API】
----
	ER ercd = del_mbx(ID mbxid)
----

【パラメータ】
----
	ID			mbxid		対象メールボックスのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1957】
				・CPUロック状態からの呼出し【NGKI1958】
	E_ID		不正ID番号
				・mbxidが有効範囲外【NGKI1959】
	E_NOEXS		オブジェクト未登録
				・対象メールボックスが未登録【NGKI1960】
	E_OBJ		オブジェクト状態エラー
				・対象メールボックスは静的APIで生成された【NGKI1961】
----

【機能】

mbxidで指定したメールボックス（対象メールボックス）を削除する．具体的な
振舞いは以下の通り．

対象メールボックスの登録が解除され，そのメールボックスIDが未使用の状態
に戻される【NGKI1962】．また，対象メールボックスの待ち行列につながれた
タスクは，待ち行列の先頭のタスクから順に待ち解除される【NGKI1963】．待
ち解除されたタスクには，待ち状態となったサービスコールからE_DLTエラーが
返る【NGKI1964】．

メールボックスの生成時に，優先度別のメッセージキューヘッダ領域がカーネ
ルによって確保された場合は，そのメモリ領域が解放される【NGKI1965】．

【使用上の注意】

del_mbxにより複数のタスクが待ち解除される場合，サービスコールの処理時間
およびカーネル内での割込み禁止時間が，待ち解除されるタスクの数に比例し
て長くなる．特に，多くのタスクが待ち解除される場合，カーネル内での割込
み禁止時間が長くなるため，注意が必要である．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，del_mbxをサポートしない【ASPS0156】．ただし，動的生成
機能拡張パッケージでは，del_mbxをサポートする【ASPS0157】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，del_mbxをサポートしない【FMPS0136】．

[[API_snd_mbx]]
----
snd_mbx		メールボックスへの送信〔Tp〕【NGKI1966】
----

【C言語API】
----
	ER ercd = snd_mbx(ID mbxid, T_MSG *pk_msg)
----

【パラメータ】
----
	ID			mbxid		対象メールボックスのID番号
	T_MSG		*pk_msg		送信メッセージの先頭番地
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1967】
				・CPUロック状態からの呼出し【NGKI1968】
	E_ID		不正ID番号
				・mbxidが有効範囲外【NGKI1969】
	E_PAR		パラメータエラー
				・条件については機能の項を参照
	E_NOEXS		オブジェクト未登録
				・対象メールボックスが未登録〔D〕【NGKI1970】
----

【機能】

mbxidで指定したメールボックス（対象メールボックス）に，pk_msgで指定した
メッセージを送信する．具体的な振舞いは以下の通り．

対象メールボックスの待ち行列にタスクが存在する場合には，待ち行列の先頭
のタスクが，pk_msgで指定したメッセージを受信し，待ち解除される
【NGKI1971】．待ち解除されたタスクには，待ち状態となったサービスコール
からE_OKが返る【NGKI1972】．

対象メールボックスの待ち行列にタスクが存在しない場合には，pk_msgで指定
したメッセージが，メールボックス属性のTA_MPRI指定の有無によって指定され
る順序で，メッセージキューにつながれる【NGKI1973】．

対象メールボックスがTA_MPRI属性である場合には，pk_msgで指定したメッセー
ジの先頭のメッセージヘッダ中のmsgpriフィールドの値が，TMIN_MPRI以上で，
対象メールボックスに送信できるメッセージ優先度の最大値以下でなければな
らない．そうでない場合には，E_PARエラーとなる【NGKI1975】．


[[API_rcv_mbx]]
----
rcv_mbx		メールボックスからの受信〔Tp〕【NGKI1976】
prcv_mbx	メールボックスからの受信（ポーリング）〔Tp〕【NGKI1977】
trcv_mbx	メールボックスからの受信（タイムアウト付き）〔Tp〕【NGKI1978】
----

【C言語API】
----
	ER ercd = rcv_mbx(ID mbxid, T_MSG **ppk_msg)
	ER ercd = prcv_mbx(ID mbxid, T_MSG **ppk_msg)
	ER ercd = trcv_mbx(ID mbxid, T_MSG **ppk_msg, TMO tmout)
----

【パラメータ】
----
	ID			mbxid		対象メールボックスのID番号
	T_MSG **	ppk_msg		受信メッセージの先頭番地を入れるメモリ領域
							へのポインタ
	TMO			tmout		タイムアウト時間（trcv_mbxの場合）
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
	T_MSG *		ppk_msg		受信メッセージの先頭番地
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1979】
				・CPUロック状態からの呼出し【NGKI1980】
				・ディスパッチ保留状態からの呼出し（prcv_mbxを除く）【NGKI1981】
	E_NOSPT		未サポート機能
				・制約タスクからの呼出し（prcv_mbxを除く）【NGKI1982】
	E_ID		不正ID番号
				・mbxidが有効範囲外【NGKI1983】
	E_PAR		パラメータエラー
				・tmoutが無効（trcv_mbxの場合）【NGKI1984】
	E_NOEXS		オブジェクト未登録
				・対象メールボックスが未登録〔D〕【NGKI1985】
	E_TMOUT		ポーリング失敗またはタイムアウト（rcv_mbxを除く）【NGKI1986】
	E_RLWAI		待ち禁止状態または待ち状態の強制解除（prcv_mbxを除く）
				【NGKI1987】
	E_DLT		待ちオブジェクトの削除または再初期化（prcv_mbxを除く）
				【NGKI1988】
----

【機能】

mbxidで指定したメールボックス（対象メールボックス）からメッセージを受信
する．受信したメッセージの先頭番地は，ppk_msgで指定したメモリ領域に返さ
れる．具体的な振舞いは以下の通り．

対象メールボックスのメッセージキューにメッセージがつながれている場合に
は，メッセージキューの先頭につながれたメッセージが取り出され，ppk_msgで
指定したメモリ領域に返される【NGKI1989】．

対象メールボックスのメッセージキューにメッセージがつながれていない場合
には，自タスクはメールボックスからの受信待ち状態となり，対象メールボッ
クスの待ち行列につながれる【NGKI1990】．


[[API_ini_mbx]]
----
ini_mbx		メールボックスの再初期化〔Tp〕【NGKI1991】
----

【C言語API】
----
	ER ercd = ini_mbx(ID mbxid)
----

【パラメータ】
----
	ID			mbxid		対象メールボックスのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI1992】
				・CPUロック状態からの呼出し【NGKI1993】
	E_ID		不正ID番号
				・mbxidが有効範囲外【NGKI1994】
	E_NOEXS		オブジェクト未登録
				・対象メールボックスが未登録〔D〕【NGKI1995】
----

【機能】

mbxidで指定したメールボックス（対象メールボックス）を再初期化する．具体
的な振舞いは以下の通り．

対象メールボックスのメールボックス管理領域は，メッセージキューはつなが
れているメッセージがない状態に初期化される【NGKI1996】．また，対象メー
ルボックスの待ち行列につながれたタスクは，待ち行列の先頭のタスクから順
に待ち解除される【NGKI1997】．待ち解除されたタスクには，待ち状態となっ
たサービスコールからE_DLTエラーが返る【NGKI1998】．

【使用上の注意】

ini_mbxにより複数のタスクが待ち解除される場合，サービスコールの処理時間
およびカーネル内での割込み禁止時間が，待ち解除されるタスクの数に比例し
て長くなる．特に，多くのタスクが待ち解除される場合，カーネル内での割込
み禁止時間が長くなるため，注意が必要である．

メールボックスを再初期化した場合に，アプリケーションとの整合性を保つのは，
アプリケーションの責任である．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていないサービスコールである．


[[API_ref_mbx]]
----
ref_mbx		メールボックスの状態参照〔Tp〕【NGKI1999】
----

【C言語API】
----
	ER ercd = ref_mbx(ID mbxid, T_RMBX *pk_rmbx)
----

【パラメータ】
----
	ID			mbxid		対象メールボックスのID番号
	T_RMBX *	pk_rmbx		メールボックスの現在状態を入れるパケットへ
							のポインタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード

　＊メールボックスの現在状態（パケットの内容）
	ID			wtskid		メールボックスの待ち行列の先頭のタスクのID
							番号
	T_MSG *		pk_msg		メッセージキューの先頭につながれたメッセー
							ジの先頭番地
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2000】
				・CPUロック状態からの呼出し【NGKI2001】
	E_ID		不正ID番号
				・mbxidが有効範囲外【NGKI2002】
	E_NOEXS		オブジェクト未登録
				・対象メールボックスが未登録〔D〕【NGKI2003】
----

【機能】

mbxidで指定したメールボックス（対象メールボックス）の現在状態を参照する．
参照した現在状態は，pk_rmbxで指定したパケットに返される【NGKI2004】．

対象メールボックスの待ち行列にタスクが存在しない場合，wtskidには
TSK_NONE（＝0）が返る【NGKI2005】．また，メッセージキューにメッセージが
つながれていない場合，pk_msgにはNULLが返る【NGKI2006】．

【使用上の注意】

ref_mbxはデバッグ時向けの機能であり，その他の目的に使用することは推奨し
ない．これは，ref_mbxを呼び出し，対象メールボックスの現在状態を参照した
直後に割込みが発生した場合，ref_mbxから戻ってきた時には対象メールボック
スの状態が変化している可能性があるためである．


==== ミューテックス

ミューテックスは，タスク間の排他制御を行うための同期・通信オブジェクト
である．タスクは，排他制御区間に入る時にミューテックスをロックし，排他
制御区間を出る時にロック解除する．ミューテックスは，ミューテックスIDと
呼ぶID番号によって識別する【NGKI2007】．

ミューテックスは，排他制御に伴う優先度逆転の時間を最小限に抑えるための
優先度上限プロトコル（priority ceiling protocol）をサポートする．ミュー
テックス属性により優先度上限ミューテックスであると指定することで，その
ミューテックスの操作時に，優先度上限プロトコルに従った現在優先度の制御
が行われる．

各ミューテックスが持つ情報は次の通り【NGKI2008】．

* ミューテックス属性
* ロック状態（ロックされている状態とロック解除されている状態）
* ミューテックスをロックしているタスク
* 待ち行列（ミューテックスのロック待ち状態のタスクのキュー）
* 上限優先度（優先度上限ミューテックスの場合）
* アクセス許可ベクタ（保護機能対応カーネルの場合）
* 属する保護ドメイン（保護機能対応カーネルの場合）
* 属するクラス（マルチプロセッサ対応カーネルの場合）

待ち行列は，ミューテックスをロックできるまで待っている状態（ミューテッ
クスのロック待ち状態）のタスクが，ミューテックスをロックできる順序でつ
ながれているキューである．

上限優先度は，優先度上限ミューテックスに対してのみ有効で，ミューテック
スの生成時に，そのミューテックスをロックする可能性のあるタスクのベース
優先度の中で最も高い優先度（または，それより高い優先度）に設定する
【NGKI2009】．

ミューテックス属性には，次の属性を指定することができる【NGKI2010】．

	TA_TPRI		0x01U	待ち行列をタスクの優先度順にする
	TA_CEILING	0x03U	優先度上限ミューテックスとする．待ち行列をタス
						クの優先度順にする

TA_TPRI，TA_CEILINGのいずれも指定しない場合，待ち行列はFIFO順になる
【NGKI2011】．

ミューテックス機能に関連して，各タスクが持つ情報は次の通り【NGKI2012】．

* ロックしているミューテックスのリスト

ロックしているミューテックスのリストは，タスクの起動時に空に初期化され
る【NGKI2013】．

タスクの現在優先度は，そのタスクのベース優先度と，そのタスクがロックし
ている優先度上限ミューテックスの優先度上限の中で，最も高い優先度に設定
される【NGKI2014】．

ミューテックス機能によりタスクの現在優先度が変化する場合には，次の処理
が行われる．現在優先度を変化させるサービスコールの前後とも，当該タスク
が実行できる状態である場合には，同じ優先度のタスクの中で最高優先順位と
なる【NGKI2015】．そのサービスコールにより，当該タスクが実行できる状態
に遷移する場合には，同じ優先度のタスクの中で最低優先順位となる
【NGKI2016】．そのサービスコールの後で，当該タスクが待ち状態で，タスク
の優先度順の待ち行列につながれている場合には，当該タスクの変更後の現在
優先度に従って，その待ち行列中での順序が変更される【NGKI2017】．待ち行
列中に同じ現在優先度のタスクがある場合には，当該タスクの順序はそれらの
中で最後になる【NGKI2018】．

ミューテックス機能に関連して，タスクの終了時に行うべき処理として，タス
クがロックしているミューテックスのロック解除がある．タスクの終了時にロッ
クしているミューテックスが残っている場合，それらのミューテックスは，ロッ
クしたのと逆の順序でロック解除される【NGKI2019】．

ミューテックス機能に関連するカーネル構成マクロは次の通り．

	TNUM_MTXID		登録できるミューテックスの数（動的生成対応でないカー
					ネルでは，静的APIによって登録されたミューテックスの
					数に一致）【NGKI2020】

【使用上の注意】

優先度上限プロトコルには，(a) 優先度の低いタスクの排他制御区間に最大1回
しかブロックされない，(b) タスクの実行が開始された以降は優先度の低いタ
スクにブロックされないという利点があるが，これは，タスク間の同期に優先
度上限ミューテックスのみを用い，他の方法でタスクのスケジューリングに関
与しない場合に得られる利点である．

これらの利点を得るためには，タスクの優先順位の回転やディスパッチの禁止
を行ってはならないことに加えて，優先度上限ミューテックスをロックしたタ
スクを待ち状態にしてはならない．特に，優先度上限ミューテックスに対して，
タスクがロック待ち状態になる状況に注意が必要である（優先度上限プロトコ
ルでは，タスクがミューテックスのロック待ち状態になることはない）．

例えば，着目するタスクAと，タスクAよりベース優先度の低いタスクBとタスク
C，タスクAよりも高い上限優先度を持った優先度上限ミューテックスがある場
合を考える．タスクAがミューテックスをロックし，タスクBとタスクCがミュー
テックスを待っている状況で，タスクAがミューテックスをロック解除すると，
タスクBがミューテックスをロックして優先度が上がり，タスクBに切り換わる．
さらにタスクBがミューテックスをロック解除すると，タスクCがミューテック
スをロックして優先度が上がり，タスクCに切り換わる．タスクAが実行される
のは，タスクCがミューテックスをロック解除した後である．この例では，タス
クAが実行開始後に，タスクBとタスクCの排他制御区間にブロックされることに
なる．

優先度上限ミューテックスに対してタスクがロック待ち状態になる状況を回避
するためには，優先度上限ミューテックスをロックする場合に，待ち状態にな
らないploc_mtxを用いるのが安全である．

【補足説明】

この仕様で優先度上限プロトコルと呼んでいる方式は，オリジナルのpriority
ceiling protocolとは異なるものである．この仕様の方式は，OSEK/VDX OS仕様
でもpriority ceiling protocolと呼ばれているが，学術論文や他のOSでは，
immediate ceiling priority protocol，priority protection protocol，
priority ceiling emulation，highest locker protocolなどと呼ばれている．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，ミューテックス機能をサポートしない【ASPS0158】．ただし，
ミューテックス機能拡張パッケージを用いると，ミューテックス機能を追加す
ることができる【ASPS0159】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，ミューテックス機能をサポートしない【FMPS0137】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，ミューテックス機能をサポートする【HRPS0131】．

【未決定事項】

マルチプロセッサにおいては，タスク間の同期に優先度上限ミューテックスの
みを用い，他の方法でタスクのスケジューリングに関与しない場合でも，優先
度上限ミューテックスに対してタスクがロック待ち状態になる．マルチプロセッ
サ対応カーネルにおける優先度上限ミューテックスの扱いについては，今後の
課題である．

【μITRON4.0仕様との関係】

μITRON4.0仕様の厳密な優先度制御規則を採用し，簡略化した優先度制御規則
はサポートしていない．また，μITRON4.0仕様でサポートしている優先度継承
プロトコル（priority inheritance protocol）は，現時点ではサポートしてい
ない．

ミューテックス機能によりタスクの現在優先度が変化する場合の振舞いは，
μITRON4.0仕様では実装依存となっているが，この仕様では規定している．

TNUM_MTXIDは，μITRON4.0仕様に規定されていないカーネル構成マクロであ
る．

[[API_CRE_MTX]]
----
CRE_MTX		ミューテックスの生成〔S〕【NGKI2021】
acre_mtx	ミューテックスの生成〔TD〕【NGKI2022】
----

【静的API】
----
	CRE_MTX(ID mtxid, { ATR mtxatr, PRI ceilpri })
----

【C言語API】
----
	ER_ID mtxid = acre_mtx(const T_CMTX *pk_cmtx)
----

【パラメータ】
----
	ID			mtxid		生成するミューテックスのID番号（CRE_MTXの
							場合）
	T_CMTX *	pk_cmtx		ミューテックスの生成情報を入れたパケット
							へのポインタ（静的APIを除く）

　＊ミューテックスの生成情報（パケットの内容）
	ATR			mtxatr		ミューテックス属性
	PRI			ceilpri		ミューテックスの上限優先度
----

【リターンパラメータ】
----
	ER_ID		mtxid		生成されたミューテックスのID番号（正の値）
							またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI2023】
				・CPUロック状態からの呼出し〔s〕【NGKI2024】
	E_RSATR		予約属性
				・mtxatrが無効【NGKI2025】
				・属する保護ドメインの指定が有効範囲外〔sP〕【NGKI2026】
				・属するクラスの指定が有効範囲外〔sM〕【NGKI2027】
				・クラスの囲みの中に記述されていない〔SM〕【NGKI2028】
	E_PAR		パラメータエラー
				・条件については機能の項を参照
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する管理操作が許可されていない〔sP〕
				　【NGKI2029】
	E_MACV		メモリアクセス違反
				・pk_cmtxが指すメモリ領域への読出しアクセスが許可されて
				　いない〔sP〕【NGKI2030】
	E_NOID		ID番号不足
				・割り付けられるミューテックスIDがない〔sD〕【NGKI2031】
	E_OBJ		オブジェクト状態エラー
				・mtxidで指定したセマフォが登録済み（CRE_MTXの場合）【NGKI2032】
----

【機能】

各パラメータで指定したミューテックス生成情報に従って，ミューテックスを
生成する．生成されたミューテックスのロック状態はロックされていない状態
に，待ち行列は空の状態に初期化される【NGKI2033】．

静的APIにおいては，mtxidはオブジェクト識別名，mtxatrとceilpriは整数定数
式パラメータである【NGKI2034】．優先度上限ミューテックス以外の場合には，
ceilpriの指定を省略することができる【NGKI2035】．

優先度上限ミューテックスを生成する場合，ceilpriは，TMIN_TPRI以上，
TMAX_TPRI以下でなければならない．そうでない場合には，E_PARエラーとなる
【NGKI2037】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルのミューテックス機能拡張パッケージでは，CRE_MTXのみをサポー
トする【ASPS0160】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，CRE_MTXのみをサポートする【HRPS0132】．ただし，動的生
成機能拡張パッケージでは，acre_mtxもサポートする【HRPS0194】．


[[API_AID_MTX]]
----
AID_MTX		割付け可能なミューテックスIDの数の指定〔SD〕【NGKI2038】
----

【静的API】
----
	AID_MTX(uint_t nomtx)
----

【パラメータ】
----
	uint_t		nomtx		割付け可能なミューテックスIDの数
----

【エラーコード】
----
	E_RSATR		予約属性
				・保護ドメインの囲みの中に記述されている〔P〕【NGKI3433】
				・クラスの囲みの中に記述されていない〔M〕【NGKI2039】
	E_PAR		パラメータエラー
				・nomtxが負の値【NGKI3282】
----

【機能】

nomtxで指定した数のミューテックスIDを，ミューテックスを生成するサービス
コールによって割付け可能なミューテックスIDとして確保する【NGKI2040】．

nomtxは整数定数式パラメータである【NGKI2041】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルの動的生成機能拡張パッケージでは，AID_MTXをサポートする
【HRPS0216】．


[[API_SAC_MTX]]
----
SAC_MTX		ミューテックスのアクセス許可ベクタの設定〔SP〕【NGKI2042】
sac_mtx		ミューテックスのアクセス許可ベクタの設定〔TPD〕【NGKI2043】
----

【静的API】
----
	SAC_MTX(ID mtxid, { ACPTN acptn1, ACPTN acptn2,
										ACPTN acptn3, ACPTN acptn4 })
----

【C言語API】
----
	ER ercd = sac_mtx(ID mtxid, const ACVCT *p_acvct)
----

【パラメータ】
----
	ID			mtxid		対象ミューテックスのID番号
	ACVCT *		p_acvct		アクセス許可ベクタを入れたパケットへのポ
							インタ（静的APIを除く）

　＊アクセス許可ベクタ（パケットの内容）
	ACPTN		acptn1		通常操作1のアクセス許可パターン
	ACPTN		acptn2		通常操作2のアクセス許可パターン
	ACPTN		acptn3		管理操作のアクセス許可パターン
	ACPTN		acptn4		参照操作のアクセス許可パターン
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI2044】
				・CPUロック状態からの呼出し〔s〕【NGKI2045】
	E_ID		不正ID番号
				・mtxidが有効範囲外〔s〕【NGKI2046】
	E_RSATR		予約属性
				・対象ミューテックスが属する保護ドメインの囲みの中（対
				　象ミューテックスが無所属の場合は，保護ドメインの囲み
				　の外）に記述されていない〔S〕【NGKI2047】
				・対象ミューテックスが属するクラスの囲みの中に記述され
				　ていない〔SM〕【NGKI2048】
	E_NOEXS		オブジェクト未登録
				・対象ミューテックスが未登録【NGKI2049】
	E_OACV		オブジェクトアクセス違反
				・対象ミューテックスに対する管理操作が許可されていない〔s〕
				　【NGKI2050】
	E_MACV		メモリアクセス違反
				・p_acvctが指すメモリ領域への読出しアクセスが許可されて
				　いない〔s〕【NGKI2051】
	E_OBJ		オブジェクト状態エラー
				・対象ミューテックスは静的APIで生成された〔s〕【NGKI2052】
				・対象ミューテックスに対してアクセス許可ベクタが設定済
				　み〔S〕【NGKI2053】
----

【機能】

mtxidで指定したミューテックス（対象ミューテックス）のアクセス許可ベクタ
（4つのアクセス許可パターンの組）を，各パラメータで指定した値に設定する
【NGKI2054】．

静的APIにおいては，mtxidはオブジェクト識別名，acptn1〜acptn4は整数定数
式パラメータである【NGKI2055】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，SAC_MTXのみをサポートする【HRPS0133】．ただし，動的生
成機能拡張パッケージでは，sac_mtxもサポートする【HRPS0195】．


[[API_del_mtx]]
----
del_mtx		ミューテックスの削除〔TD〕【NGKI2056】
----

【C言語API】
----
	ER ercd = del_mtx(ID mtxid)
----

【パラメータ】
----
	ID			mtxid		対象ミューテックスのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2057】
				・CPUロック状態からの呼出し【NGKI2058】
	E_ID		不正ID番号
				・mtxidが有効範囲外【NGKI2059】
	E_NOEXS		オブジェクト未登録
				・対象ミューテックスが未登録【NGKI2060】
	E_OACV		オブジェクトアクセス違反
				・対象ミューテックスに対する管理操作が許可されていない〔P〕
				　【NGKI2061】
	E_OBJ		オブジェクト状態エラー
				・対象ミューテックスは静的APIで生成された【NGKI2062】
----

【機能】

mtxidで指定したミューテックス（対象ミューテックス）を削除する．具体的な
振舞いは以下の通り．

対象ミューテックスの登録が解除され，そのミューテックスIDが未使用の状態
に戻される【NGKI2063】．対象ミューテックスをロックしているタスクがある
場合には，そのタスクがロックしているミューテックスのリストから対象ミュー
テックスが削除され，必要な場合にはそのタスクの現在優先度が変更される
【NGKI2064】．また，対象ミューテックスの待ち行列につながれたタスクは，
待ち行列の先頭のタスクから順に待ち解除される【NGKI2065】．待ち解除され
たタスクには，待ち状態となったサービスコールからE_DLTエラーが返る
【NGKI2066】．

【使用上の注意】

対象ミューテックスをロックしているタスクには，ミューテックスが削除され
たことが通知されず，そのミューテックスをロック解除する時点でエラーとな
る．これが不都合な場合には，ミューテックスを削除しようとするタスクが
ミューテックスをロックした状態で，ミューテックスを削除すればよい．

del_mtxにより複数のタスクが待ち解除される場合，サービスコールの処理時間
およびカーネル内での割込み禁止時間が，待ち解除されるタスクの数に比例し
て長くなる．特に，多くのタスクが待ち解除される場合，カーネル内での割込
み禁止時間が長くなるため，注意が必要である．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルのミューテックス機能拡張パッケージでは，del_mtxをサポートし
ない【ASPS0162】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，del_mtxをサポートしない【HRPS0134】．ただし，動的生成
機能拡張パッケージでは，del_mtxをサポートする【HRPS0196】．

[[API_loc_mtx]]
----
loc_mtx		ミューテックスのロック〔T〕【NGKI2067】
ploc_mtx	ミューテックスのロック（ポーリング）〔T〕【NGKI2068】
tloc_mtx	ミューテックスのロック（タイムアウト付き）〔T〕【NGKI2069】
----

【C言語API】
----
	ER ercd = loc_mtx(ID mtxid)
	ER ercd = ploc_mtx(ID mtxid)
	ER ercd = tloc_mtx(ID mtxid, TMO tmout)
----

【パラメータ】
----
	ID			mtxid		対象ミューテックスのID番号
	TMO			tmout		タイムアウト時間（tloc_mtxの場合）
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2070】
				・CPUロック状態からの呼出し【NGKI2071】
				・ディスパッチ保留状態からの呼出し（ploc_mtxを除く）【NGKI2072】
	E_NOSPT		未サポート機能
				・制約タスクからの呼出し（ploc_mtxを除く）【NGKI2073】
	E_ID		不正ID番号
				・mtxidが有効範囲外【NGKI2074】
	E_PAR		パラメータエラー
				・tmoutが無効（tloc_mtxの場合）【NGKI2075】
	E_NOEXS		オブジェクト未登録
				・対象ミューテックスが未登録〔D〕【NGKI2076】
	E_OACV		オブジェクトアクセス違反
				・対象ミューテックスに対する通常操作1が許可されていない〔P〕
				　【NGKI2077】
	E_ILUSE		サービスコール不正使用
				・条件については機能の項を参照
	E_OBJ		オブジェクト状態エラー
				・対象ミューテックスが自タスクによってロックされている
				　【NGKI3609】
	E_TMOUT		ポーリング失敗またはタイムアウト（loc_mtxを除く）【NGKI2078】
	E_RLWAI		待ち禁止状態または待ち状態の強制解除（ploc_mtxを除く）
				【NGKI2079】
	E_DLT		待ちオブジェクトの削除または再初期化（ploc_mtxを除く）
				【NGKI2080】
----

【機能】

mtxidで指定したミューテックス（対象ミューテックス）をロックする．具体的
な振舞いは以下の通り．

対象ミューテックスがロックされていない場合には，自タスクによってロック
されている状態になる【NGKI2081】．自タスクがロックしているミューテック
スのリストに対象ミューテックスが追加され，必要な場合には自タスクの現在
優先度が変更される【NGKI2082】．

対象ミューテックスが自タスク以外のタスクによってロックされている場合に
は，自タスクはミューテックスのロック待ち状態となり，対象ミューテックス
の待ち行列につながれる【NGKI2083】．

対象ミューテックスが優先度上限ミューテックスで，その上限優先度より自タ
スクのベース優先度が高い場合には，E_ILUSEエラーとなる【NGKI2085】．

【仕様変更の経緯】

この仕様のRelease 1.6以前では，対象ミューテックスが自タスクによってロッ
クされている場合には，E_ILUSEエラーとなることとしていたが，Release 1.7
以降でE_OBJエラーに変更した．これは，ミューテックスを用いて，リエントラ
ントロックを実現できるようにするためである．


[[API_unl_mtx]]
----
unl_mtx		ミューテックスのロック解除〔T〕【NGKI2086】
----

【C言語API】
----
	ER ercd = unl_mtx(ID mtxid)
----

【パラメータ】
----
	ID			mtxid		対象ミューテックスのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2087】
				・CPUロック状態からの呼出し【NGKI2088】
	E_ID		不正ID番号
				・mtxidが有効範囲外【NGKI2089】
	E_NOEXS		オブジェクト未登録
				・対象ミューテックスが未登録〔D〕【NGKI2090】
	E_OACV		オブジェクトアクセス違反
				・対象ミューテックスに対する通常操作1が許可されていない〔P〕
				　【NGKI3273】
	E_OBJ		オブジェクト状態エラー
				・対象ミューテックスが自タスクによってロックされていな
				　い【NGKI3610】
----

【機能】

mtxidで指定したミューテックス（対象ミューテックス）をロック解除する．具
体的な振舞いは以下の通り．

まず，自タスクがロックしているミューテックスのリストから対象ミューテッ
クスが削除され，必要な場合には自タスクの現在優先度が変更される
【NGKI2091】．

対象ミューテックスの待ち行列にタスクが存在する場合には，待ち行列の先頭
のタスクが待ち解除される【NGKI2092】．対象ミューテックスは，待ち解除さ
れたタスクによってロックされている状態になる【NGKI2093】．待ち解除され
たタスクがロックしているミューテックスのリストに対象ミューテックスが追
加され，必要な場合にはそのタスクの現在優先度が変更される【NGKI2094】．
待ち解除されたタスクには，待ち状態となったサービスコールからE_OKが返る
【NGKI2095】．

待ち行列にタスクが存在しない場合には，対象ミューテックスはロックされて
いない状態になる【NGKI2096】．


[[API_ini_mtx]]
----
ini_mtx		ミューテックスの再初期化〔T〕【NGKI2098】
----

【C言語API】
----
	ER ercd = ini_mtx(ID mtxid)
----

【パラメータ】
----
	ID			mtxid		対象ミューテックスのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2099】
				・CPUロック状態からの呼出し【NGKI2100】
	E_ID		不正ID番号
				・mtxidが有効範囲外【NGKI2101】
	E_NOEXS		オブジェクト未登録
				・対象ミューテックスが未登録〔D〕【NGKI2102】
	E_OACV		オブジェクトアクセス違反
				・対象ミューテックスに対する管理操作が許可されていない〔P〕
				　【NGKI2103】
----

【機能】

mtxidで指定したミューテックス（対象ミューテックス）を再初期化する．具体
的な振舞いは以下の通り．

対象ミューテックスのロック状態は，ロックされていない状態に初期化される
【NGKI2104】．対象ミューテックスをロックしているタスクがある場合には，
そのタスクがロックしているミューテックスのリストから対象ミューテックス
が削除され，必要な場合にはそのタスクの現在優先度が変更される
【NGKI2105】．また，対象ミューテックスの待ち行列につながれたタスクは，
待ち行列の先頭のタスクから順に待ち解除される【NGKI2106】．待ち解除され
たタスクには，待ち状態となったサービスコールからE_DLTエラーが返る
【NGKI2107】．

【使用上の注意】

対象ミューテックスをロックしているタスクには，ミューテックスが再初期化
されたことが通知されず，そのミューテックスをロック解除する時点でエラー
となる．これが不都合な場合には，ミューテックスを再初期化しようとするタ
スクがミューテックスをロックした状態で，ミューテックスを再初期化すれば
よい．

ini_mtxにより複数のタスクが待ち解除される場合，サービスコールの処理時間
およびカーネル内での割込み禁止時間が，待ち解除されるタスクの数に比例し
て長くなる．特に，多くのタスクが待ち解除される場合，カーネル内での割込
み禁止時間が長くなるため，注意が必要である．

ミューテックスを再初期化した場合に，アプリケーションとの整合性を保つの
は，アプリケーションの責任である．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていないサービスコールである．


[[API_rex_mtx]]
----
ref_mtx		ミューテックスの状態参照〔T〕【NGKI2108】
----

【C言語API】
----
	ER ercd = ref_mtx(ID mtxid, T_RMTX *pk_rmtx)
----

【パラメータ】
----
	ID			mtxid		対象ミューテックスのID番号
	T_RMTX *	pk_rmtx		ミューテックスの現在状態を入れるパケットへ
							のポインタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード

　＊ミューテックスの現在状態（パケットの内容）
	ID			htskid		ミューテックスをロックしているタスクのID番号
	ID			wtskid		ミューテックスの待ち行列の先頭のタスクのID
							番号
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2109】
				・CPUロック状態からの呼出し【NGKI2110】
	E_ID		不正ID番号
				・mtxidが有効範囲外【NGKI2111】
	E_NOEXS		オブジェクト未登録
				・対象ミューテックスが未登録〔D〕【NGKI2112】
	E_OACV		オブジェクトアクセス違反
				・対象ミューテックスに対する参照操作が許可されていない〔P〕
				　【NGKI2113】
	E_MACV		メモリアクセス違反
				・pk_rmtxが指すメモリ領域への書込みアクセスが許可されて
				　いない〔P〕【NGKI2114】
----

【機能】

mtxidで指定したミューテックス（対象ミューテックス）の現在状態を参照する．
参照した現在状態は，pk_rmtxで指定したパケットに返される．

対象ミューテックスがロックされていない場合，htskidにはTSK_NONE（＝0）が
返る【NGKI2115】．

対象ミューテックスの待ち行列にタスクが存在しない場合，wtskidには
TSK_NONE（＝0）が返る【NGKI2116】．

【使用上の注意】

ref_mtxはデバッグ時向けの機能であり，その他の目的に使用することは推奨し
ない．これは，ref_mtxを呼び出し，対象ミューテックスの現在状態を参照した
直後に割込みが発生した場合，ref_mtxから戻ってきた時には対象ミューテック
スの状態が変化している可能性があるためである．


==== メッセージバッファ

メッセージバッファは，指定した長さのバイト列をメッセージとして，FIFO順
で送受信するための同期・通信オブジェクトである．メッセージバッファは，
メッセージバッファIDと呼ぶID番号によって識別する【NGKI3291】．

各メッセージバッファが持つ情報は次の通り【NGKI3292】．

* メッセージバッファ属性
* 最大メッセージサイズ
* メッセージバッファ管理領域
* 送信待ち行列（メッセージバッファへの送信待ち状態のタスクのキュー）
* 受信待ち行列（メッセージバッファからの受信待ち状態のタスクのキュー）
* アクセス許可ベクタ（保護機能対応カーネルの場合）
* 属する保護ドメイン（保護機能対応カーネルの場合）
* 属するクラス（マルチプロセッサ対応カーネルの場合）

メッセージバッファ管理領域は，メッセージバッファに送信されたメッセージ
を，送信された順に格納しておくためのメモリ領域である．メッセージバッファ
生成時の指定により，メッセージバッファ管理領域のサイズを0とすることがで
きる【NGKI3293】．

保護機能対応カーネルにおいて，メッセージバッファ管理領域は，カーネルの
用いるオブジェクト管理領域として扱われる【NGKI3294】．

送信待ち行列は，メッセージバッファに対してメッセージが送信できるまで待っ
ている状態（メッセージバッファへの送信待ち状態）のタスクが，メッセージ
を送信できる順序でつながれているキューである．また，受信待ち行列は，メッ
セージバッファからメッセージが受信できるまで待っている状態（メッセージ
バッファからの受信待ち状態）のタスクが，メッセージを受信できる順序でつ
ながれているキューである．

メッセージバッファ属性には，次の属性を指定することができる【NGKI3295】．

	TA_TPRI		0x01U	送信待ち行列をタスクの優先度順にする

TA_TPRIを指定しない場合，送信待ち行列はFIFO順になる【NGKI3296】．受信待
ち行列は，FIFO順に固定されている【NGKI3297】．

メッセージバッファ機能に関連するカーネル構成マクロは次の通り．

	TNUM_MBFID		登録できるメッセージバッファの数（動的生成対応でな
					いカーネルでは，静的APIによって登録されたメッセー
					ジバッファの数に一致）【NGKI3298】

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，メッセージバッファ機能をサポートしない【ASPS0202】．た
だし，メッセージバッファ機能拡張パッケージを用いると，メッセージバッファ
機能を追加することができる【ASPS0203】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，メッセージバッファ機能をサポートしない【FMPS0167】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，メッセージバッファ機能をサポートしない【HRPS0168】．
ただし，メッセージバッファ機能拡張パッケージを用いると，メッセージバッ
ファ機能を追加することができる【HRPS0169】．

【μITRON4.0仕様との関係】

TNUM_MBFIDは，μITRON4.0仕様に規定されていないカーネル構成マクロである．


[[API_CRE_MBF]]
----
CRE_MBF		メッセージバッファの生成〔S〕【NGKI3299】
acre_mbf	メッセージバッファの生成〔TD〕【NGKI3300】
----

【静的API】
----
	CRE_MBF(ID mbfid, { ATR mbfatr, uint_t maxmsz, SIZE mbfsz, void *mbfmb })
----

【C言語API】
----
	ER_ID mbfid = acre_mbf(const T_CMBF *pk_cmbf)
----

【パラメータ】
----
	ID			mbfid		生成するメッセージバッファのID番号（CRE_MBF
							の場合）
	T_CMBF *	pk_cmbf		メッセージバッファの生成情報を入れたパケッ
							トへのポインタ（静的APIを除く）

　＊メッセージバッファの生成情報（パケットの内容）
	ATR			mbfatr		メッセージバッファ属性
	uint_t		maxmsz		メッセージバッファの最大メッセージサイズ（バ
							イト数）
	SIZE		mbfsz		メッセージバッファ管理領域のサイズ（バイト数）
	void *		mbfmb		メッセージバッファ管理領域の先頭番地
----

【リターンパラメータ】
----
	ER_ID		mbfid		生成されたメッセージバッファのID番号（正の
							値）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI3301】
				・CPUロック状態からの呼出し〔s〕【NGKI3302】
	E_RSATR		予約属性
				・mbfatrが無効【NGKI3303】
				・属する保護ドメインの指定が有効範囲外〔sP〕【NGKI3304】
				・属するクラスの指定が有効範囲外〔sM〕【NGKI3305】
				・クラスの囲みの中に記述されていない〔SM〕【NGKI3306】
	E_NOSPT		未サポート機能
				・条件については各カーネルにおける規定の項を参照
	E_PAR		パラメータエラー
				・maxmszが0以下【NGKI3307】
				・mbfszが負の値〔S〕【NGKI3308】
				・その他の条件については機能の項を参照
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する管理操作が許可されていない〔sP〕
				　【NGKI3309】
	E_MACV		メモリアクセス違反
				・pk_cmbfが指すメモリ領域への読出しアクセスが許可されて
				　いない〔sP〕【NGKI3310】
	E_NOID		ID番号不足
				・割り付けられるメッセージバッファIDがない〔sD〕【NGKI3311】
	E_NOMEM		メモリ不足
				・メッセージバッファ管理領域が確保できない【NGKI3312】
	E_OBJ		オブジェクト状態エラー
				・mbfidで指定したメッセージバッファが登録済み（CRE_MBF
				　の場合）【NGKI3313】
				・その他の条件については機能の項を参照
----

【機能】

各パラメータで指定したメッセージバッファ生成情報に従って，メッセージバッ
ファを生成する．mbfszとmbfmbからメッセージバッファ管理領域が設定され，
格納されているメッセージがない状態に初期化される【NGKI3314】．また，送
信待ち行列と受信待ち行列は，空の状態に初期化される【NGKI3315】．

静的APIにおいては，mbfidはオブジェクト識別名，mbfatr，maxmsz，mbfszは整
数定数式パラメータ，mbfmbは一般定数式パラメータである【NGKI3316】．コン
フィギュレータは，静的APIのメモリ不足（E_NOMEM）エラーを検出することが
できない【NGKI3317】．

mbfmbをNULLとした場合，mbfszで指定したサイズのメッセージバッファ管理領
域が，コンフィギュレータまたはカーネルにより確保される【NGKI3318】．
mbfszにターゲット定義の制約に合致しないサイズを指定した時には，ターゲッ
ト定義の制約に合致するように大きい方に丸めたサイズで確保される
【NGKI3319】．

〔mbfmbにNULL以外を指定した場合〕

mbfmbにNULL以外を指定した場合，mbfmbとmbfszで指定したメッセージバッファ
管理領域は，アプリケーションで確保しておく必要がある【NGKI3320】．メッ
セージバッファ管理領域をアプリケーションで確保するために，次のマクロを
用意している【NGKI3321】．

	TSZ_MBFMB(msgcnt, msgsz)	msgszで指定したサイズのメッセージを，
								msgcntで指定した数だけ格納できるメッセー
								ジバッファ管理領域のサイズ（バイト数）
	TCNT_MBFMB(msgcnt, msgsz)	msgszで指定したサイズのメッセージを，
								msgcntで指定した数だけ格納できるメッセー
								ジバッファ管理領域を確保するために必要
								なMB_T型の配列の要素数

これらを用いてメッセージバッファ管理領域を確保する方法は次の通り
【NGKI3322】．

----
MB_T	<メッセージバッファ管理領域の変数名>[TCNT_MBFMB(msgcnt, msgsz)];
----

この時，mbfszにはTSZ_MBFMB(msgcnt, msgsz)を，mbfmbには<メッセージバッファ
管理領域の変数名>を指定する【NGKI3323】．

この方法に従わず，mbfmbとmbfszにターゲット定義の制約に合致しない先頭番
地やサイズを指定した時には，E_PARエラーとなる【NGKI3324】．また，保護機
能対応カーネルにおいて，mbfmbとmbfszで指定したメッセージバッファ管理領
域がカーネル専用のメモリオブジェクトに含まれない場合，E_OBJエラーとなる
【NGKI3325】．

なお，TSZ_MBFMBは，mbfmbにNULLを指定した場合にも，メッセージバッファ管
理領域のサイズを決めるために用いることができる．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルのメッセージバッファ機能拡張パッケージでは，CRE_MBFのみをサ
ポートする【ASPS0204】．また，mbfmbにはNULLのみを指定することができる．
NULL以外を指定した場合には，E_NOSPTエラーとなる【ASPS0205】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルのメッセージバッファ機能拡張パッケージでは，CRE_MBFのみをサ
ポートする【HRPS0170】．また，mbfmbにはNULLのみを指定することができる．
NULL以外を指定した場合には，E_NOSPTエラーとなる【HRPS0171】．

【μITRON4.0仕様との関係】

μITRON4.0/PX仕様にあわせて，メッセージバッファ生成情報の最後のパラメー
タを，mbf（メッセージバッファ領域の先頭番地）から，mbfmb（メッセージバッ
ファ管理領域の先頭番地）に改名した．また，TSZ_MBFをTSZ_MBFMBに改名した．

TCNT_MBFMBを新設し，メッセージバッファ管理領域をアプリケーションで確保
する方法を規定した．


[[API_AID_MBF]]
----
AID_MBF		割付け可能なメッセージバッファIDの数の指定〔SD〕【NGKI3326】
----

【静的API】
----
	AID_MBF(uint_t nombf)
----

【パラメータ】
----
	uint_t		nombf		割付け可能なメッセージバッファIDの数
----

【エラーコード】
----
	E_RSATR		予約属性
				・保護ドメインの囲みの中に記述されている〔P〕【NGKI3434】
				・クラスの囲みの中に記述されていない〔M〕【NGKI3327】
	E_PAR		パラメータエラー
				・nombfが負の値【NGKI3328】
----

【機能】

nombfで指定した数のメッセージバッファIDを，メッセージバッファを生成する
サービスコールによって割付け可能なメッセージバッファIDとして確保する
【NGKI3329】．

nombfは整数定数式パラメータである【NGKI3330】．


[[API_SAC_MBF]]
----
SAC_MBF		メッセージバッファのアクセス許可ベクタの設定〔SP〕【NGKI3331】
sac_mbf		メッセージバッファのアクセス許可ベクタの設定〔TPD〕【NGKI3332】
----

【静的API】
----
	SAC_MBF(ID mbfid, { ACPTN acptn1, ACPTN acptn2,
										ACPTN acptn3, ACPTN acptn4 })
----

【C言語API】
----
	ER ercd = sac_mbf(ID mbfid, const ACVCT *p_acvct)
----

【パラメータ】
----
	ID			mbfid		対象メッセージバッファのID番号
	ACVCT *		p_acvct		アクセス許可ベクタを入れたパケットへのポ
							インタ（静的APIを除く）

　＊アクセス許可ベクタ（パケットの内容）
	ACPTN		acptn1		通常操作1のアクセス許可パターン
	ACPTN		acptn2		通常操作2のアクセス許可パターン
	ACPTN		acptn3		管理操作のアクセス許可パターン
	ACPTN		acptn4		参照操作のアクセス許可パターン
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI3333】
				・CPUロック状態からの呼出し〔s〕【NGKI3334】
	E_ID		不正ID番号
				・mbfidが有効範囲外〔s〕【NGKI3335】
	E_RSATR		予約属性
				・対象メッセージバッファが属する保護ドメインの囲みの中
				　（対象メッセージバッファが無所属の場合は，保護ドメイ
				　ンの囲みの外）に記述されていない〔S〕【NGKI3336】
				・対象メッセージバッファが属するクラスの囲みの中に記述
				　されていない〔SM〕【NGKI3337】
	E_NOEXS		オブジェクト未登録
				・対象メッセージバッファが未登録【NGKI3338】
	E_OACV		オブジェクトアクセス違反
				・対象メッセージバッファに対する管理操作が許可されてい
				　ない〔s〕【NGKI3339】
	E_MACV		メモリアクセス違反
				・p_acvctが指すメモリ領域への読出しアクセスが許可されて
				　いない〔s〕【NGKI3340】
	E_OBJ		オブジェクト状態エラー
				・対象メッセージバッファは静的APIで生成された〔s〕【NGKI3341】
				・対象メッセージバッファに対してアクセス許可ベクタが設
				　定済み〔S〕【NGKI3342】
----

【機能】

mbfidで指定したメッセージバッファ（対象メッセージバッファ）のアクセス許
可ベクタ（4つのアクセス許可パターンの組）を，各パラメータで指定した値に
設定する【NGKI3343】．

静的APIにおいては，mbfidはオブジェクト識別名，acptn1〜acptn4は整数定数
式パラメータである【NGKI3344】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルのメッセージバッファ機能拡張パッケージでは，SAC_MBFのみをサ
ポートする【HRPS0172】．


[[API_del_mbf]]
----
del_mbf		メッセージバッファの削除〔TD〕【NGKI3345】
----

【C言語API】
----
	ER ercd = del_mbf(ID mbfid)
----

【パラメータ】
----
	ID			mbfid		対象メッセージバッファのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI3346】
				・CPUロック状態からの呼出し【NGKI3347】
	E_ID		不正ID番号
				・mbfidが有効範囲外【NGKI3348】
	E_NOEXS		オブジェクト未登録
				・対象メッセージバッファが未登録【NGKI3349】
	E_OACV		オブジェクトアクセス違反
				・対象メッセージバッファに対する管理操作が許可されてい
				　ない〔P〕【NGKI3350】
	E_OBJ		オブジェクト状態エラー
				・対象メッセージバッファは静的APIで生成された【NGKI3351】
----

【機能】

mbfidで指定したメッセージバッファ（対象メッセージバッファ）を削除する．
具体的な振舞いは以下の通り．

対象メッセージバッファの登録が解除され，そのメッセージバッファIDが未使
用の状態に戻される【NGKI3352】．また，対象メッセージバッファの送信待ち
行列と受信待ち行列につながれたタスクは，それぞれの待ち行列の先頭のタス
クから順に待ち解除される【NGKI3353】．待ち解除されたタスクには，待ち状
態となったサービスコールからE_DLTエラーが返る【NGKI3354】．

メッセージバッファの生成時に，メッセージバッファ管理領域がカーネルによっ
て確保された場合は，そのメモリ領域が解放される【NGKI3355】．

【補足説明】

送信待ち行列と受信待ち行列の両方にタスクがつながれていることはないため，
別の待ち行列で待っていたタスクの間の待ち解除の順序は，規定する必要がな
い．

【使用上の注意】

del_mbfにより複数のタスクが待ち解除される場合，サービスコールの処理時間
およびカーネル内での割込み禁止時間が，待ち解除されるタスクの数に比例し
て長くなる．特に，多くのタスクが待ち解除される場合，カーネル内での割込
み禁止時間が長くなるため，注意が必要である．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルのメッセージバッファ機能拡張パッケージでは，del_mbfをサポー
トしない【ASPS0207】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルのメッセージバッファ機能拡張パッケージでは，del_mbfをサポー
トしない【HRPS0173】．


[[API_snd_mbf]]
----
snd_mbf		メッセージバッファへの送信〔T〕【NGKI3356】
psnd_mbf	メッセージバッファへの送信（ポーリング）〔T〕【NGKI3357】
tsnd_mbf	メッセージバッファへの送信（タイムアウト付き）〔T〕【NGKI3358】
----

【C言語API】
----
	ER ercd = snd_mbf(ID mbfid, const void *msg, uint_t msgsz)
	ER ercd = psnd_mbf(ID mbfid, const void *msg, uint_t msgsz)
	ER ercd = tsnd_mbf(ID mbfid, const void *msg, uint_t msgsz, TMO tmout)
----

【パラメータ】
----
	ID			mbfid		対象メッセージバッファのID番号
	void *		msg			送信メッセージの先頭番地
	uint_t		msgsz		送信メッセージのサイズ（バイト数）
	TMO			tmout		タイムアウト時間（tsnd_mbfの場合）
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI3359】
				・CPUロック状態からの呼出し【NGKI3360】
				・ディスパッチ保留状態からの呼出し（psnd_mbfを除く）
				　【NGKI3361】
	E_NOSPT		未サポート機能
				・制約タスクからの呼出し（psnd_mbfを除く）【NGKI3362】
	E_ID		不正ID番号
				・mbfidが有効範囲外【NGKI3363】
	E_PAR		パラメータエラー
				・msgszが有効範囲（0より大きく対象メッセージバッファの
				　最大メッセージサイズ以下）外【NGKI3364】
				・tmoutが無効（tsnd_mbfの場合）【NGKI3365】
	E_NOEXS		オブジェクト未登録
				・対象メッセージバッファが未登録〔D〕【NGKI3366】
	E_OACV		オブジェクトアクセス違反
				・対象メッセージバッファに対する通常操作1が許可されて
				　いない〔P〕【NGKI3367】
	E_MACV		メモリアクセス違反
				・msgとmsgszが指すメモリ領域への読出しアクセスが許可さ
				　れていない〔P〕【NGKI3368】
	E_TMOUT		ポーリング失敗またはタイムアウト（snd_mbfを除く）【NGKI3369】
	E_RLWAI		待ち禁止状態または待ち状態の強制解除（psnd_mbfを除く）
				【NGKI3370】
	E_DLT		待ちオブジェクトの削除または再初期化（psnd_mbfを除く）
				【NGKI3371】
----

【機能】

mbfidで指定したメッセージバッファ（対象メッセージバッファ）に，msgと
msgszで指定したメッセージ（送信メッセージ）を送信する．具体的な振舞いは
以下の通り．

対象メッセージバッファの受信待ち行列にタスクが存在する場合には，受信待
ち行列の先頭のタスクが，送信メッセージを受信し，待ち解除される
【NGKI3372】．待ち解除されたタスクには，待ち状態となったサービスコール
から，受信したメッセージのサイズが返る【NGKI3373】．

対象メッセージバッファの受信待ち行列にタスクが存在しない場合で，送信待
ち行列に自タスクより優先してメッセージを送信できるタスクが存在せず，メッ
セージバッファ管理領域に送信メッセージを格納するスペースがある場合には，
送信メッセージが，FIFO順でメッセージバッファ管理領域に格納される
【NGKI3374】．ここで，送信待ち行列に自タスクより優先してメッセージを送
信できるタスクが存在するとは，送信待ち行列がFIFO順の場合には送信待ち行
列に何らかのタスクが存在すること，タスクの優先度順の場合には自タスクと
優先度が同じかより高いタスクが存在することを意味する．

対象メッセージバッファの受信待ち行列にタスクが存在しない場合で，送信待
ち行列に自タスクより優先してメッセージを送信できるタスクが存在するか，
メッセージバッファ管理領域に送信メッセージを格納するスペースがない場合
には，自タスクはメッセージバッファへの送信待ち状態となり，対象メッセー
ジバッファの送信待ち行列につながれる【NGKI3375】．

メッセージバッファの送信待ち行列の先頭につながれているタスクが，
ter_tskにより強制終了した場合や，rel_wai／irel_waiやタイムアウトにより
待ち解除された場合，新たに送信待ち行列の先頭になったタスクの送信メッセー
ジを，メッセージバッファ管理領域に格納できる可能性がある．そのため，こ
れらの場合には，メッセージバッファからの受信によりメッセージバッファ管
理領域に空きができた時の処理［NGKI3393］［NGKI3394］［NGKI3395］と同じ
処理が行われる【NGKI3419】．さらに，送信待ち行列がタスクの優先度順の時
には，chg_priやミューテックスの操作によりタスクの優先度が変化し，送信待
ち行列の先頭につながれているタスクが変わった場合にも，同じ処理が行われ
る【NGKI3420】．

【使用上の注意】

送信待ち行列の先頭につながれているタスクの強制終了，待ち解除，優先度変
更に伴う処理で，送信待ち行列につながれていたタスクが複数待ち解除される
場合がある．この時，サービスコールの処理時間およびカーネル内での割込み
禁止時間が，待ち解除されるタスクの数に比例して長くなる．特に，多くのタ
スクが待ち解除される場合，カーネル内での割込み禁止時間が長くなるため，
注意が必要である．


[[API_rcv_mbf]]
----
rcv_mbf		メッセージバッファからの受信〔T〕【NGKI3376】
prcv_mbf	メッセージバッファからの受信（ポーリング）〔T〕【NGKI3377】
trcv_mbf	メッセージバッファからの受信（タイムアウト付き）〔T〕【NGKI3378】
----

【C言語API】
----
	ER_UINT	msgsz = rcv_mbf(ID mbfid, void *msg)
	ER_UINT	msgsz = prcv_mbf(ID mbfid, void *msg)
	ER_UINT	msgsz = trcv_mbf(ID mbfid, void *msg, TMO tmout)
----

【パラメータ】
----
	ID			mbfid		対象メッセージバッファのID番号
	void *		msg			受信メッセージを入れるメモリ領域の先頭番地
	TMO			tmout		タイムアウト時間（trcv_mbfの場合）
----

【リターンパラメータ】
----
	ER_UINT		msgsz		受信メッセージサイズ（正の値）またはエラー
							コード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI3379】
				・CPUロック状態からの呼出し【NGKI3380】
				・ディスパッチ保留状態からの呼出し（prcv_mbfを除く）
				　【NGKI3381】
	E_NOSPT		未サポート機能
				・制約タスクからの呼出し（prcv_mbfを除く）【NGKI3382】
	E_ID		不正ID番号
				・mbfidが有効範囲外【NGKI3383】
	E_PAR		パラメータエラー
				・tmoutが無効（trcv_mbfの場合）【NGKI3384】
	E_NOEXS		オブジェクト未登録
				・対象メッセージバッファが未登録〔D〕【NGKI3385】
	E_OACV		オブジェクトアクセス違反
				・対象メッセージバッファに対する通常操作2が許可されてい
				　ない〔P〕【NGKI3386】
	E_MACV		メモリアクセス違反
				・msgを先頭番地とし，対象メッセージバッファの最大メッセー
				　ジサイズ分のメモリ領域への書込みアクセスが許可されて
				　いない〔P〕【NGKI3387】
	E_TMOUT		ポーリング失敗またはタイムアウト（rcv_mbfを除く）【NGKI3388】
	E_RLWAI		待ち禁止状態または待ち状態の強制解除（prcv_mbfを除く）
				【NGKI3389】
	E_DLT		待ちオブジェクトの削除または再初期化（prcv_mbfを除く）
				【NGKI3390】
----

【機能】

mbfidで指定したメッセージバッファ（対象メッセージバッファ）からメッセー
ジを受信する．メッセージの受信に成功した場合，受信したメッセージはmsgを
先頭番地とするメモリ領域に格納され，そのサイズはサービスコールの返値と
して返される【NGKI3391】．具体的な振舞いは以下の通り．

対象メッセージバッファのメッセージバッファ管理領域にメッセージが格納さ
れている場合には，メッセージバッファ管理領域の先頭に格納されたメッセー
ジを受信する【NGKI3392】．また，送信待ち行列にタスクが存在し，メッセー
ジバッファ管理領域に送信待ち行列の先頭のタスクの送信メッセージを格納す
るスペースがある場合には，送信メッセージがFIFO順でデータキュー管理領域
に格納され，そのタスクは待ち解除される【NGKI3393】．待ち解除されたタス
クには，待ち状態となったサービスコールからE_OKが返る【NGKI3394】．この
処理を，送信待ち行列にタスクが存在しなくなるか，メッセージバッファ管理
領域に送信待ち行列の先頭のタスクの送信メッセージを格納するスペースがな
くなるまで繰り返す【NGKI3395】．

対象メッセージバッファのメッセージバッファ管理領域にメッセージが格納さ
れておらず，送信待ち行列にタスクが存在する場合には，送信待ち行列の先頭
のタスクの送信メッセージを受信する【NGKI3396】．送信待ち行列の先頭のタ
スクは，待ち解除される【NGKI3397】．待ち解除されたタスクには，待ち状態
となったサービスコールからE_OKが返る【NGKI3398】．

対象メッセージバッファのメッセージバッファ管理領域にメッセージが格納さ
れておらず，送信待ち行列にタスクが存在しない場合には，自タスクはメッセー
ジバッファからの受信待ち状態となり，対象メッセージバッファの受信待ち行
列につながれる【NGKI3399】．

【使用上の注意】

メッセージバッファ管理領域に格納されたメッセージを受信した結果，送信待
ち行列につながれていたタスクが複数待ち解除される場合がある．この時，サー
ビスコールの処理時間およびカーネル内での割込み禁止時間が，待ち解除され
るタスクの数に比例して長くなる．特に，多くのタスクが待ち解除される場合，
カーネル内での割込み禁止時間が長くなるため，注意が必要である．


[[API_ini_mbf]]
----
ini_mbf		メッセージバッファの再初期化〔T〕【NGKI3400】
----

【C言語API】
----
	ER ercd = ini_mbf(ID mbfid)
----

【パラメータ】
----
	ID			mbfid		対象メッセージバッファのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI3401】
				・CPUロック状態からの呼出し【NGKI3402】
	E_ID		不正ID番号
				・mbfidが有効範囲外【NGKI3403】
	E_NOEXS		オブジェクト未登録
				・対象メッセージバッファが未登録〔D〕【NGKI3404】
	E_OACV		オブジェクトアクセス違反
				・対象メッセージバッファに対する管理操作が許可されてい
				　ない〔P〕【NGKI3405】
----

【機能】

mbfidで指定したメッセージバッファ（対象メッセージバッファ）を再初期化す
る．具体的な振舞いは以下の通り．

対象メッセージバッファのメッセージバッファ管理領域は，格納されているメッ
セージがない状態に初期化される【NGKI3406】．また，対象メッセージバッファ
の送信待ち行列と受信待ち行列につながれたタスクは，それぞれの待ち行列の
先頭のタスクから順に待ち解除される【NGKI3407】．待ち解除されたタスクに
は，待ち状態となったサービスコールからE_DLTエラーが返る【NGKI3408】．

【補足説明】

送信待ち行列と受信待ち行列の両方にタスクがつながれていることはないため，
別の待ち行列で待っていたタスクの間の待ち解除の順序は，規定する必要がな
い．

【使用上の注意】

ini_mbfにより複数のタスクが待ち解除される場合，サービスコールの処理時間
およびカーネル内での割込み禁止時間が，待ち解除されるタスクの数に比例し
て長くなる．特に，多くのタスクが待ち解除される場合，カーネル内での割込
み禁止時間が長くなるため，注意が必要である．

メッセージバッファを再初期化した場合に，アプリケーションとの整合性を保
つのは，アプリケーションの責任である．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていないサービスコールである．


[[API_ref_mbf]]
----
ref_mbf		メッセージバッファの状態参照〔T〕【NGKI3409】
----

【C言語API】
----
	ER ercd = ref_mbf(ID mbfid, T_RMBF *pk_rmbf)
----

【パラメータ】
----
	ID			mbfid		対象メッセージバッファのID番号
	T_RMBF *	pk_rmbf		メッセージバッファの現在状態を入れるパケッ
							トへのポインタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード

　＊メッセージバッファの現在状態（パケットの内容）
	ID			stskid		メッセージバッファの送信待ち行列の先頭のタ
							スクのID番号
	ID			rtskid		メッセージバッファの受信待ち行列の先頭のタ
							スクのID番号
	uint_t		smbfcnt		メッセージバッファ管理領域に格納されている
							メッセージの数
	SIZE		fmbfsz		メッセージバッファ管理領域中の空き領域のサ
							イズ
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI3410】
				・CPUロック状態からの呼出し【NGKI3411】
	E_ID		不正ID番号
				・mbfidが有効範囲外【NGKI3412】
	E_NOEXS		オブジェクト未登録
				・対象メッセージバッファが未登録〔D〕【NGKI3413】
	E_OACV		オブジェクトアクセス違反
				・対象メッセージバッファに対する参照操作が許可されてい
				　ない〔P〕【NGKI3414】
	E_MACV		メモリアクセス違反
				・pk_rmbfが指すメモリ領域への書込みアクセスが許可されて
				　いない〔P〕【NGKI3415】
----

【機能】

mbfidで指定したメッセージバッファ（対象メッセージバッファ）の現在状態を
参照する．参照した現在状態は，pk_rmbfで指定したパケットに返される
【NGKI3416】．

対象メッセージバッファの送信待ち行列にタスクが存在しない場合，stskidには
TSK_NONE（＝0）が返る【NGKI3417】．また，受信待ち行列にタスクが存在しな
い場合，rtskidにはTSK_NONE（＝0）が返る【NGKI3418】．

【使用上の注意】

ref_mbfはデバッグ時向けの機能であり，その他の目的に使用することは推奨し
ない．これは，ref_mbfを呼び出し，対象メッセージバッファの現在状態を参照
した直後に割込みが発生した場合，ref_mbfから戻ってきた時には対象メッセー
ジバッファの状態が変化している可能性があるためである．


==== スピンロック

スピンロックは，マルチプロセッサ対応カーネルにおいて，割込みのマスクと
プロセッサ間ロックの取得により，排他制御を行うための同期・通信オブジェ
クトである．スピンロックは，スピンロックIDと呼ぶID番号によって識別する
【NGKI2117】．

プロセッサ間ロックを取得している間は，CPUロック状態にすることですべての
カーネル管理の割込みがマスクされ，ディスパッチが保留される【NGKI2118】．
ロックが他のプロセッサに取得されている場合には，ロックが取得できるまで
ループによって待つ【NGKI2119】．ロックの取得を待つ間は，CPUロック解除状
態であり，割込みはマスクされない【NGKI2120】．プロセッサ間ロックを取得
し，CPUロック状態に遷移することを，スピンロックを取得するという．また，
プロセッサ間ロックを返却し，CPUロック状態を解除することを，スピンロック
を返却するという．

タスクが取得したスピンロックを返却せずに終了した場合や，タスク例外処理
ルーチン，割込みハンドラ，割込みサービスルーチン，タイムイベントハンド
ラが取得したスピンロックを返却せずにリターンした場合には，カーネルによっ
てスピンロックが返却される【NGKI2121】．また，スピンロックを取得してい
ない状態で発生したCPU例外によって呼び出されたCPU例外ハンドラが，取得し
たスピンロックを返却せずにリターンした場合には，カーネルによってスピン
ロックが返却される【NGKI2122】．一方，拡張サービスコールからのリターン
では，スピンロックは返却されない【NGKI2123】．

各スピンロックが持つ情報は次の通り【NGKI2124】．

* スピンロック属性
* ロック状態（取得されている状態と取得されていない状態）
* アクセス許可ベクタ（保護機能対応カーネルの場合）
* 属する保護ドメイン（保護機能対応カーネルの場合）
* 属するクラス

スピンロック属性に指定できる属性はない【NGKI2125】．そのためスピンロッ
ク属性には，TA_NULLを指定しなければならない【NGKI2126】．

スピンロック機能に関連するカーネル構成マクロは次の通り．

	TNUM_SPNID		登録できるスピンロックの数（動的生成対応でないカー
					ネルでは，静的APIによって登録されたスピンロックの数
					に一致）【NGKI2127】

【補足説明】

CPUロック状態では，スピンロックを取得するサービスコールを呼び出すことが
できないため，スピンロックを取得しているプロセッサが，さらにスピンロッ
クを取得することはできない．そのため，1つの処理単位が，複数のスピンロッ
クを取得した状態になることはできない．

スピンロックを取得した状態でCPU例外が発生した場合，起動されるCPU例外ハ
ンドラはカーネル管理外のCPU例外ハンドラであり（xsns_dpn，xsns_xpnとも
trueを返す），CPU例外ハンドラ中でiunl_spnを呼び出してスピンロックを返却
しようとした場合の動作は保証されない．保証されないにも関わらずiunl_spn
を呼び出した場合には，CPU例外ハンドラからのリターン時に元の状態に戻らな
い．これは，CPUロック状態の扱いと一貫していないため，注意が必要である．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，スピンロック機能をサポートしない【ASPS0163】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，スピンロック機能をサポートする【FMPS0138】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，スピンロック機能をサポートしない【HRPS0135】．

【μITRON4.0仕様との関係】

スピンロック機能は，μITRON4.0仕様に定義されていない機能である．


[[API_CRE_SPN]]
----
CRE_SPN		スピンロックの生成〔SM〕【NGKI2128】
acre_spn	スピンロックの生成〔TMD〕【NGKI2129】
----

【静的API】
----
	CRE_SPN(ID spnid, { ATR spnatr })
----

【C言語API】
----
	ER_ID spnid = acre_spn(const T_CSPN *pk_cspn)
----

【パラメータ】
----
	ID			spnid		生成するスピンロックのID番号（CRE_SPNの場合）
	T_CSPN *	pk_cspn		スピンロックの生成情報を入れたパケットへの
							ポインタ（静的APIを除く）

　＊スピンロックの生成情報（パケットの内容）
	ATR			spnatr		スピンロック属性
----

【リターンパラメータ】
----
	ER_ID		spnid		生成されたスピンロックのID番号（正の値）ま
							たはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI2130】
				・CPUロック状態からの呼出し〔s〕【NGKI2131】
	E_RSATR		予約属性
				・spnatrが無効【NGKI2132】
				・属する保護ドメインの指定が有効範囲外〔sP〕【NGKI2133】
				・属するクラスの指定が有効範囲外〔s〕【NGKI2134】
				・クラスの囲みの中に記述されていない〔S〕【NGKI2135】
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する管理操作が許可されていない〔sP〕
				　【NGKI2136】
	E_MACV		メモリアクセス違反
				・pk_cspnが指すメモリ領域への読出しアクセスが許可されて
				　いない〔sP〕【NGKI2137】
	E_NOID		ID番号不足
				・割り付けられるスピンロックIDがない〔sD〕【NGKI2138】
	E_NORES		資源不足
				・条件については機能の項を参照
	E_OBJ		オブジェクト状態エラー
				・spnidで指定したスピンロックが登録済み（CRE_SPNの場合）
				　【NGKI2139】
----

【機能】

各パラメータで指定したスピンロック生成情報に従って，スピンロックを生成
する．生成されたスピンロックのロック状態は，取得されていない状態に初期
化される【NGKI2140】．

静的APIにおいては，spnidはオブジェクト識別名，spnatrは整数定数式パラメー
タである【NGKI2141】．

スピンロックをハードウェアによって実現している場合には，ターゲット定義
で，生成できるスピンロックの数に上限がある【NGKI2142】．この上限を超え
てスピンロックを生成しようとした場合には，E_NORESエラーとなる
【NGKI2143】．

【補足説明】

スピンロックを動的に生成する場合に，生成できるスピンロックの数の上限は
AID_SPNによってチェックされるため，acre_spnでE_NORESエラーが返ることは
ない．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，CRE_SPNのみをサポートする【FMPS0139】．


[[API_AID_SPN]]
----
AID_SPN		割付け可能なスピンロックIDの数の指定〔SMD〕【NGKI2144】
----

【静的API】
----
	AID_SPN(uint_t nospn)
----

【パラメータ】
----
	uint_t		nospn		割付け可能なスピンロックIDの数
----

【エラーコード】
----
	E_RSATR		予約属性
				・保護ドメインの囲みの中に記述されている〔P〕【NGKI3435】
				・クラスの囲みの中に記述されていない【NGKI2145】
	E_PAR		パラメータエラー
				・nospnが負の値【NGKI3283】
----

【機能】

nospnで指定した数のスピンロックIDを，スピンロックを生成するサービスコー
ルによって割付け可能なスピンロックIDとして確保する【NGKI2146】．

nospnは整数定数式パラメータである【NGKI2147】．


[[API_SAC_SPN]]
----
SAC_SPN		スピンロックのアクセス許可ベクタの設定〔SPM〕【NGKI2148】
sac_spn		スピンロックのアクセス許可ベクタの設定〔TPMD〕【NGKI2149】
----

【静的API】
----
	SAC_SPN(ID spnid, { ACPTN acptn1, ACPTN acptn2,
										ACPTN acptn3, ACPTN acptn4 })
----

【C言語API】
----
	ER ercd = sac_spn(ID spnid, const ACVCT *p_acvct)
----

【パラメータ】
----
	ID			spnid		対象スピンロックのID番号
	ACVCT *		p_acvct		アクセス許可ベクタを入れたパケットへのポ
							インタ（静的APIを除く）

　＊アクセス許可ベクタ（パケットの内容）
	ACPTN		acptn1		通常操作1のアクセス許可パターン
	ACPTN		acptn2		通常操作2のアクセス許可パターン
	ACPTN		acptn3		管理操作のアクセス許可パターン
	ACPTN		acptn4		参照操作のアクセス許可パターン
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI2150】
				・CPUロック状態からの呼出し〔s〕【NGKI2151】
	E_ID		不正ID番号
				・spnidが有効範囲外〔s〕【NGKI2152】
	E_RSATR		予約属性
				・対象スピンロックが属する保護ドメインの囲みの中（対象
				　スピンロックが無所属の場合は，保護ドメインの囲みの外）
				　に記述されていない〔S〕【NGKI2153】
				・対象スピンロックが属するクラスの囲みの中に記述されて
				　いない〔S〕【NGKI2154】
	E_NOEXS		オブジェクト未登録
				・対象スピンロックが未登録【NGKI2155】
	E_OACV		オブジェクトアクセス違反
				・対象スピンロックに対する管理操作が許可されていない〔s〕
				　【NGKI2156】
	E_MACV		メモリアクセス違反
				・p_acvctが指すメモリ領域への読出しアクセスが許可されて
				　いない〔s〕【NGKI2157】
	E_OBJ		オブジェクト状態エラー
				・対象スピンロックは静的APIで生成された〔s〕【NGKI2158】
				・対象スピンロックに対してアクセス許可ベクタが設定済み〔S〕
				　【NGKI2159】
----

【機能】

spnidで指定したスピンロック（対象スピンロック）のアクセス許可ベクタ（4
つのアクセス許可パターンの組）を，各パラメータで指定した値に設定する
【NGKI2160】．

静的APIにおいては，spnidはオブジェクト識別名，acptn1〜acptn4は整数定数
式パラメータである【NGKI2161】．


[[API_del_spn]]
----
del_spn		スピンロックの削除〔TMD〕【NGKI2162】
----

【C言語API】
----
	ER ercd = del_spn(ID spnid)
----

【パラメータ】
----
	ID			spnid		対象スピンロックのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2163】
				・CPUロック状態からの呼出し【NGKI2164】
	E_ID		不正ID番号
				・spnidが有効範囲外【NGKI2165】
	E_NOEXS		オブジェクト未登録
				・対象スピンロックが未登録【NGKI2166】
	E_OACV		オブジェクトアクセス違反
				・対象スピンロックに対する管理操作が許可されていない〔P〕
				　【NGKI2167】
	E_OBJ		オブジェクト状態エラー
				・対象スピンロックは静的APIで生成された【NGKI2168】
----

【機能】

spnidで指定したスピンロック（対象スピンロック）を削除する．具体的な振舞
いは以下の通り．

対象スピンロックの登録が解除され，そのスピンロックIDが未使用の状態に戻
される【NGKI2169】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，del_spnをサポートしない【FMPS0141】．

【未決定事項】

対象スピンロックが取得されている状態の場合の振舞いは，今後の課題である．


[[API_loc_spn]]
----
loc_spn		スピンロックの取得〔TM〕【NGKI2170】
iloc_spn	スピンロックの取得〔IM〕【NGKI2171】
----

【C言語API】
----
	ER ercd = loc_spn(ID spnid)
	ER ercd = iloc_spn(ID spnid)
----

【パラメータ】
----
	ID			spnid		対象スピンロックのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（loc_spnの場合）【NGKI2172】
				・タスクコンテキストからの呼出し（iloc_spnの場合）【NGKI2173】
				・CPUロック状態からの呼出し【NGKI2174】
	E_ID		不正ID番号
				・spnidが有効範囲外【NGKI2175】
	E_NOEXS		オブジェクト未登録
				・対象スピンロックが未登録〔D〕【NGKI2176】
	E_OACV		オブジェクトアクセス違反
				・対象スピンロックに対する通常操作1が許可されていない
				　（loc_spnの場合）〔P〕【NGKI2177】
----

【機能】

spnidで指定したスピンロック（対象スピンロック）を取得する．具体的な振舞
いは以下の通り．

対象スピンロックが取得されていない状態である場合には，プロセッサ間ロッ
クの取得を試みる【NGKI2178】．ロックが他のプロセッサによって取得されて
いる状態である場合や，他のプロセッサがロックの取得に成功した場合には，
ロックが返却されるまでループによって待ち，返却されたらロックの取得を試
みる【NGKI2179】．これを，ロックの取得に成功するまで繰り返す
【NGKI2180】．

ロックの取得に成功した場合には，スピンロックは取得されている状態になる
【NGKI2181】．また，CPUロックフラグをセットしてCPUロック状態へ遷移し，
サービスコールからリターンする【NGKI2182】．

なお，複数のプロセッサがロックの取得を待っている時に，どのプロセッサが
最初にロックを取得できるかは，現時点ではターゲット定義とする【NGKI2183】．

【補足説明】

対象スピンロックが，loc_spn／iloc_spnを呼び出したプロセッサによって取得
されている状態である場合には，スピンロックの取得によりCPUロック状態になっ
ているため，loc_spn／iloc_spnはE_CTXエラーとなる．

プロセッサがロックを取得できる順序を，現時点ではターゲット定義としたが，
リアルタイム性保証のためには，（ロックの取得待ちの間に割込みが発生しな
い限りは）loc_spn／iloc_spnを呼び出した順序でロックを取得できるとするの
が望ましい．ただし，ターゲットハードウェアの制限で，そのような実装がで
きるとは限らないため，現時点ではターゲット定義としている．


[[API_try_spn]]
----
try_spn		スピンロックの取得（ポーリング）〔TM〕【NGKI2184】
itry_spn	スピンロックの取得（ポーリング）〔IM〕【NGKI2185】
----

【C言語API】
----
	ER ercd = try_spn(ID spnid)
	ER ercd = itry_spn(ID spnid)
----

【パラメータ】
----
	ID			spnid		対象スピンロックのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（try_spnの場合）【NGKI2186】
				・タスクコンテキストからの呼出し（itry_spnの場合）【NGKI2187】
				・CPUロック状態からの呼出し【NGKI2188】
	E_ID		不正ID番号
				・spnidが有効範囲外【NGKI2189】
	E_NOEXS		オブジェクト未登録
				・対象スピンロックが未登録〔D〕【NGKI2190】
	E_OACV		オブジェクトアクセス違反
				・対象スピンロックに対する通常操作1が許可されていない
				　（try_spnの場合）〔P〕【NGKI2191】
	E_OBJ		オブジェクト状態エラー
				・条件については機能の項を参照
----

【機能】

spnidで指定したスピンロック（対象スピンロック）の取得を試みる．具体的な
振舞いは以下の通り．

対象スピンロックが取得されていない状態である場合には，プロセッサ間ロッ
クの取得を試みる【NGKI2192】．ロックの取得に成功した場合には，スピンロッ
クは取得されている状態になる【NGKI2193】．また，CPUロックフラグをセット
してCPUロック状態へ遷移し，サービスコールからリターンする【NGKI2194】．

対象スピンロックが他のプロセッサによって取得されている状態である場合や，
ロックの取得に失敗した場合（他のプロセッサがロックの取得に成功した場合）
には，E_OBJエラーとする【NGKI2195】．

【使用上の注意】

try_spn／itry_spnを，ロックの取得に成功するまで繰り返し呼び出すことによ
りスピンロックを取得する方法は，loc_spn／iloc_spnによりスピンロックを取
得する方法と，プロセッサがロックを取得できる順序が異なる可能性ある．


[[API_unl_spn]]
----
unl_spn		スピンロックの返却〔TM〕【NGKI2196】
iunl_spn	スピンロックの返却〔IM〕【NGKI2197】
----

【C言語API】
----
	ER ercd = unl_spn(ID spnid)
	ER ercd = iunl_spn(ID spnid)
----

【パラメータ】
----
	ID			spnid		対象スピンロックのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（unl_spnの場合）【NGKI2198】
				・タスクコンテキストからの呼出し（iunl_spnの場合）【NGKI2199】
	E_ID		不正ID番号
				・spnidが有効範囲外【NGKI2200】
	E_NOEXS		オブジェクト未登録
				・対象スピンロックが未登録〔D〕【NGKI2201】
	E_OACV		オブジェクトアクセス違反
				・対象スピンロックに対する通常操作1が許可されていない
				　（unl_spnの場合）〔P〕【NGKI2202】
	E_ILUSE		サービスコール不正使用
				・条件については機能の項を参照
----

【機能】

spnidで指定したスピンロック（対象スピンロック）を返却する．具体的な振舞
いは以下の通り．

対象スピンロックが，unl_spn／iunl_spnを呼び出したプロセッサによって取得
されている状態である場合には，ロックを返却し，スピンロックを取得されて
いない状態とする【NGKI2203】．また，CPUロックフラグをクリアし，CPUロッ
ク解除状態へ遷移する【NGKI2204】．

対象スピンロックが，取得されていない状態である場合や，他のプロセッサに
よって取得されている状態である場合には，E_ILUSEエラーとなる【NGKI2205】．


[[API_ref_spn]
----
ref_spn		スピンロックの状態参照〔TM〕【NGKI2206】
----

【C言語API】
----
	ER ercd = ref_spn(ID spnid, T_RSPN *pk_rspn)
----

【パラメータ】
----
	ID			spnid		対象スピンロックのID番号
	T_RSPN *	pk_rspn		スピンロックの現在状態を入れるパケットへの
							ポインタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード

　＊スピンロックの現在状態（パケットの内容）
	STAT		spnstat		ロック状態
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2207】
				・CPUロック状態からの呼出し【NGKI2208】
	E_ID		不正ID番号
				・spnidが有効範囲外【NGKI2209】
	E_NOEXS		オブジェクト未登録
				・対象スピンロックが未登録〔D〕【NGKI2210】
	E_OACV		オブジェクトアクセス違反
				・対象スピンロックに対する参照操作が許可されていない〔P〕
				　【NGKI2211】
	E_MACV		メモリアクセス違反
				・pk_rspnが指すメモリ領域への書込みアクセスが許可されて
				　いない）〔P〕【NGKI2212】
----

【機能】

spnidで指定したスピンロック（対象スピンロック）の現在状態を参照する．参
照した現在状態は，pk_rspnで指定したパケットに返される【NGKI2213】．

spnstatには，対象スピンロックの現在のロック状態を表す次のいずれかの値が
返される【NGKI2214】．

	TSPN_UNL	0x01U		取得されていない状態
	TSPN_LOC	0x02U		取得されている状態

【使用上の注意】

ref_spnはデバッグ時向けの機能であり，その他の目的に使用することは推奨し
ない．これは，ref_spnを呼び出し，対象スピンロックの現在状態を参照した直
後に割込みが発生した場合，ref_spnから戻ってきた時には対象スピンロックの
状態が変化している可能性があるためである．


=== メモリプール管理機能

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，メモリプール管理機能をサポートしない【SSPS0128】．

【μITRON4.0仕様との関係】

この仕様では，可変長メモリプール機能はサポートしないこととした．

【仕様決定の理由】

可変長メモリプール機能をサポートしないこととしたのは，メモリ割付けの処
理時間とフラグメンテーションの発生を考えると，最適なメモリ管理アルゴリ
ズムはアプリケーション依存となるため，カーネル内で実現するより，ライブ
ラリとして実現する方が適切と考えたためである．

==== 固定長メモリプール

固定長メモリプールは，生成時に決めたサイズのメモリブロック（固定長メモ
リブロック）を動的に獲得・返却するための同期・通信オブジェクトである．
固定長メモリプールは，固定長メモリプールIDと呼ぶID番号で識別する
【NGKI2215】．

各固定長メモリプールが持つ情報は次の通り【NGKI2216】．

* 固定長メモリプール属性
* 待ち行列（固定長メモリブロックの獲得待ち状態のタスクのキュー）
* 固定長メモリプール領域
* 固定長メモリプール管理領域
* アクセス許可ベクタ（保護機能対応カーネルの場合）
* 属する保護ドメイン（保護機能対応カーネルの場合）
* 属するクラス（マルチプロセッサ対応カーネルの場合）

待ち行列は，固定長メモリブロックが獲得できるまで待っている状態（固定長
メモリブロックの獲得待ち状態）のタスクが，固定長メモリブロックを獲得で
きる順序でつながれているキューである．

固定長メモリプール領域は，その中から固定長メモリブロックを割り付けるた
めのメモリ領域である．

固定長メモリプール管理領域は，固定長メモリプール領域中の割当て済みの固
定長メモリブロックと未割当てのメモリ領域に関する情報を格納しておくため
のメモリ領域である．

保護機能対応カーネルにおいて，固定長メモリプール管理領域は，カーネルの
用いるオブジェクト管理領域として扱われる【NGKI2217】．

固定長メモリプール属性には，次の属性を指定することができる【NGKI2218】．

	TA_TPRI		0x01U	待ち行列をタスクの優先度順にする

TA_TPRIを指定しない場合，待ち行列はFIFO順になる【NGKI2219】．

固定長メモリプール機能に関連するカーネル構成マクロは次の通り．

	TNUM_MPFID		登録できる固定長メモリプールの数（動的生成対応でない
					カーネルでは，静的APIによって登録された固定長メモリ
					プールの数に一致）【NGKI2220】

【μITRON4.0仕様との関係】

固定長メモリプール領域として確保すべき領域のサイズを返すカーネル構成マ
クロ（TSZ_MPF）は廃止した．これは，固定長メモリプール領域をアプリケーショ
ンで確保する方法を定めた結果，そのサイズは(blkcnt * ROUND_MPF_T(blksz))
で求めることができるようになったためである．

TNUM_MPFIDは，μITRON4.0仕様に規定されていないカーネル構成マクロである．

[[API_CRE_MPF]]
----
CRE_MPF		固定長メモリプールの生成〔S〕【NGKI2221】
acre_mpf	固定長メモリプールの生成〔TD〕【NGKI2222】
----

【静的API】
----
	CRE_MPF(ID mpfid, { ATR mpfatr, uint_t blkcnt, uint_t blksz,
										MPF_T *mpf, void *mpfmb })
----

【C言語API】
----
	ER_ID mpfid = acre_mpf(const T_CMPF *pk_cmpf)
----

【パラメータ】
----
	ID			mpfid		生成する固定長メモリプールのID番号（CRE_MPF
							の場合）
	T_CMPF *	pk_cmpf		固定長メモリプールの生成情報を入れたパケッ
							トへのポインタ（静的APIを除く）

　＊固定長メモリプールの生成情報（パケットの内容）
	ATR			mpfatr		固定長メモリプール属性
	uint_t		blkcnt		獲得できる固定長メモリブロックの数
	uint_t		blksz		固定長メモリブロックのサイズ（バイト数）
	MPF_T *		mpf			固定長メモリプール領域の先頭番地
	void *		mpfmb		固定長メモリプール管理領域の先頭番地
----

【リターンパラメータ】
----
	ER_ID		mpfid		生成された固定長メモリプールのID番号（正の
							値）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI2223】
				・CPUロック状態からの呼出し〔s〕【NGKI2224】
	E_RSATR		予約属性
				・mpfatrが無効【NGKI2225】
				・属する保護ドメインの指定が有効範囲外〔sP〕【NGKI2226】
				・属するクラスの指定が有効範囲外〔sM〕【NGKI2227】
				・クラスの囲みの中に記述されていない〔SM〕【NGKI2228】
	E_NOSPT		未サポート機能
				・条件については各カーネルにおける規定の項を参照
	E_PAR		パラメータエラー
				・blkcntが0以下【NGKI2229】
				・blkszが0以下【NGKI2230】
				・その他の条件については機能の項を参照
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する管理操作が許可されていない〔sP〕
				　【NGKI2231】
	E_MACV		メモリアクセス違反
				・pk_cmpfが指すメモリ領域への読出しアクセスが許可されて
				　いない〔sP〕【NGKI2232】
	E_NOID		ID番号不足
				・割り付けられる固定長メモリプールIDがない〔sD〕【NGKI2233】
	E_NOMEM		メモリ不足
				・固定長メモリプール領域が確保できない【NGKI2234】
				・固定長メモリプール管理領域が確保できない【NGKI2235】
	E_OBJ		オブジェクト状態エラー
				・mpfidで指定した固定長メモリプールが登録済み（CRE_MPF
				　の場合）【NGKI2236】
				・その他の条件については機能の項を参照
----

【機能】

各パラメータで指定した固定長メモリプール生成情報に従って，固定長メモリ
プールを生成する．mpf，blkcnt，blkszから固定長メモリプール領域が，
mpfmbとblkcntから固定長メモリプール管理領域がそれぞれ設定され，メモリプー
ル領域全体が未割当ての状態に初期化される【NGKI2237】．また，待ち行列は
空の状態に初期化される【NGKI2238】．

静的APIにおいては，mpfidはオブジェクト識別名，mpfatr，blkcnt，blkszは整
数定数式パラメータ，mpfとmpfmbは一般定数式パラメータである【NGKI2239】．
コンフィギュレータは，静的APIのメモリ不足（E_NOMEM）エラーを検出するこ
とができない【NGKI2240】．

mpfをNULLとした場合，blkcntとblkszから決まるサイズの固定長メモリプール
領域が，コンフィギュレータまたはカーネルにより確保される【NGKI2241】．

保護機能対応カーネルでは，コンフィギュレータまたはカーネルにより確保さ
れる固定長メモリプール領域は，固定長メモリプールと同じ保護ドメインに属
し，固定長メモリプールと同じアクセス許可ベクタを持ったメモリオブジェク
ト中に確保される【NGKI2242】．

mpfmbをNULLとした場合，blkcntから決まるサイズの固定長メモリプール管理領
域が，コンフィギュレータまたはカーネルにより確保される【NGKI2243】．

〔mpfにNULL以外を指定した場合〕

mpfにNULL以外を指定した場合，mpfを先頭番地とする固定長メモリプール領域
は，アプリケーションで確保しておく必要がある【NGKI2244】．固定長メモリ
プール領域をアプリケーションで確保するために，次のデータ型とマクロを用
意している【NGKI2245】．

	MPF_T				固定長メモリプール領域を確保するためのデータ型

	COUNT_MPF_T(blksz)	固定長メモリブロックのサイズがblkszの固定長メモ
						リプール領域を確保するために，固定長メモリブロッ
						ク1つあたりに必要なMPF_T型の配列の要素数
	ROUND_MPF_T(blksz)	要素数COUNT_MPF_T(blksz)のMPF_T型の配列のサイズ
						（blkszを，MPF_T型のサイズの倍数になるように大き
						い方に丸めた値）

これらを用いて固定長メモリプール領域を確保する方法は次の通り【NGKI2246】．

----
MPF_T	<固定長メモリプール領域の変数名>[(blkcnt) * COUNT_MPF_T(blksz)];
----

この時，mpfには<固定長メモリプール領域の変数名>を指定する【NGKI2247】．

これ以外の方法で固定長メモリプール領域を確保する場合には，上記の配列と
同じサイズのメモリ領域を確保しなければならない【NGKI2248】．また，その
先頭番地がターゲット定義の制約に合致していなければならない．mpfにターゲッ
ト定義の制約に合致しない先頭番地を指定した時には，E_PARエラーとなる
【NGKI2249】．

保護機能対応カーネルでは，アプリケーションで確保する固定長メモリプール
領域は，カーネルに登録されたメモリオブジェクトに含まれていなければなら
ない．指定した固定長メモリプール領域が，カーネルに登録されたメモリオブ
ジェクトに含まれていない場合，E_OBJエラーとなる【NGKI2251】．

〔mpfmbにNULL以外を指定した場合〕

mpfmbにNULL以外を指定した場合，mpfmbを先頭番地とする固定長メモリプール
管理領域は，アプリケーションで確保しておく必要がある【NGKI2252】．固定
長メモリプール管理領域をアプリケーションで確保するために，次のマクロを
用意している【NGKI2253】．

	TSZ_MPFMB(blkcnt)	blkcntで指定した数の固定長メモリブロックを管理
						することができる固定長メモリプール管理領域のサ
						イズ（バイト数）
	TCNT_MPFMB(blkcnt)	blkcntで指定した数の固定長メモリブロックを管理
						することができる固定長メモリプール管理領域を確
						保するために必要なMB_T型の配列の要素数

これらを用いて固定長メモリプール管理領域を確保する方法は次の通り
【NGKI2254】．

----
MB_T	<固定長メモリプール管理領域の変数名>[TCNT_MPFMB(blkcnt)];
----

この時，mpfmbには<固定長メモリプール管理領域の変数名>を指定する
【NGKI2255】．

この方法に従わず，mpfmbにターゲット定義の制約に合致しない先頭番地を指定
した時には，E_PARエラーとなる【NGKI2256】．また，保護機能対応カーネルに
おいて，mpfmbで指定した固定長メモリプール管理領域がカーネル専用のメモリ
オブジェクトに含まれない場合，E_OBJエラーとなる【NGKI2257】．

【補足説明】

保護機能対応カーネルにおいて，固定長メモリプール領域をアプリケーション
で確保する場合には，固定長メモリプール領域が属する保護ドメインとアクセ
ス権の設定は変更されない．これらを適切に設定することは，アプリケーショ
ンの責任である．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，CRE_MPFのみをサポートする【ASPS0164】．また，mpfmbには
NULLのみを指定することができる．NULL以外を指定した場合には，E_NOSPTエラー
となる【ASPS0166】．ただし，動的生成機能拡張パッケージでは，acre_mpfも
サポートする【ASPS0167】．acre_mpfに対しては，mpfmbにNULL以外を指定でき
ないという制限はない【ASPS0168】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，CRE_MPFのみをサポートする【FMPS0142】．また，mpfmbには
NULLのみを指定することができる．NULL以外を指定した場合には，E_NOSPTエラー
となる【FMPS0144】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，CRE_MPFのみをサポートする【HRPS0136】．また，mpfmbに
はNULLのみを指定することができる．NULL以外を指定した場合には，E_NOSPTエ
ラーとなる【HRPS0138】．

動的生成機能拡張パッケージでは，acre_mpfもサポートする【HRPS0197】．
acre_mpfに対しては，mpfmbにNULL以外を指定できないという制限はない
【HRPS0198】．ただし，mpfにNULLが指定されるとカーネルが固定長メモリプー
ル領域を確保する機能はサポートしない．mpfにNULLを指定した場合には，
E_NOSPTエラーとなる【HRPS0199】．

【μITRON4.0仕様との関係】

mpfのデータ型をMPF_T *に変更した．COUNT_MPF_TとROUND_MPF_Tを新設し，固
定長メモリプール領域をアプリケーションで確保する方法を規定した．また，
μITRON4.0/PX仕様にあわせて，固定長メモリプール生成情報に，mpfmbを追加
した．

【μITRON4.0/PX仕様との関係】

TCNT_MPFMBを新設し，固定長メモリプール管理領域をアプリケーションで確保
する方法を規定した．

[[API_AID_MPF]]
----
AID_MPF		割付け可能な固定長メモリプールIDの数の指定〔SD〕【NGKI2258】
----

【静的API】
----
	AID_MPF(uint_t nompf)
----

【パラメータ】
----
	uint_t		nompf		割付け可能な固定長メモリプールIDの数
----

【エラーコード】
----
	E_RSATR		予約属性
				・保護ドメインの囲みの中に記述されている〔P〕【NGKI3436】
				・クラスの囲みの中に記述されていない〔M〕【NGKI2259】
	E_PAR		パラメータエラー
				・nompfが負の値【NGKI3284】
----

【機能】

nompfで指定した数の固定長メモリプールIDを，固定長メモリプールを生成する
サービスコールによって割付け可能な固定長メモリプールIDとして確保する
【NGKI2260】．

nompfは整数定数式パラメータである【NGKI2261】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルの動的生成機能拡張パッケージでは，AID_MPFをサポートする
【ASPS0216】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルの動的生成機能拡張パッケージでは，AID_MPFをサポートする
【HRPS0217】．

[[API_SAC_MPF]]
----
SAC_MPF		固定長メモリプールのアクセス許可ベクタの設定〔SP〕【NGKI2262】
sac_mpf		固定長メモリプールのアクセス許可ベクタの設定〔TPD〕【NGKI2263】
----

【静的API】
----
	SAC_MPF(ID mpfid, { ACPTN acptn1, ACPTN acptn2,
										ACPTN acptn3, ACPTN acptn4 })
----

【C言語API】
----
	ER ercd = sac_mpf(ID mpfid, const ACVCT *p_acvct)
----

【パラメータ】
----
	ID			mpfid		対象固定長メモリプールのID番号
	ACVCT *		p_acvct		アクセス許可ベクタを入れたパケットへのポ
							インタ（静的APIを除く）

　＊アクセス許可ベクタ（パケットの内容）
	ACPTN		acptn1		通常操作1のアクセス許可パターン
	ACPTN		acptn2		通常操作2のアクセス許可パターン
	ACPTN		acptn3		管理操作のアクセス許可パターン
	ACPTN		acptn4		参照操作のアクセス許可パターン
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI2264】
				・CPUロック状態からの呼出し〔s〕【NGKI2265】
	E_ID		不正ID番号
				・mpfidが有効範囲外〔s〕【NGKI2266】
	E_RSATR		予約属性
				・対象固定長メモリプールが属する保護ドメインの囲みの中
				　（対象固定長メモリプールが無所属の場合は，保護ドメイ
				　ンの囲みの外）に記述されていない〔S〕【NGKI2267】
				・対象固定長メモリプールが属するクラスの囲みの中に記述
				　されていない〔SM〕【NGKI2268】
	E_NOEXS		オブジェクト未登録
				・対象固定長メモリプールが未登録【NGKI2269】
	E_OACV		オブジェクトアクセス違反
				・対象固定長メモリプールに対する管理操作が許可されてい
				　ない〔s〕【NGKI2270】
	E_MACV		メモリアクセス違反
				・p_acvctが指すメモリ領域への読出しアクセスが許可されて
				　いない〔s〕【NGKI2271】
	E_OBJ		オブジェクト状態エラー
				・対象固定長メモリプールは静的APIで生成された〔s〕【NGKI2272】
				・対象固定長メモリプールに対してアクセス許可ベクタが設
				　定済み〔S〕【NGKI2273】
----

【機能】

mpfidで指定した固定長メモリプール（対象固定長メモリプール）のアクセス許
可ベクタ（4つのアクセス許可パターンの組）を，各パラメータで指定した値に
設定する【NGKI2274】．対象固定長メモリプールの固定長メモリプール領域が
コンフィギュレータまたはカーネルにより確保されたものである場合には，固
定長メモリプール領域のアクセス許可ベクタも，各パラメータで指定した値に
設定する【NGKI2275】．

静的APIにおいては，mpfidはオブジェクト識別名，acptn1〜acptn4は整数定数
式パラメータである【NGKI2276】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，SAC_MPFのみをサポートする【HRPS0139】．ただし，動的生
成機能拡張パッケージでは，sac_mpfもサポートする【HRPS0200】．


[[API_del_mpf]]
----
del_mpf		固定長メモリプールの削除〔TD〕【NGKI2277】
----

【C言語API】
----
	ER ercd = del_mpf(ID mpfid)
----

【パラメータ】
----
	ID			mpfid		対象固定長メモリプールのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2278】
				・CPUロック状態からの呼出し【NGKI2279】
	E_ID		不正ID番号
				・mpfidが有効範囲外【NGKI2280】
	E_NOEXS		オブジェクト未登録
				・対象固定長メモリプールが未登録【NGKI2281】
	E_OACV		オブジェクトアクセス違反
				・対象固定長メモリプールに対する管理操作が許可されてい
				　ない〔P〕【NGKI2282】
	E_OBJ		オブジェクト状態エラー
				・対象固定長メモリプールは静的APIで生成された【NGKI2283】
----

【機能】

mpfidで指定した固定長メモリプール（対象固定長メモリプール）を削除する．
具体的な振舞いは以下の通り．

対象固定長メモリプールの登録が解除され，その固定長メモリプールIDが未使
用の状態に戻される【NGKI2284】．また，対象固定長メモリプールの待ち行列
につながれたタスクは，待ち行列の先頭のタスクから順に待ち解除される
【NGKI2285】．待ち解除されたタスクには，待ち状態となったサービスコール
からE_DLTエラーが返る【NGKI2286】．

【使用上の注意】

del_mpfにより複数のタスクが待ち解除される場合，サービスコールの処理時間
およびカーネル内での割込み禁止時間が，待ち解除されるタスクの数に比例し
て長くなる．特に，多くのタスクが待ち解除される場合，カーネル内での割込
み禁止時間が長くなるため，注意が必要である．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，del_mpfをサポートしない【ASPS0170】．ただし，動的生成
機能拡張パッケージでは，del_mpfをサポートする【ASPS0171】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，del_mpfをサポートしない【FMPS0146】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，del_mpfをサポートしない【HRPS0140】．ただし，動的生成
機能拡張パッケージでは，del_mpfをサポートする【HRPS0201】．


[[API_get_mpf]]
----
get_mpf		固定長メモリブロックの獲得〔T〕【NGKI2287】
pget_mpf	固定長メモリブロックの獲得（ポーリング）〔T〕【NGKI2288】
tget_mpf	固定長メモリブロックの獲得（タイムアウト付き）〔T〕【NGKI2289】
----

【C言語API】
----
	ER ercd = get_mpf(ID mpfid, void **p_blk)
	ER ercd = pget_mpf(ID mpfid, void **p_blk)
	ER ercd = tget_mpf(ID mpfid, void **p_blk, TMO tmout)
----

【パラメータ】
----
	ID			mpfid		対象固定長メモリプールのID番号
	void **		p_blk		獲得した固定長メモリブロックの先頭番地を入
							れるメモリ領域へのポインタ
	TMO			tmout		タイムアウト時間（twai_mpfの場合）
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
	void *		blk			獲得した固定長メモリブロックの先頭番地
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2290】
				・CPUロック状態からの呼出し【NGKI2291】
				・ディスパッチ保留状態からの呼出し（pget_mpfを除く）
				　【NGKI2292】
	E_NOSPT		未サポート機能
				・制約タスクからの呼出し（pget_mpfを除く）【NGKI2293】
	E_ID		不正ID番号
				・mpfidが有効範囲外【NGKI2294】
	E_PAR		パラメータエラー
				・tmoutが無効（tget_mpfの場合）【NGKI2295】
	E_NOEXS		オブジェクト未登録
				・対象固定長メモリプールが未登録〔D〕【NGKI2296】
	E_OACV		オブジェクトアクセス違反
				・対象固定長メモリプールに対する通常操作1が許可されてい
				　ない〔P〕【NGKI2297】
	E_MACV		メモリアクセス違反
				・p_blkが指すメモリ領域への書込みアクセスが許可されてい
				　ない）〔P〕【NGKI2298】
	E_TMOUT		ポーリング失敗またはタイムアウト（get_mpfを除く）【NGKI2299】
	E_RLWAI		待ち禁止状態または待ち状態の強制解除（pget_mpfを除く）
				【NGKI2300】
	E_DLT		待ちオブジェクトの削除または再初期化（pget_mpfを除く）
				【NGKI2301】
----

【機能】

mpfidで指定した固定長メモリプール（対象固定長メモリプール）から固定長メ
モリブロックを獲得し，その先頭番地をp_blkが指すメモリ領域に返す．具体的
な振舞いは以下の通り．

対象固定長メモリプールの固定長メモリプール領域の中に，固定長メモリブロッ
クを割り付けることのできる未割当てのメモリ領域がある場合には，固定長メ
モリブロックが1つ割り付けられ，その先頭番地がblkに返される【NGKI2302】．

未割当てのメモリ領域がない場合には，自タスクは固定長メモリプールの獲得
待ち状態となり，対象固定長メモリプールの待ち行列につながれる【NGKI2303】．


[[API_rel_mpf]]
----
rel_mpf		固定長メモリブロックの返却〔T〕【NGKI2304】
----

【C言語API】
----
	ER ercd = rel_mpf(ID mpfid, void *blk)
----

【パラメータ】
----
	ID			mpfid		対象固定長メモリプールのID番号
	void *		blk			返却する固定長メモリブロックの先頭番地
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2305】
				・CPUロック状態からの呼出し【NGKI2306】
	E_ID		不正ID番号
				・mpfidが有効範囲外【NGKI2307】
	E_PAR		パラメータエラー
				・条件については機能の項を参照
	E_NOEXS		オブジェクト未登録
				・対象固定長メモリプールが未登録〔D〕【NGKI2308】
	E_OACV		オブジェクトアクセス違反
				・対象固定長メモリプールに対する通常操作2が許可されてい
				　ない〔P〕【NGKI2309】
----

【機能】

mpfidで指定した固定長メモリプール（対象固定長メモリプール）に，blkで指
定した固定長メモリブロックを返却する．具体的な振舞いは以下の通り．

対象固定長メモリプールの待ち行列にタスクが存在する場合には，待ち行列の
先頭のタスクが，blkで指定した固定長メモリブロックを獲得し，待ち解除され
る【NGKI2310】．待ち解除されたタスクには，待ち状態となったサービスコー
ルからE_OKが返る【NGKI2311】．

待ち行列にタスクが存在しない場合には，blkで指定した固定長メモリブロック
は，対象固定長メモリプールのメモリプール領域に返却される【NGKI2312】．

blkが，対象固定長メモリプールから獲得した固定長メモリブロックの先頭番地
でない場合には，E_PARエラーとなる【NGKI2313】．


[[API_ini_mpf]]
----
ini_mpf		固定長メモリプールの再初期化〔T〕【NGKI2314】
----

【C言語API】
----
	ER ercd = ini_mpf(ID mpfid)
----

【パラメータ】
----
	ID			mpfid		対象固定長メモリプールのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2315】
				・CPUロック状態からの呼出し【NGKI2316】
	E_ID		不正ID番号
				・mpfidが有効範囲外【NGKI2317】
	E_NOEXS		オブジェクト未登録
				・対象固定長メモリプールが未登録〔D〕【NGKI2318】
	E_OACV		オブジェクトアクセス違反
				・対象固定長メモリプールに対する管理操作が許可されてい
				　ない〔P〕【NGKI2319】
----

【機能】

mpfidで指定した固定長メモリプール（対象固定長メモリプール）を再初期化す
る．具体的な振舞いは以下の通り．

対象固定長メモリプールのメモリプール領域全体が未割当ての状態に初期化さ
れる【NGKI2320】．また，対象固定長メモリプールの待ち行列につながれたタ
スクは，待ち行列の先頭のタスクから順に待ち解除される【NGKI2321】．待ち
解除されたタスクには，待ち状態となったサービスコールからE_DLTエラーが返
る【NGKI2322】．

【使用上の注意】

ini_mpfにより複数のタスクが待ち解除される場合，サービスコールの処理時間
およびカーネル内での割込み禁止時間が，待ち解除されるタスクの数に比例し
て長くなる．特に，多くのタスクが待ち解除される場合，カーネル内での割込
み禁止時間が長くなるため，注意が必要である．

固定長メモリプールを再初期化した場合に，アプリケーションとの整合性を保
つのは，アプリケーションの責任である．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていないサービスコールである．


[[API_ref_mpf]]
----
ref_mpf		固定長メモリプールの状態参照〔T〕【NGKI2323】
----

【C言語API】
----
	ER ercd = ref_mpf(ID mpfid, T_RMPF *pk_rmpf)
----

【パラメータ】
----
	ID			mpfid		対象固定長メモリプールのID番号
	T_RMPF *	pk_rmpf		固定長メモリプールの現在状態を入れるパケッ
							トへのポインタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード

　＊固定長メモリプールの現在状態（パケットの内容）
	ID			wtskid		固定長メモリプールの待ち行列の先頭のタスク
							のID番号
	uint_t		fblkcnt		固定長メモリプール領域の空きメモリ領域に割
							り付けることができる固定長メモリブロックの
							数
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2324】
				・CPUロック状態からの呼出し【NGKI2325】
	E_ID		不正ID番号
				・mpfidが有効範囲外【NGKI2326】
	E_NOEXS		オブジェクト未登録
				・対象固定長メモリプールが未登録〔D〕【NGKI2327】
	E_OACV		オブジェクトアクセス違反
				・対象固定長メモリプールに対する参照操作が許可されてい
				　ない〔P〕【NGKI2328】
	E_MACV		メモリアクセス違反
				・pk_rmpfが指すメモリ領域への書込みアクセスが許可されて
				　いない）〔P〕【NGKI2329】
----

【機能】

mpfidで指定した固定長メモリプール（対象固定長メモリプール）の現在状態を
参照する．参照した現在状態は，pk_rmpfで指定したパケットに返される
【NGKI2330】．

対象固定長メモリプールの待ち行列にタスクが存在しない場合，wtskidには
TSK_NONE（＝0）が返る【NGKI2331】．

【使用上の注意】

ref_mpfはデバッグ時向けの機能であり，その他の目的に使用することは推奨し
ない．これは，ref_mpfを呼び出し，対象固定長メモリプールの現在状態を参照
した直後に割込みが発生した場合，ref_mpfから戻ってきた時には対象固定長メ
モリプールの状態が変化している可能性があるためである．


=== 時間管理機能

==== システム時刻管理

システム時刻は，カーネルによって管理され，タイムアウト処理，タスクの遅
延，周期ハンドラの起動，アラームハンドラの起動に使用される時刻を管理す
るカーネルオブジェクトである【NGKI3603】．システム時刻は，符号無しの整
数型であるSYSTIM型で表され，単位はミリ秒である【NGKI2332】．

システム時刻は，カーネルの初期化時に0に初期化される【NGKI2333】．タイム
ティックを通知するためのタイマ割込みが発生する毎にカーネルによって更新
され，SYSTIM型で表せる最大値（ULONG_MAX）を超えると0に戻される
【NGKI2334】．タイムティックの周期は，ターゲット定義である【NGKI2335】．
また，システム時刻の精度はターゲットに依存する【NGKI2336】．

マルチプロセッサ対応でないカーネルと，マルチプロセッサ対応カーネルでグ
ローバルタイマ方式を用いている場合には，システム時刻は，システムに1つの
み存在する【NGKI2337】．マルチプロセッサ対応カーネルでローカルタイマ方
式を用いている場合には，システム時刻は，プロセッサ毎に存在する
【NGKI2338】．ローカルタイマ方式とグローバルタイマ方式については，
「2.3.4 マルチプロセッサ対応」の節を参照すること．

マルチプロセッサ対応カーネルでローカルタイマ方式を用いている場合には，
タイムアウト処理とタスクの遅延処理には，待ち解除されるタスクが割り付け
られているプロセッサのシステム時刻が用いられる【NGKI2339】．また，周期
ハンドラとアラームハンドラの起動には，それが割り付けられているプロセッ
サのシステム時刻が用いられる【NGKI2340】．これらの処理単位がマイグレー
ションする場合には，用いられるシステム時刻も変更される【NGKI2341】．こ
の場合にも，イベントの処理が行われるのは，基準時刻から相対時間によって
指定した以上の時間が経過した後となるという規則は維持される【NGKI2342】．

1回のタイムティックの発生により，複数のイベントの処理を行うべき状況になっ
た場合，それらの処理の間の処理順序は規定されない【NGKI2343】．

性能評価用システム時刻は，性能評価に使用することを目的とした，システム
時刻よりも精度の高い時刻である．性能評価用システム時刻は，符号無しの整
数型であるSYSUTM型で表され，単位はマイクロ秒である【NGKI2344】．ただし，
実際の精度はターゲットに依存する【NGKI2345】．

マルチプロセッサ対応カーネルにおける性能評価用システム時刻の扱いは，ター
ゲット定義とする【NGKI2346】．

システム時刻管理機能に関連するカーネル構成マクロは次の通り．

	TIC_NUME	タイムティックの周期（単位はミリ秒）の分子	【NGKI2347】
	TIC_DENO	タイムティックの周期（単位はミリ秒）の分母

	TOPPERS_SUPPORT_GET_UTM		get_utmがサポートされている【NGKI2348】

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，時間管理機能をサポートしない【SSPS0129】．

【使用上の注意】

タイムティックを通知するためのタイマ割込みが長時間マスクされた場合（タ
イマ割込みより優先して実行される割込み処理が長時間続けて実行された場合
を含む）や，シミュレーション環境においてシミュレータのプロセスが長時間
スケジュールされなかった場合には，システム時刻が正しく更新されない可能
性があるため，注意が必要である．

【μITRON4.0仕様との関係】

システム時刻を設定するサービスコール（set_tim）を廃止した．また，タイム
ティックを供給する機能は，カーネル内に実現することとし，そのためのサー
ビスコール（isig_tim）は廃止した．

【μITRON4.0/PX仕様との関係】

システム時刻のアクセス許可ベクタは廃止し，システム状態のアクセス許可ベ
クタで代替することとした．そのため，システム時刻のアクセス許可ベクタを
設定する静的API（SAC_TIM）とサービスコール（sac_tim）は廃止した．

[[API_get_tim]]
----
get_tim		システム時刻の参照〔T〕【NGKI2349】
----

【C言語API】
----
	ER ercd = get_tim(SYSTIM *p_systim)
----

【パラメータ】
----
	SYSTIM *	p_systim	システム時刻を入れるメモリ領域へのポインタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
	SYSTIM		systim		システム時刻の現在値
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2350】
				・CPUロック状態からの呼出し【NGKI2351】
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する参照操作が許可されていない〔P〕
				　【NGKI2352】
	E_MACV		メモリアクセス違反
				・p_systimが指すメモリ領域への書込みアクセスが許可され
				　ていない）〔P〕【NGKI2353】
----

【機能】

システム時刻の現在値を参照する．参照したシステム時刻は，p_systimが指す
メモリ領域に返される【NGKI2354】．

マルチプロセッサ対応カーネルでローカルタイマ方式を用いている場合には，
自タスクが割り付けられているプロセッサのシステム時刻の現在値を参照する
【NGKI2355】．

【補足説明】

マルチプロセッサ対応カーネルでローカルタイマ方式を用いている場合に，他
のプロセッサのシステム時刻の現在値を参照する機能は用意していない．


[[API_get_utm]]
----
get_utm		性能評価用システム時刻の参照〔TI〕【NGKI2356】
----

【C言語API】
----
	ER ercd = get_utm(SYSUTM *p_sysutm)
----

【パラメータ】
----
	SYSUTM *	p_sysutm	性能評価用システム時刻を入れるメモリ領域へ
							のポインタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
	SYSUTM		sysutm		性能評価用システム時刻の現在値
----

【エラーコード】
----
	E_NOSPT		未サポート機能
				・条件については機能の項を参照
	E_MACV		メモリアクセス違反
				・p_sysutmが指すメモリ領域へ書込みアクセスが許可されて
				　いない）〔P〕【NGKI2357】
----

【機能】

性能評価用システム時刻の現在値を参照する．参照した性能評価用システム時
刻は，p_sysutmが指すメモリ領域に返される【NGKI2358】．

get_utmは，任意の状態から呼び出すことができる【NGKI2359】．タスクコンテ
キストからも非タスクコンテキストからも呼び出すことができるし，CPUロック
状態であっても呼び出すことができる．

ターゲット定義で，get_utmがサポートされていない場合がある【NGKI2360】．
get_utmがサポートされている場合には，TOPPERS_SUPPORT_GET_UTMがマクロ定
義される【NGKI2361】．サポートされていない場合にget_utmを呼び出すと，
E_NOSPTエラーが返るか，リンク時にエラーとなる【NGKI2362】．

【使用方法】

get_utmを使用してプログラムの処理時間を計測する場合には，次の手順を取る．
処理時間を計測したいプログラムの実行直前と実行直後に，get_utmを用いて性
能評価用システム時刻を読み出す．その差を求めることで，対象プログラムの
処理時間に，get_utm自身の処理時間を加えたものが得られる．

マルチプロセッサ対応カーネルにおいては，異なるプロセッサで読み出した性
能評価用システム時刻の差を求めることで，処理時間が正しく計測できるとは
限らない．

【使用上の注意】

get_utmは性能評価のための機能であり，その他の目的に使用することは推奨し
ない．

get_utmは，任意の状態から呼び出すことができるように，全割込みロック状態
を用いて実装されている．そのため，get_utmを用いると，カーネル管理外の割
込みの応答性が低下する．

システム時刻が正しく更新されない状況では，get_utmは誤った性能評価用シス
テム時刻を返す可能性がある．システム時刻の更新が確実に行われることを保
証できない場合には，get_utmが誤った性能評価用システム時刻を返す可能性を
考慮に入れて使用しなければならない．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていないサービスコールである．


==== 周期ハンドラ

周期ハンドラは，指定した周期で起動されるタイムイベントハンドラである．
周期ハンドラは，周期ハンドラIDと呼ぶID番号によって識別する【NGKI2363】．

各周期ハンドラが持つ情報は次の通り【NGKI2364】．

* 周期ハンドラ属性
* 周期ハンドラの動作状態
* 次に周期ハンドラを起動する時刻
* 拡張情報
* 周期ハンドラの先頭番地
* 起動周期
* 起動位相
* アクセス許可ベクタ（保護機能対応カーネルの場合）
* 属する保護ドメイン（保護機能対応カーネルの場合）
* 属するクラス（マルチプロセッサ対応カーネルの場合）

周期ハンドラの起動時刻は，後述する基準時刻から，以下の式で求められる相
対時間後である【NGKI2365】．

	起動位相＋起動周期×(n−1)		n＝1,2,…

周期ハンドラの動作状態は，動作している状態と動作していない状態のいずれ
かをとる【NGKI2366】．周期ハンドラを動作している状態にすることを動作開
始，動作していない状態にすることを動作停止という．

周期ハンドラが動作している状態の場合には，周期ハンドラを起動する時刻に
なると，周期ハンドラの起動処理が行われる【NGKI2367】．具体的には，拡張
情報をパラメータとして，周期ハンドラが呼び出される【NGKI2368】．

保護機能対応カーネルにおいて，周期ハンドラが属することのできる保護ドメ
インは，カーネルドメインに限られる【NGKI2369】．

周期ハンドラ属性には，次の属性を指定することができる【NGKI2370】．

	TA_STA		0x02U	周期ハンドラの生成時に周期ハンドラを動作開始する
	TA_PHS		0x04U	周期ハンドラを生成した時刻を基準時刻とする

TA_STAを指定しない場合，周期ハンドラの生成直後には，周期ハンドラは動作
していない状態となる【NGKI2371】．

TA_PHSを指定しない場合には，周期ハンドラを動作開始した時刻が，周期ハン
ドラを起動する時刻の基準時刻となる【NGKI2372】．TA_PHSを指定した場合に
は，周期ハンドラを生成した時刻（静的APIで生成した場合にはカーネルの起動
時刻）が，基準時刻となる【NGKI2373】．

次に周期ハンドラを起動する時刻は，周期ハンドラが動作している状態でのみ
有効で，必要に応じて，カーネルの起動時，周期ハンドラの動作開始時，周期
ハンドラの起動処理時に設定される【NGKI2374】．

マルチプロセッサ対応カーネルでグローバルタイマ方式を用いている場合には，
周期ハンドラは，システム時刻管理プロセッサのみが割付け可能プロセッサで
あるクラスにのみ属することができる【NGKI2375】．すなわち，周期ハンドラ
は，システム時刻管理プロセッサによって実行される．

C言語による周期ハンドラの記述形式は次の通り【NGKI2376】．

[source,c]
----
	void cyclic_handler(intptr_t exinf)
	{
		周期ハンドラ本体
	}
----

exinfには，周期ハンドラの拡張情報が渡される【NGKI2377】．

周期ハンドラ機能に関連するカーネル構成マクロは次の通り．

	TNUM_CYCID		登録できる周期ハンドラの数（動的生成対応でないカー
					ネルでは，静的APIによって登録された周期ハンドラの数
					に一致）【NGKI2378】

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，TA_PHS属性の周期ハンドラをサポートしない【ASPS0172】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，TA_PHS属性の周期ハンドラをサポートしない【FMPS0147】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，TA_PHS属性の周期ハンドラをサポートしない【HRPS0141】．

【μITRON4.0仕様との関係】

TNUM_CYCIDは，μITRON4.0仕様に規定されていないカーネル構成マクロである．


[[API_CRE_CYC]]
----
CRE_CYC		周期ハンドラの生成〔S〕【NGKI2379】
acre_cyc	周期ハンドラの生成〔TD〕【NGKI2380】
----

【静的API】
----
	CRE_CYC(ID cycid, { ATR cycatr, intptr_t exinf, CYCHDR cychdr,
										RELTIM cyctim, RELTIM cycphs })
----

【C言語API】
----
	ER_ID cycid = acre_cyc(const T_CCYC *pk_ccyc)
----

【パラメータ】
----
	ID			cycid		生成する周期ハンドラのID番号（CRE_CYCの場合）
	T_CCYC *	pk_ccyc		周期ハンドラの生成情報を入れたパケットへの
							ポインタ（静的APIを除く）

　＊周期ハンドラの生成情報（パケットの内容）
	ATR			cycatr		周期ハンドラ属性
	intptr_t	exinf		周期ハンドラの拡張情報
	CYCHDR		cychdr		周期ハンドラの先頭番地
	RELTIM		cyctim		周期ハンドラの起動周期
	RELTIM		cycphs		周期ハンドラの起動位相
----

【リターンパラメータ】
----
	ER_ID		cycid		生成された周期ハンドラのID番号（正の値）また
							はエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI2381】
				・CPUロック状態からの呼出し〔s〕【NGKI2382】
	E_RSATR		予約属性
				・cycatrが無効【NGKI2383】
				・属する保護ドメインの指定が有効範囲外またはカーネルド
				　メイン以外〔sP〕【NGKI2384】
				・カーネルドメインの囲みの中に記述されていない〔SP〕
				　【NGKI2385】
				・属するクラスの指定が有効範囲外〔sM〕【NGKI2386】
				・クラスの囲みの中に記述されていない〔SM〕【NGKI2387】
				・その他の条件については機能の項を参照
	E_PAR		パラメータエラー
				・cychdrがプログラムの先頭番地として正しくない【NGKI2388】
				・cyctimが有効範囲（0より大きくTMAX_RELTIM以下）外【NGKI2397】
				・cycphsが有効範囲（0以上TMAX_RELTIM以下）外【NGKI2399】
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する管理操作が許可されていない〔sP〕
				　【NGKI2389】
	E_MACV		メモリアクセス違反
				・pk_ccycが指すメモリ領域への読出しアクセスが許可されて
				　いない〔sP〕【NGKI2390】
	E_NOID		ID番号不足
				・割り付けられる周期ハンドラIDがない〔sD〕【NGKI2391】
	E_OBJ		オブジェクト状態エラー
				・cycidで指定した周期ハンドラが登録済み（CRE_CYCの場合）
				　【NGKI2392】
----

【機能】

各パラメータで指定した周期ハンドラ生成情報に従って，周期ハンドラを生成
する．具体的な振舞いは以下の通り．

cycatrにTA_STAを指定した場合，対象周期ハンドラは動作している状態となる
【NGKI2393】．次に周期ハンドラを起動する時刻は，サービスコールを呼び出
した時刻（静的APIの場合はカーネルの起動時刻）から，cycphsで指定した相対
時間後に設定される【NGKI2394】．cycphsにcyctimより大きい値を指定しても
よい【NGKI2400】．

cycatrにTA_STAを指定しない場合，対象周期ハンドラは動作していない状態に
初期化される【NGKI2395】．

静的APIにおいては，cycidはオブジェクト識別名，cycatr，cyctim，cycphsは
整数定数式パラメータ，exinfとcychdrは一般定数式パラメータである
【NGKI2396】．

マルチプロセッサ対応カーネルでグローバルタイマ方式を用いている場合で，
生成する周期ハンドラの属するクラスの割付け可能プロセッサが，システム時
刻管理プロセッサのみでない場合には，E_RSATRエラーとなる【NGKI2401】．

【補足説明】

静的APIにおいて，cycatrにTA_STAを，cycphsに0を指定した場合，周期ハンド
ラが最初に呼び出されるのは，カーネル起動後最初のタイムティックになる．
cycphsに1を指定した場合も同じ振舞いとなるため，静的APIでcycatrにTA_STA
が指定されている場合には，cycphsに0を指定することは推奨されず，コンフィ
ギュレータが警告メッセージを出力する．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，CRE_CYCのみをサポートする【ASPS0173】．ただし，TA_PHS
属性の周期ハンドラはサポートしない【ASPS0174】．動的生成機能拡張パッケー
ジでは，acre_cycもサポートする【ASPS0175】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，CRE_CYCのみをサポートする【FMPS0148】．ただし，TA_PHS
属性の周期ハンドラはサポートしない【FMPS0149】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，CRE_CYCのみをサポートする【HRPS0142】．ただし，
TA_PHS属性の周期ハンドラはサポートしない【HRPS0143】．動的生成機能拡張
パッケージでは，acre_cycもサポートする【HRPS0202】．

【μITRON4.0仕様との関係】

cychdrのデータ型をCYCHDRに変更した．また，cycphsにcyctimより大きい値を
指定した場合の振舞いと，静的APIでcycphsに0を指定した場合の振舞いを規定
した．


[[API_AID_CYC]]
----
AID_CYC		割付け可能な周期ハンドラIDの数の指定〔SD〕【NGKI2402】
----

【静的API】
----
	AID_CYC(uint_t nocyc)
----

【パラメータ】
----
	uint_t		nocyc		割付け可能な周期ハンドラIDの数
----

【エラーコード】
----
	E_RSATR		予約属性
				・保護ドメインの囲みの中に記述されている〔P〕【NGKI3437】
				・クラスの囲みの中に記述されていない〔M〕【NGKI2404】
				・その他の条件については機能の項を参照
	E_PAR		パラメータエラー
				・nocycが負の値【NGKI3285】
----

【機能】

nocycで指定した数の周期ハンドラIDを，周期ハンドラを生成するサービスコー
ルによって割付け可能な周期ハンドラIDとして確保する【NGKI2405】．

nocycは整数定数式パラメータである【NGKI2406】．

マルチプロセッサ対応カーネルでグローバルタイマ方式を用いている場合で，
AID_CYCが属するクラスの割付け可能プロセッサが，システム時刻管理プロセッ
サのみでない場合には，E_RSATRエラーとなる【NGKI2407】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルの動的生成機能拡張パッケージでは，AID_CYCをサポートする
【ASPS0217】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルの動的生成機能拡張パッケージでは，AID_CYCをサポートする
【HRPS0218】．


[[API_SAC_CYC]]
----
SAC_CYC		周期ハンドラのアクセス許可ベクタの設定〔SP〕【NGKI2408】
sac_cyc		周期ハンドラのアクセス許可ベクタの設定〔TPD〕【NGKI2409】
----

【静的API】
----
	SAC_CYC(ID cycid, { ACPTN acptn1, ACPTN acptn2,
										ACPTN acptn3, ACPTN acptn4 })
----

【C言語API】
----
	ER ercd = sac_cyc(ID cycid, const ACVCT *p_acvct)
----

【パラメータ】
----
	ID			cycid		対象周期ハンドラのID番号
	ACVCT *		p_acvct		アクセス許可ベクタを入れたパケットへのポ
							インタ（静的APIを除く）

　＊アクセス許可ベクタ（パケットの内容）
	ACPTN		acptn1		通常操作1のアクセス許可パターン
	ACPTN		acptn2		通常操作2のアクセス許可パターン
	ACPTN		acptn3		管理操作のアクセス許可パターン
	ACPTN		acptn4		参照操作のアクセス許可パターン
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI2410】
				・CPUロック状態からの呼出し〔s〕【NGKI2411】
	E_ID		不正ID番号
				・cycidが有効範囲外〔s〕【NGKI2412】
	E_RSATR		予約属性
				・カーネルドメインの囲みの中に記述されていない〔S〕【NGKI2413】
				・対象周期ハンドラが属するクラスの囲みの中に記述されて
				　いない〔SM〕【NGKI2414】
	E_NOEXS		オブジェクト未登録
				・対象周期ハンドラが未登録【NGKI2415】
	E_OACV		オブジェクトアクセス違反
				・対象周期ハンドラに対する管理操作が許可されていない〔s〕
				　【NGKI2416】
	E_MACV		メモリアクセス違反
				・p_acvctが指すメモリ領域への読出しアクセスが許可されて
				　いない〔s〕【NGKI2417】
	E_OBJ		オブジェクト状態エラー
				・対象周期ハンドラは静的APIで生成された〔s〕【NGKI2418】
				・対象周期ハンドラに対してアクセス許可ベクタが設定済み
				　〔S〕【NGKI2419】
----

【機能】

cycidで指定した周期ハンドラ（対象周期ハンドラ）のアクセス許可ベクタ（4
つのアクセス許可パターンの組）を，各パラメータで指定した値に設定する
【NGKI2420】．

静的APIにおいては，cycidはオブジェクト識別名，acptn1〜acptn4は整数定数
式パラメータである【NGKI2421】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，SAC_CYCのみをサポートする【HRPS0144】．ただし，動的生
成機能拡張パッケージでは，sac_cycもサポートする【HRPS0203】．


[[API_del_cyc]]
----
del_cyc		周期ハンドラの削除〔TD〕【NGKI2422】
----

【C言語API】
----
	ER ercd = del_cyc(ID cycid)
----

【パラメータ】
----
	ID			cycid		対象周期ハンドラのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2423】
				・CPUロック状態からの呼出し【NGKI2424】
	E_ID		不正ID番号
				・cycidが有効範囲外【NGKI2425】
	E_NOEXS		オブジェクト未登録
				・対象周期ハンドラが未登録【NGKI2426】
	E_OACV		オブジェクトアクセス違反
				・対象周期ハンドラに対する管理操作が許可されていない〔P〕
				　【NGKI2427】
	E_OBJ		オブジェクト状態エラー
				・対象周期ハンドラは静的APIで生成された【NGKI2428】
----

【機能】

cycidで指定した周期ハンドラ（対象周期ハンドラ）を削除する．具体的な振舞
いは以下の通り．

対象周期ハンドラの登録が解除され，その周期ハンドラIDが未使用の状態に戻
される【NGKI2429】．対象周期ハンドラが動作している状態であった場合には，
動作していない状態にされた後に，登録が解除される【NGKI2430】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，del_cycをサポートしない【ASPS0177】．ただし，動的生成
機能拡張パッケージでは，del_cycをサポートする【ASPS0178】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，del_cycをサポートしない【FMPS0151】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，del_cycをサポートしない【HRPS0145】．ただし，動的生成
機能拡張パッケージでは，del_cycをサポートする【HRPS0204】．


[[API_sta_cyc]]
----
sta_cyc		周期ハンドラの動作開始〔T〕【NGKI2431】
----

【C言語API】
----
	ER ercd = sta_cyc(ID cycid)
----

【パラメータ】
----
	ID			cycid		対象周期ハンドラのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2432】
				・CPUロック状態からの呼出し【NGKI2433】
	E_ID		不正ID番号
				・cycidが有効範囲外【NGKI2434】
	E_NOEXS		オブジェクト未登録
				・対象周期ハンドラが未登録〔D〕【NGKI2435】
	E_OACV		オブジェクトアクセス違反
				・対象周期ハンドラに対する通常操作1が許可されていない〔P〕
				　【NGKI2436】
----

【機能】

cycidで指定した周期ハンドラ（対象周期ハンドラ）を動作開始する．具体的な
振舞いは以下の通り．

対象周期ハンドラが動作していない状態であれば，対象周期ハンドラは動作し
ている状態となる【NGKI2437】．次に周期ハンドラを起動する時刻は，
sta_cycを呼び出して以降の最初の起動時刻に設定される【NGKI2438】．

対象周期ハンドラが動作している状態であれば，次に周期ハンドラを起動する
時刻の再設定のみが行われる【NGKI2439】．

【補足説明】

TA_PHS属性でない周期ハンドラの場合，次に周期ハンドラを起動する時刻は，
sta_cycを呼び出してから，対象周期ハンドラの起動位相で指定した相対時間後
に設定される．

対象周期ハンドラがTA_PHS属性で，動作している状態であれば，次に周期ハン
ドラを起動する時刻は変化しない．

【μITRON4.0仕様との関係】

TA_PHS属性でない周期ハンドラにおいて，sta_cycを呼び出した後，最初に周期
ハンドラが起動される時刻を変更した．μITRON4.0仕様では，sta_cycを呼び出
してから周期ハンドラの起動周期で指定した相対時間後となっているが，この
仕様では，起動位相で指定した相対時間後とした．


[[API_msta_cyc]]
----
msta_cyc	割付けプロセッサ指定での周期ハンドラの動作開始〔TM〕【NGKI2440】
----

【C言語API】
----
	ER ercd = msta_cyc(ID cycid, ID prcid)
----

【パラメータ】
----
	ID			cycid		対象周期ハンドラのID番号
	ID			prcid		周期ハンドラの割付け対象のプロセッサのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2441】
				・CPUロック状態からの呼出し【NGKI2442】
	E_NOSPT		未サポート機能
				・条件については機能の項を参照
	E_ID		不正ID番号
				・cycidが有効範囲外【NGKI2443】
				・prcidが有効範囲外【NGKI2444】
	E_PAR		パラメータエラー
				・条件については機能の項を参照
	E_NOEXS		オブジェクト未登録
				・対象周期ハンドラが未登録〔D〕【NGKI2445】
	E_OACV		オブジェクトアクセス違反
				・対象周期ハンドラに対する通常操作1が許可されていない〔P〕
				　【NGKI2446】
----

【機能】

prcidで指定したプロセッサを割付けプロセッサとして，cycidで指定した周期
ハンドラ（対象周期ハンドラ）を動作開始する．具体的な振舞いは以下の通り．

対象周期ハンドラが動作していない状態であれば，対象周期ハンドラの割付け
プロセッサがprcidで指定したプロセッサに変更された後，対象周期ハンドラは
動作している状態となる【NGKI2447】．次に周期ハンドラを起動する時刻は，
msta_cycを呼び出して以降の最初の起動時刻に設定される【NGKI2448】．

対象周期ハンドラが動作している状態であれば，対象周期ハンドラの割付けプ
ロセッサがprcidで指定したプロセッサに変更された後，次に周期ハンドラを起
動する時刻の再設定が行われる【NGKI2449】．

対象周期ハンドラが実行中である場合には，割付けプロセッサを変更しても，
実行中の周期ハンドラを実行するプロセッサは変更されない【NGKI2450】．対
象周期ハンドラが変更後の割付けプロセッサで実行されるのは，次に起動され
る時からである【NGKI2451】．

対象周期ハンドラの属するクラスの割付け可能プロセッサが，prcidで指定した
プロセッサを含んでいない場合には，E_PARエラーとなる【NGKI2452】．

prcidにTPRC_INI（＝0）を指定すると，対象周期ハンドラの割付けプロセッサ
を，それが属するクラスの初期割付けプロセッサとする【NGKI2453】．

グローバルタイマ方式を用いている場合，msta_cycはE_NOSPTを返す
【NGKI2454】．

【補足説明】

TA_PHS属性でない周期ハンドラの場合，次に周期ハンドラを起動する時刻は，
msta_cycを呼び出してから，対象周期ハンドラの起動位相で指定した相対時間
後に設定される．

【使用上の注意】

msta_cycで実行中の周期ハンドラの割付けプロセッサを変更した場合，同じ周
期ハンドラが異なるプロセッサで同時に実行される可能性がある．特に，対象
周期ハンドラの起動位相が0の場合に，注意が必要である．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていないサービスコールである．


[[API_stp_cyc]]
----
stp_cyc		周期ハンドラの動作停止〔T〕【NGKI2455】
----

【C言語API】
----
	ER ercd = stp_cyc(ID cycid)
----

【パラメータ】
----
	ID			cycid		対象周期ハンドラのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2456】
				・CPUロック状態からの呼出し【NGKI2457】
	E_ID		不正ID番号
				・cycidが有効範囲外【NGKI2458】
	E_NOEXS		オブジェクト未登録
				・対象周期ハンドラが未登録〔D〕【NGKI2459】
	E_OACV		オブジェクトアクセス違反
				・対象周期ハンドラに対する通常操作2が許可されていない〔P〕
				　【NGKI2460】
----

【機能】

cycidで指定した周期ハンドラ（対象周期ハンドラ）を動作停止する．具体的な
振舞いは以下の通り．

対象周期ハンドラが動作している状態であれば，動作していない状態になる
【NGKI2461】．対象周期ハンドラが動作していない状態であれば，何も行われ
ずに正常終了する【NGKI2462】．


[[API_ref_cyc]]
----
ref_cyc		周期ハンドラの状態参照〔T〕【NGKI2463】
----

【C言語API】
----
	ER ercd = ref_cyc(ID cycid, T_RCYC *pk_rcyc)
----

【パラメータ】
----
	ID			cycid		対象周期ハンドラのID番号
	T_RCYC *	pk_rcyc		周期ハンドラの現在状態を入れるパケットへの
							ポインタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード

　＊周期ハンドラの現在状態（パケットの内容）
	STAT		cycstat		周期ハンドラの動作状態
	RELTIM		lefttim		次に周期ハンドラを起動する時刻までの相対時間
	ID			prcid		周期ハンドラの割付けプロセッサのID（マルチプ
							ロセッサ対応カーネルの場合）
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2464】
				・CPUロック状態からの呼出し【NGKI2465】
	E_ID		不正ID番号
				・cycidが有効範囲外【NGKI2466】
	E_NOEXS		オブジェクト未登録
				・対象周期ハンドラが未登録〔D〕【NGKI2467】
	E_OACV		オブジェクトアクセス違反
				・対象周期ハンドラに対する参照操作が許可されていない〔P〕
				　【NGKI2468】
	E_MACV		メモリアクセス違反
				・pk_rcycが指すメモリ領域への書込みアクセスが許可されて
				　いない）〔P〕【NGKI2469】
----

【機能】

cycidで指定した周期ハンドラ（対象周期ハンドラ）の現在状態を参照する．参
照した現在状態は，pk_rcycで指定したパケットに返される【NGKI2470】．

cycstatには，対象周期ハンドラの現在の動作状態を表す次のいずれかの値が返
される【NGKI2471】．

	TCYC_STP	0x01U		周期ハンドラが動作していない状態
	TCYC_STA	0x02U		周期ハンドラが動作している状態

対象周期ハンドラが動作している状態である場合には，lefttimに，次に周期ハ
ンドラ起動する時刻までの相対時間が返される【NGKI2472】．対象周期ハンド
ラが動作していない状態である場合には，lefttimの値は保証されない
【NGKI2473】．

マルチプロセッサ対応カーネルでは，prcidに，対象周期ハンドラの割付けプロ
セッサのID番号が返される【NGKI2474】．

【使用上の注意】

ref_cycはデバッグ時向けの機能であり，その他の目的に使用することは推奨し
ない．これは，ref_cycを呼び出し，対象周期ハンドラの現在状態を参照した直
後に割込みが発生した場合，ref_cycから戻ってきた時には対象周期ハンドラの
状態が変化している可能性があるためである．

【μITRON4.0仕様との関係】

TCYC_STPとTCYC_STAを値を変更した．


==== アラームハンドラ

アラームハンドラは，指定した相対時間後に起動されるタイムイベントハンド
ラである．アラームハンドラは，アラームハンドラIDと呼ぶID番号によって識
別する【NGKI2475】．

各アラームハンドラが持つ情報は次の通り【NGKI2476】．

* アラームハンドラ属性
* アラームハンドラの動作状態
* アラームハンドラを起動する時刻
* 拡張情報
* アラームハンドラの先頭番地
* アクセス許可ベクタ（保護機能対応カーネルの場合）
* 属する保護ドメイン（保護機能対応カーネルの場合）
* 属するクラス（マルチプロセッサ対応カーネルの場合）

アラームハンドラの動作状態は，動作している状態と動作していない状態のい
ずれかをとる【NGKI2477】．アラームハンドラを動作している状態にすること
を動作開始，動作していない状態にすることを動作停止という．

アラームハンドラを起動する時刻は，アラームハンドラを動作開始する時に設
定される【NGKI2478】．

アラームハンドラが動作している状態の場合には，アラームハンドラを起動す
る時刻になると，アラームハンドラの起動処理が行われる【NGKI2479】．具体
的には，まず，アラームハンドラが動作していない状態にされる【NGKI2480】．
その後に，拡張情報をパラメータとして，アラームハンドラが呼び出される
【NGKI2481】．

保護機能対応カーネルにおいて，アラームハンドラが属することのできる保護
ドメインは，カーネルドメインに限られる【NGKI2482】．

マルチプロセッサ対応カーネルでグローバルタイマ方式を用いている場合には，
アラームハンドラは，割付け可能プロセッサがシステム時刻管理プロセッサの
みであるクラスにのみ属することができる【NGKI2483】．すなわち，アラーム
ハンドラは，システム時刻管理プロセッサによって実行される．

アラームハンドラ属性に指定できる属性はない【NGKI3423】．そのためアラー
ムハンドラ属性には，TA_NULLを指定しなければならない【NGKI3424】．

C言語によるアラームハンドラの記述形式は次の通り【NGKI2484】．

[source,c]
----
	void alarm_handler(intptr_t exinf)
	{
		アラームハンドラ本体
	}
----

exinfには，アラームハンドラの拡張情報が渡される【NGKI2485】．

アラームハンドラ機能に関連するカーネル構成マクロは次の通り．

	TNUM_ALMID		登録できるアラームハンドラの数（動的生成対応でない
					カーネルでは，静的APIによって登録されたアラームハン
					ドラの数に一致）【NGKI2486】

【μITRON4.0仕様との関係】

TNUM_ALMIDは，μITRON4.0仕様に規定されていないカーネル構成マクロである．


[[API_CRE_ALM]]
----
CRE_ALM		アラームハンドラの生成〔S〕【NGKI2487】
acre_alm	アラームハンドラの生成〔TD〕【NGKI2488】
----

【静的API】
----
	CRE_ALM(ID almid, { ATR almatr, intptr_t exinf, ALMHDR almhdr })
----

【C言語API】
----
	ER_ID almid = acre_alm(const T_CALM *pk_calm)
----

【パラメータ】
----
	ID			almid		生成するアラームハンドラのID番号（CRE_ALM
							の場合）
	T_CALM *	pk_calm		アラームハンドラの生成情報を入れたパケット
							へのポインタ（静的APIを除く）

　＊アラームハンドラの生成情報（パケットの内容）
	ATR			almatr		アラームハンドラ属性
	intptr_t	exinf		アラームハンドラの拡張情報
	ALMHDR		almhdr		アラームハンドラの先頭番地
----

【リターンパラメータ】
----
	ER_ID		almid		生成されたアラームハンドラのID番号（正の値）
							またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI2489】
				・CPUロック状態からの呼出し〔s〕【NGKI2490】
	E_RSATR		予約属性
				・almatrが無効【NGKI2491】
				・属する保護ドメインの指定が有効範囲外またはカーネルド
				　メイン以外〔sP〕【NGKI2492】
				・カーネルドメインの囲みの中に記述されていない〔SP〕
				　【NGKI2493】
				・属するクラスの指定が有効範囲外〔sM〕【NGKI2494】
				・クラスの囲みの中に記述されていない〔SM〕【NGKI2495】
				・その他の条件については機能の項を参照
	E_PAR		パラメータエラー
				・almhdrがプログラムの先頭番地として正しくない【NGKI2496】
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する管理操作が許可されていない〔sP〕
				　【NGKI2497】
	E_MACV		メモリアクセス違反
				・pk_calmが指すメモリ領域への読出しアクセスが許可されて
				　いない〔sP〕【NGKI2498】
	E_NOID		ID番号不足
				・割り付けられるアラームハンドラIDがない〔sD〕【NGKI2499】
	E_OBJ		オブジェクト状態エラー
				・almidで指定したアラームハンドラが登録済み（CRE_ALMの
				　場合）【NGKI2500】
----

【機能】

各パラメータで指定したアラームハンドラ生成情報に従って，アラームハンド
ラを生成する．対象アラームハンドラは，動作していない状態に初期化される
【NGKI2501】．

静的APIにおいては，almidはオブジェクト識別名，almatrは整数定数式パラメー
タ，exinfとalmhdrは一般定数式パラメータである【NGKI2502】．

マルチプロセッサ対応カーネルでグローバルタイマ方式を用いている場合で，
生成するアラームハンドラの属するクラスの割付け可能プロセッサが，システ
ム時刻管理プロセッサのみでない場合には，E_RSATRエラーとなる【NGKI2503】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，CRE_ALMのみをサポートする【ASPS0179】．ただし，動的生
成機能拡張パッケージでは，acre_almもサポートする【ASPS0180】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，CRE_ALMのみをサポートする【FMPS0152】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，CRE_ALMのみをサポートする【HRPS0146】．ただし，動的生
成機能拡張パッケージでは，acre_almもサポートする【HRPS0205】．

【μITRON4.0仕様との関係】

almhdrのデータ型をALMHDRに変更した．


[[API_AID_ALM]]
----
AID_ALM		割付け可能なアラームハンドラIDの数の指定〔SD〕【NGKI2504】
----

【静的API】
----
	AID_ALM(uint_t noalm)
----

【パラメータ】
----
	uint_t		noalm		割付け可能なアラームハンドラIDの数
----

【エラーコード】
----
	E_RSATR		予約属性
				・保護ドメインの囲みの中に記述されている〔P〕【NGKI3438】
				・クラスの囲みの中に記述されていない〔M〕【NGKI2506】
				・その他の条件については機能の項を参照
	E_PAR		パラメータエラー
				・noalmが負の値【NGKI3286】
----

【機能】

noalmで指定した数のアラームハンドラIDを，アラームハンドラを生成するサー
ビスコールによって割付け可能なアラームハンドラIDとして確保する
【NGKI2507】．

noalmは整数定数式パラメータである【NGKI2508】．

マルチプロセッサ対応カーネルでグローバルタイマ方式を用いている場合で，
AID_ALMが属するクラスの割付け可能プロセッサが，システム時刻管理プロセッ
サのみでない場合には，E_RSATRエラーとなる【NGKI2509】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルの動的生成機能拡張パッケージでは，AID_ALMをサポートする
【ASPS0218】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルの動的生成機能拡張パッケージでは，AID_ALMをサポートする
【HRPS0219】．


[[API_SAC_ALM]]
----
SAC_ALM		アラームハンドラのアクセス許可ベクタの設定〔SP〕【NGKI2510】
sac_alm		アラームハンドラのアクセス許可ベクタの設定〔TPD〕【NGKI2511】
----

【静的API】
----
	SAC_ALM(ID almid, { ACPTN acptn1, ACPTN acptn2,
										ACPTN acptn3, ACPTN acptn4 })
----

【C言語API】
----
	ER ercd = sac_alm(ID almid, const ACVCT *p_acvct)
----

【パラメータ】
----
	ID			almid		対象アラームハンドラのID番号
	ACVCT *		p_acvct		アクセス許可ベクタを入れたパケットへのポ
							インタ（静的APIを除く）

　＊アクセス許可ベクタ（パケットの内容）
	ACPTN		acptn1		通常操作1のアクセス許可パターン
	ACPTN		acptn2		通常操作2のアクセス許可パターン
	ACPTN		acptn3		管理操作のアクセス許可パターン
	ACPTN		acptn4		参照操作のアクセス許可パターン
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI2512】
				・CPUロック状態からの呼出し〔s〕【NGKI2513】
	E_ID		不正ID番号
				・almidが有効範囲外〔s〕【NGKI2514】
	E_RSATR		予約属性
				・カーネルドメインの囲みの中に記述されていない〔S〕【NGKI2515】
				・対象アラームハンドラが属するクラスの囲みの中に記述さ
				　れていない〔SM〕【NGKI2516】
	E_NOEXS		オブジェクト未登録
				・対象アラームハンドラが未登録【NGKI2517】
	E_OACV		オブジェクトアクセス違反
				・対象アラームハンドラに対する管理操作が許可されていな
				　い〔s〕【NGKI2518】
	E_MACV		メモリアクセス違反
				・p_acvctが指すメモリ領域への読出しアクセスが許可されて
				　いない〔s〕【NGKI2519】
	E_OBJ		オブジェクト状態エラー
				・対象アラームハンドラは静的APIで生成された〔s〕【NGKI2520】
				・対象アラームハンドラに対してアクセス許可ベクタが設定
				　済み〔S〕【NGKI2521】
----

【機能】

almidで指定したアラームハンドラ（対象アラームハンドラ）のアクセス許可ベ
クタ（4つのアクセス許可パターンの組）を，各パラメータで指定した値に設定
する【NGKI2522】．

静的APIにおいては，almidはオブジェクト識別名，acptn1〜acptn4は整数定数
式パラメータである【NGKI2523】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，SAC_ALMのみをサポートする【HRPS0147】．ただし，動的生
成機能拡張パッケージでは，sac_almもサポートする【HRPS0206】．


[[API_del_alm]]
----
del_alm		アラームハンドラの削除〔TD〕【NGKI2524】
----

【C言語API】
----
	ER ercd = del_alm(ID almid)
----

【パラメータ】
----
	ID			almid		対象アラームハンドラのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2525】
				・CPUロック状態からの呼出し【NGKI2526】
	E_ID		不正ID番号
				・almidが有効範囲外【NGKI2527】
	E_NOEXS		オブジェクト未登録
				・対象アラームハンドラが未登録【NGKI2528】
	E_OACV		オブジェクトアクセス違反
				・対象アラームハンドラに対する管理操作が許可されていな
				　い〔P〕【NGKI2529】
	E_OBJ		オブジェクト状態エラー
				・対象アラームハンドラは静的APIで生成された【NGKI2530】
----

【機能】

almidで指定したアラームハンドラ（対象アラームハンドラ）を削除する．具体
的な振舞いは以下の通り．

対象アラームハンドラの登録が解除され，そのアラームハンドラIDが未使用の
状態に戻される【NGKI2531】．対象アラームハンドラが動作している状態であっ
た場合には，登録解除の前に，アラームハンドラが動作していない状態となる
【NGKI2532】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，del_almをサポートしない【ASPS0182】．ただし，動的生成
機能拡張パッケージでは，del_almをサポートする【ASPS0183】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，del_almをサポートしない【FMPS0154】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，del_almをサポートしない【HRPS0148】．ただし，動的生成
機能拡張パッケージでは，del_almをサポートする【HRPS0207】．


[[API_sta_alm]]
----
sta_alm		アラームハンドラの動作開始〔T〕【NGKI2533】
ista_alm	アラームハンドラの動作開始〔I〕【NGKI2534】
----

【C言語API】
----
	ER ercd = sta_alm(ID almid, RELTIM almtim)
	ER ercd = ista_alm(ID almid, RELTIM almtim)
----

【パラメータ】
----
	ID			almid		対象アラームハンドラのID番号
	RELTIM		almtim		アラームハンドラの起動時刻（相対時間）
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（sta_almの場合）【NGKI2535】
				・タスクコンテキストからの呼出し（ista_almの場合）【NGKI2536】
				・CPUロック状態からの呼出し
	E_ID		不正ID番号
				・almidが有効範囲外【NGKI2537】
	E_PAR		パラメータエラー
				・almtimがTMAX_RELTIMより大きい【NGKI2538】
	E_NOEXS		オブジェクト未登録
				・対象アラームハンドラが未登録〔D〕【NGKI2539】
	E_OACV		オブジェクトアクセス違反
				・対象アラームハンドラに対する通常操作1が許可されていな
				　い（sta_almの場合）〔P〕【NGKI2540】
----

【機能】

almidで指定したアラームハンドラ（対象アラームハンドラ）を動作開始する．
具体的な振舞いは以下の通り．

対象アラームハンドラが動作していない状態であれば，対象アラームハンドラ
は動作している状態となる【NGKI2541】．アラームハンドラを起動する時刻は，
sta_almを呼び出してから，almtimで指定した相対時間後に設定される
【NGKI2542】．

対象アラームハンドラが動作している状態であれば，アラームハンドラを起動
する時刻の再設定のみが行われる【NGKI2543】．


[[API_msta_alm]]
----
msta_alm	割付けプロセッサ指定でのアラームハンドラの動作開始〔TM〕【NGKI2544】
imsta_alm	割付けプロセッサ指定でのアラームハンドラの動作開始〔IM〕【NGKI2545】
----

【C言語API】
----
	ER ercd = msta_alm(ID almid, RELTIM almtim, ID prcid)
	ER ercd = imsta_alm(ID almid, RELTIM almtim, ID prcid)
----

【パラメータ】
----
	ID			almid		対象アラームハンドラのID番号
	RELTIM		almtim		アラームハンドラの起動時刻（相対時間）
	ID			prcid		アラームハンドラの割付け対象のプロセッサの
							ID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（msta_almの場合）
				　【NGKI2546】
				・タスクコンテキストからの呼出し（imsta_almの場合）【NGKI2547】
				・CPUロック状態からの呼出し【NGKI2548】
	E_NOSPT		未サポート機能
				・条件については機能の項を参照
	E_ID		不正ID番号
				・almidが有効範囲外【NGKI2549】
				・prcidが有効範囲外【NGKI2550】
	E_PAR		パラメータエラー
				・almtimがTMAX_RELTIMより大きい【NGKI2551】
				・その他の条件については機能の項を参照
	E_NOEXS		オブジェクト未登録
				・対象アラームハンドラが未登録〔D〕【NGKI2552】
	E_OACV		オブジェクトアクセス違反
				・対象アラームハンドラに対する通常操作1が許可されていな
				　い（msta_almの場合）〔P〕【NGKI2553】
----

【機能】

prcidで指定したプロセッサを割付けプロセッサとして，almidで指定したアラー
ムハンドラ（対象アラームハンドラ）を動作開始する．具体的な振舞いは以下
の通り．

対象アラームハンドラが動作していない状態であれば，対象アラームハンドラ
の割付けプロセッサがprcidで指定したプロセッサに変更された後，対象アラー
ムハンドラは動作している状態となる【NGKI2554】．アラームハンドラを起動
する時刻は，msta_almを呼び出してから，almtimで指定した相対時間後に設定
される【NGKI2555】．

対象アラームハンドラが動作している状態であれば，対象アラームハンドラの
割付けプロセッサがprcidで指定したプロセッサに変更された後，アラームハン
ドラを起動する時刻の再設定が行われる【NGKI2556】．

対象アラームハンドラが実行中である場合には，割付けプロセッサを変更して
も，実行中のアラームハンドラを実行するプロセッサは変更されない
【NGKI2557】．対象アラームハンドラが変更後の割付けプロセッサで実行され
るのは，次に起動される時からである【NGKI2558】．

対象アラームハンドラの属するクラスの割付け可能プロセッサが，prcidで指定
したプロセッサを含んでいない場合には，E_PARエラーとなる【NGKI2559】．

prcidにTPRC_INI（＝0）を指定すると，対象アラームハンドラの割付けプロセッ
サを，それが属するクラスの初期割付けプロセッサとする【NGKI2560】．

グローバルタイマ方式を用いている場合，msta_alm／imsta_almはE_NOSPTを返
す【NGKI2561】．

【使用上の注意】

msta_alm／imsta_almで実行中のアラームハンドラの割付けプロセッサを変更し
た場合，同じアラームハンドラが異なるプロセッサで同時に実行される可能性
がある．特に，almtimに0を指定する場合に，注意が必要である．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていないサービスコールである．


[[API_stp_alm]]
----
stp_alm		アラームハンドラの動作停止〔T〕【NGKI2562】
istp_alm	アラームハンドラの動作停止〔I〕【NGKI2563】
----

【C言語API】
----
	ER ercd = stp_alm(ID almid)
	ER ercd = istp_alm(ID almid)
----

【パラメータ】
----
	ID			almid		対象アラームハンドラのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（stp_almの場合）【NGKI2564】
				・タスクコンテキストからの呼出し（istp_almの場合）【NGKI2565】
				・CPUロック状態からの呼出し【NGKI2566】
	E_ID		不正ID番号
				・almidが有効範囲外【NGKI2567】
	E_NOEXS		オブジェクト未登録
				・対象アラームハンドラが未登録〔D〕【NGKI2568】
	E_OACV		オブジェクトアクセス違反
				・対象アラームハンドラに対する通常操作2が許可されていな
				　い（stp_almの場合）〔P〕【NGKI2569】
----

【機能】

almidで指定したアラームハンドラ（対象アラームハンドラ）を動作停止する．
具体的な振舞いは以下の通り．

対象アラームハンドラが動作している状態であれば，動作していない状態とな
る【NGKI2570】．対象アラームハンドラが動作していない状態であれば，何も
行われずに正常終了する【NGKI2571】．


[[API_ref_alm]]
----
ref_alm		アラームハンドラの状態参照〔T〕【NGKI2572】
----

【C言語API】
----
	ER ercd = ref_alm(ID almid, T_RALM *pk_ralm)
----

【パラメータ】
----
	ID			almid		対象アラームハンドラのID番号
	T_RALM *	pk_ralm		アラームハンドラの現在状態を入れるパケット
							へのポインタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード

　＊アラームハンドラの現在状態（パケットの内容）
	STAT		almstat		アラームハンドラの動作状態
	RELTIM		lefttim		アラームハンドラを起動する時刻までの相対時間
	ID			prcid		アラームハンドラの割付けプロセッサのID（マル
							チプロセッサ対応カーネルの場合）
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2573】
				・CPUロック状態からの呼出し【NGKI2574】
	E_ID		不正ID番号
				・almidが有効範囲外【NGKI2575】
	E_NOEXS		オブジェクト未登録
				・対象アラームハンドラが未登録〔D〕【NGKI2576】
	E_OACV		オブジェクトアクセス違反
				・対象アラームハンドラに対する参照操作が許可されていな
				　い〔P〕【NGKI2577】
	E_MACV		メモリアクセス違反
				・pk_ralmが指すメモリ領域への書込みアクセスが許可されて
				　いない〔P〕【NGKI2578】
----

【機能】

almidで指定したアラームハンドラ（対象アラームハンドラ）の現在状態を参照
する．参照した現在状態は，pk_ralmで指定したパケットに返される【NGKI2579】．

almstatには，対象アラームハンドラの現在の動作状態を表す次のいずれかの値
が返される【NGKI2580】．

	TALM_STP	0x01U		アラームハンドラが動作していない状態
	TALM_STA	0x02U		アラームハンドラが動作している状態

対象アラームハンドラが動作している状態である場合には，lefttimに，アラー
ムハンドラ起動する時刻までの相対時間が返される【NGKI2581】．対象アラー
ムハンドラが動作していない状態である場合には，lefttimの値は保証されない
【NGKI2582】．

マルチプロセッサ対応カーネルでは，prcidに，対象アラームハンドラの割付け
プロセッサのID番号が返される【NGKI2583】．

【使用上の注意】

ref_almはデバッグ時向けの機能であり，その他の目的に使用することは推奨し
ない．これは，ref_almを呼び出し，対象アラームハンドラの現在状態を参照し
た直後に割込みが発生した場合，ref_almから戻ってきた時には対象アラームハ
ンドラの状態が変化している可能性があるためである．

【μITRON4.0仕様との関係】

TALM_STPとTALM_STAを値を変更した．

==== オーバランハンドラ

オーバランハンドラは，タスクが使用したプロセッサ時間が，指定した時間を
超えた場合に起動されるタイムイベントハンドラである．オーバランハンドラ
は，システムで1つのみ登録することができる【NGKI2584】．

オーバランハンドラ機能に関連して，各タスクが持つ情報は次の通り
【NGKI2585】．

* オーバランハンドラの動作状態
* 残りプロセッサ時間

オーバランハンドラの動作状態は，タスク毎に，動作している状態と動作して
いない状態のいずれかをとる【NGKI2586】．残りプロセッサ時間は，オーバラ
ンハンドラが動作している状態の時に，タスクが使用できる残りのプロセッサ
時間を表す．

オーバランハンドラの動作状態は，タスクの登録時と，タスクが休止状態に遷
移する時に，動作していない状態に初期化される【NGKI2587】．

残りプロセッサ時間は，オーバランハンドラが動作している状態でタスクが実
行している間，タスクが使用したプロセッサ時間の分だけ減少する【NGKI2588】．
残りプロセッサ時間が0になると（これをオーバランと呼ぶ），オーバランハン
ドラが起動される【NGKI2589】．

タスクが使用したプロセッサ時間には，そのタスク自身とタスク例外処理ルー
チン，それらから呼び出したサービルコール（拡張サービスコールを含む）の
実行時間を含む【NGKI2590】．一方，タスクの実行中に起動されたカーネル管
理の割込みハンドラ（割込みサービスルーチン，周期ハンドラ，アラームハン
ドラ，オーバランハンドラの実行時間を含む）とカーネル管理のCPU例外ハンド
ラの実行時間は含まないが，割込みハンドラおよびCPU例外ハンドラの呼出し／
復帰にかかる時間と，それらの入口処理と出口処理の一部の実行時間は含んで
しまう【NGKI2591】．また，タスクの実行中に起動されたカーネル管理外の割
込みハンドラとカーネル管理外のCPU例外ハンドラの実行時間も含む
【NGKI2592】．

プロセッサ時間は，符号無しの整数型であるOVRTIM型で表し，単位はマイクロ
秒とする【NGKI2593】．ただし，プロセッサ時間には，OVRTIM型に格納できる
任意の値を指定できるとは限らず，指定できる値にターゲット定義の上限があ
る場合がある【NGKI2594】．プロセッサ時間に指定できる最大値は，構成マク
ロTMAX_OVRTIMに定義されている【NGKI2595】．また，タスクが使用したプロセッ
サ時間の計測精度はターゲットに依存する【NGKI2596】．

保護機能対応カーネルにおいて，オーバランハンドラは，カーネルドメインに
属する【NGKI2597】．

ターゲット定義で，オーバランハンドラ機能がサポートされていない場合があ
る【NGKI2598】．オーバランハンドラ機能がサポートされている場合には，
TOPPERS_SUPPORT_OVRHDRがマクロ定義される【NGKI2599】．サポートされてい
ない場合にオーバランハンドラ機能のサービスコールを呼び出すと，E_NOSPTエ
ラーが返るか，リンク時にエラーとなる【NGKI2600】．

オーバランハンドラ機能に用いるデータ型は次の通り．

	OVRTIM		プロセッサ時間（符号無し整数，単位はマイクロ秒，ulong_t
				に定義）【NGKI2601】

オーバランハンドラ属性に指定できる属性はない【NGKI2602】．そのためオー
バランハンドラ属性には，TA_NULLを指定しなければならない【NGKI2603】．

C言語によるオーバランハンドラの記述形式は次の通り【NGKI2604】．

[source,c]
----
	void overrun_handler(ID tskid, intptr_t exinf)
	{
		オーバランハンドラ本体
	}
----

tskidにはオーバランを起こしたタスクのID番号が，exinfにはそのタスクの拡
張情報が，それぞれ渡される【NGKI2605】．

オーバランハンドラ機能に関連するカーネル構成マクロは次の通り．

	TMAX_OVRTIM		プロセッサ時間に指定できる最大値【NGKI2606】

	TOPPERS_SUPPORT_OVRHDR		オーバランハンドラ機能がサポートされて
								いる【NGKI2607】

【使用上の注意】

マルチプロセッサ対応カーネルでは，オーバランハンドラが異なるプロセッサ
で同時に実行される可能性があるので，注意が必要である．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，オーバランハンドラをサポートしない【ASPS0184】．ただし，
オーバランハンドラ機能拡張パッケージを用いると，オーバランハンドラ機能
を追加することができる【ASPS0185】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，オーバランハンドラをサポートしない【FMPS0155】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，オーバランハンドラをサポートする【HRPS0149】．

【μITRON4.0仕様との関係】

OVRTIMの時間単位は，μITRON4.0仕様では実装定義としていたが，この仕様で
はマイクロ秒と規定した．

TMAX_OVRTIMは，μITRON4.0仕様に規定されていないカーネル構成マクロである．


[[API_DEF_OVR]]
----
DEF_OVR		オーバランハンドラの定義〔S〕【NGKI2608】
def_ovr		オーバランハンドラの定義〔TD〕【NGKI2609】
----

【静的API】
----
	DEF_OVR({ ATR ovratr, OVRHDR ovrhdr })
----

【C言語API】
----
	ER ercd = def_ovr(const T_DOVR *pk_dovr)
----

【パラメータ】
----
	T_DOVR *	pk_dovr		オーバランハンドラの定義情報を入れたパケッ
							トへのポインタ（静的APIを除く）

　＊オーバランハンドラの定義情報（パケットの内容）
	ATR			ovratr		オーバランハンドラ属性
	OVRHDR		ovrhdr		オーバランハンドラの先頭番地
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI2610】
				・CPUロック状態からの呼出し〔s〕【NGKI2611】
	E_RSATR		予約属性
				・ovratrが無効【NGKI2612】
				・その他の条件については機能の項を参照
	E_PAR		パラメータエラー
				・ovrhdrがプログラムの先頭番地として正しくない【NGKI2613】
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する管理操作が許可されていない〔sP〕
				　【NGKI2614】
	E_MACV		メモリアクセス違反
				・pk_dovrが指すメモリ領域への読出しアクセスが許可されて
				　いない〔sP〕【NGKI2615】
	E_OBJ		オブジェクト状態エラー
				・条件については機能の項を参照
----

【機能】

各パラメータで指定したオーバランハンドラ定義情報に従って，オーバランハ
ンドラを定義する【NGKI2616】．ただし，def_ovrにおいてpk_dovrをNULLにし
た場合には，オーバランハンドラの定義を解除する【NGKI2617】．

静的APIにおいては，ovratrは整数定数式パラメータ，ovrhdrは一般定数式パラ
メータである【NGKI2618】．

オーバランハンドラを定義する場合（DEF_OVRの場合およびdef_ovrにおいて
pk_dovrをNULL以外にした場合）で，すでにオーバランハンドラが定義されてい
る場合には，E_OBJエラーとなる【NGKI2619】．

保護機能対応カーネルにおいて，DEF_OVRは，カーネルドメインの囲みの中に記
述しなければならない．そうでない場合には，E_RSATRエラーとなる
【NGKI2621】．また，def_ovrでオーバランハンドラを定義する場合には，オー
バランハンドラの属する保護ドメインを設定する必要はなく，オーバランハン
ドラ属性にTA_DOM(domid)を指定した場合にはE_RSATRエラーとなる【NGKI2622】．
ただし，TA_DOM(TDOM_SELF)を指定した場合には，指定が無視され，E_RSATRエ
ラーは検出されない【NGKI2623】．

マルチプロセッサ対応カーネルでは，DEF_OVRは，クラスの囲みの外に記述しな
ければならない．そうでない場合には，E_RSATRエラーとなる【NGKI2625】．ま
た，def_ovrオーバランハンドラを定義する場合には，オーバランハンドラの属
するクラスを設定する必要はなく，オーバランハンドラ属性にTA_CLS(clsid)を
指定した場合にはE_RSATRエラーとなる【NGKI2626】．ただし，
TA_CLS(TCLS_SELF)を指定した場合には，指定が無視され，E_RSATRエラーは検
出されない【NGKI2627】．

オーバランハンドラの定義を解除する場合（def_ovrにおいてpk_dovrをNULLに
した場合）で，オーバランハンドラが定義されていない場合には，E_OBJエラー
となる【NGKI2628】．

オーバランハンドラの定義を解除すると，オーバランハンドラの動作状態は，
すべてのタスクに対して動作していない状態となる【NGKI2629】．

【使用上の注意】

def_ovrによりオーバランハンドラの定義を解除する場合，サービスコールの処
理時間およびカーネル内での割込み禁止時間が，タスクの総数に比例して長く
なる．特に，タスクの総数が多い場合，カーネル内での割込み禁止時間が長く
なるため，注意が必要である．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルのオーバランハンドラ機能拡張パッケージでは，DEF_OVRのみをサ
ポートする【ASPS0186】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，DEF_OVRのみをサポートする【HRPS0150】．

【μITRON4.0仕様との関係】

ovrhdrのデータ型をOVRHDRに変更した．

def_ovrによって定義済みのオーバランハンドラを再定義しようとした場合に，
E_OBJエラーとすることにした．オーバランハンドラの定義を変更するには，一
度定義を解除してから，再度定義する必要がある．


[[API_sta_ovr]]
----
sta_ovr		オーバランハンドラの動作開始〔T〕【NGKI2630】
ista_ovr	オーバランハンドラの動作開始〔I〕【NGKI2631】
----

【C言語API】
----
	ER ercd = sta_ovr(ID tskid, OVRTIM ovrtim)
	ER ercd = ista_ovr(ID tskid, OVRTIM ovrtim)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
	OVRTIM		ovrtim		対象タスクの残りプロセッサ時間
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（sta_ovrの場合）【NGKI2632】
				・タスクコンテキストからの呼出し（ista_ovrの場合）【NGKI2633】
				・CPUロック状態からの呼出し【NGKI2634】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI2635】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録〔D〕【NGKI2636】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する通常操作2が許可されていない（sta_ovr
				　の場合）〔P〕【NGKI2637】
	E_PAR		パラメータエラー
				・ovrtimが0，またはTMAX_OVRTIMより大きい【NGKI2643】
	E_OBJ		オブジェクト状態エラー
				・オーバランハンドラが定義されていない【NGKI2638】
----

【機能】

tskidで指定したタスク（対象タスク）に対して，オーバランハンドラの動作を
開始する．具体的な振舞いは以下の通り．

対象タスクに対するオーバランハンドラの動作状態は，動作している状態とな
り，残りプロセッサ時間は，ovrtimに指定した時間に設定される【NGKI2639】．
対象タスクに対してオーバランハンドラが動作している状態であれば，残りプ
ロセッサ時間の設定のみが行われる【NGKI2640】．

sta_ovrにおいてtskidにTSK_SELF（＝0）を指定すると，自タスクが対象タスク
となる【NGKI2641】．

【μITRON4.0仕様との関係】

ista_ovrは，μITRON4.0仕様に定義されていないサービスコールである．

[[API_stp_ovr]]
----
stp_ovr		オーバランハンドラの動作停止〔T〕【NGKI2644】
istp_ovr	オーバランハンドラの動作停止〔I〕【NGKI2645】
----

【C言語API】
----
	ER ercd = stp_ovr(ID tskid)
	ER ercd = istp_ovr(ID tskid)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（stp_ovrの場合）【NGKI2646】
				・タスクコンテキストからの呼出し（istp_ovrの場合）【NGKI2647】
				・CPUロック状態からの呼出し【NGKI2648】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI2649】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録〔D〕【NGKI2650】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する通常操作2が許可されていない（stp_ovr
				　の場合）〔P〕【NGKI2651】
	E_OBJ		オブジェクト状態エラー
				・オーバランハンドラが定義されていない【NGKI2652】
----

【機能】

tskidで指定したタスク（対象タスク）に対して，オーバランハンドラの動作を
停止する．具体的な振舞いは以下の通り．

対象タスクに対するオーバランハンドラの動作状態は，動作していない状態と
なる【NGKI2653】．対象タスクに対してオーバランハンドラが動作していない
状態であれば，何も行われずに正常終了する【NGKI2654】．

stp_ovrにおいてtskidにTSK_SELF（＝0）を指定すると，自タスクが対象タスク
となる【NGKI2655】．

【μITRON4.0仕様との関係】

istp_ovrは，μITRON4.0仕様に定義されていないサービスコールである．


[[API_ref_ovr]]
----
ref_ovr		オーバランハンドラの状態参照〔T〕【NGKI2656】
----

【C言語API】
----
	ER ercd = ref_ovr(ID tskid, T_ROVR *pk_rovr)
----

【パラメータ】
----
	ID			tskid		対象タスクのID番号
	T_ROVR *	pk_rovr		オーバランハンドラの現在状態を入れるパケッ
							トへのポインタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード

　＊タスクの現在状態（パケットの内容）
	STAT		ovrstat		オーバランハンドラの動作状態
	OVRTIM		leftotm		残りプロセッサ時間
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2657】
				・CPUロック状態からの呼出し【NGKI2658】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI2659】
	E_NOEXS		オブジェクト未登録
				・対象タスクが未登録〔D〕【NGKI2660】
	E_OACV		オブジェクトアクセス違反
				・対象タスクに対する参照操作が許可されていない〔P〕【NGKI2661】
	E_MACV		メモリアクセス違反
				・pk_rovrが指すメモリ領域への書込みアクセスが許可されて
				　いない〔P〕【NGKI2662】
	E_OBJ		オブジェクト状態エラー
				・オーバランハンドラが定義されていない【NGKI2663】
----

【機能】

tskidで指定したタスク（対象タスク）に対するオーバランハンドラの現在状態
を参照する．参照した現在状態は，pk_rovrで指定したメモリ領域に返される
【NGKI2664】．

ovrstatには，対象タスクに対するオーバランハンドラの動作状態を表す次のい
ずれかの値が返される【NGKI2665】．

	TOVR_STP	0x01U		オーバランハンドラが動作していない状態
	TOVR_STA	0x02U		オーバランハンドラが動作している状態

対象タスクに対してオーバランハンドラが動作している状態の場合には，
leftotmに，オーバランハンドラが起動されるまでの残りプロセッサ時間が返さ
れる【NGKI2666】．オーバランハンドラが起動される直前には，leftotmに0が
返される可能性がある【NGKI2667】．オーバランハンドラが動作していない状
態の場合には，leftotmの値は保証されない【NGKI2668】．

tskidにTSK_SELF（＝0）を指定すると，自タスクが対象タスクとなる
【NGKI2669】．

【使用上の注意】

ref_ovrはデバッグ時向けの機能であり，その他の目的に使用することは推奨し
ない．これは，ref_ovrを呼び出し，対象オーバランハンドラの現在状態を参照
した直後に割込みが発生した場合，ref_ovrから戻ってきた時には対象オーバラ
ンハンドラの状態が変化している可能性があるためである．

【未決定事項】

マルチプロセッサ対応カーネルにおいて，対象タスクが，自タスクが割付けら
れたプロセッサと異なるプロセッサに割り付けられている場合に，leftotmを参
照できるとするかどうかは，今後の課題である．

【μITRON4.0仕様との関係】

TOVR_STPとTOVR_STAを値を変更した．

=== システム状態管理機能

システム状態管理機能は，特定のオブジェクトに関連しないシステムの状態を
変更／参照するための機能である．

[[API_SAC_SYS]]
----
SAC_SYS		システム状態のアクセス許可ベクタの設定〔SP〕【NGKI2670】
sac_sys		システム状態のアクセス許可ベクタの設定〔TPD〕【NGKI2671】
----

【静的API】
----
	SAC_SYS({ ACPTN acptn1, ACPTN acptn2, ACPTN acptn3, ACPTN acptn4 })
----

【C言語API】
----
	ER ercd = sac_sys(const ACVCT *p_acvct)
----

【パラメータ】
----
	ACVCT *		p_acvct		アクセス許可ベクタを入れたパケットへのポ
							インタ（静的APIを除く）

　＊アクセス許可ベクタ（パケットの内容）
	ACPTN		acptn1		通常操作1のアクセス許可パターン
	ACPTN		acptn2		通常操作2のアクセス許可パターン
	ACPTN		acptn3		管理操作のアクセス許可パターン
	ACPTN		acptn4		参照操作のアクセス許可パターン
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI2672】
				・CPUロック状態からの呼出し〔s〕【NGKI2673】
	E_RSATR		予約属性
				・カーネルドメインの囲みの中に記述されていない〔S〕【NGKI2674】
				・クラスの囲みの中に記述されている〔SM〕【NGKI2675】
	E_OACV		オブジェクトアクセス違反
				・カーネルドメイン以外からの呼出し〔s〕【NGKI2676】
	E_OBJ		オブジェクト状態エラー
				・システム状態のアクセス許可ベクタが設定済み〔S〕【NGKI2677】
----

【機能】

システム状態のアクセス許可ベクタ（4つのアクセス許可パターンの組）を，各
パラメータで指定した値に設定する【NGKI2678】．

静的APIにおいては，acptn1〜acptn4は整数定数式パラメータである【NGKI2679】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，SAC_SYSのみをサポートする【HRPS0151】．

[[API_rot_rdq]]
----
rot_rdq		タスクの優先順位の回転〔T〕【NGKI2680】
irot_rdq	タスクの優先順位の回転〔I〕【NGKI2681】
----

【C言語API】
----
	ER ercd = rot_rdq(PRI tskpri)
	ER ercd = irot_rdq(PRI tskpri)
----

【パラメータ】
----
	PRI	　		tskpri		回転対象の優先度（対象優先度）
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（rot_rdqの場合）【NGKI2682】
				・タスクコンテキストからの呼出し（irot_rdqの場合）【NGKI2683】
				・CPUロック状態からの呼出し【NGKI2684】
	E_NOSPT		未サポート機能
				・条件については機能の項を参照
	E_PAR		パラメータエラー
				・tskpriが有効範囲外【NGKI2685】
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する通常操作1が許可されていない（rot_rdq
				　の場合）〔P〕【NGKI2686】
----

【機能】

tskpriで指定した優先度（対象優先度）を持つ実行できる状態のタスクの中で，
最も優先順位が高いタスクを，同じ優先度のタスクの中で最も優先順位が低い
状態にする【NGKI2687】．対象優先度を持つ実行できる状態のタスクが無いか
1つのみの場合には，何も行われずに正常終了する【NGKI2688】．

マルチプロセッサ対応カーネルにおいては，自タスクと同じプロセッサに割り
付けられているタスクのみを操作対象とする【NGKI3622】．

rot_rdqにおいて，tskpriにTPRI_SELF（＝0）を指定すると，自タスクのベース
優先度が対象優先度となる【NGKI2689】．

対象優先度を持つ実行できる状態のタスクの中で，最も優先順位が高いタスク
が制約タスクの場合には，E_NOSPTエラーとなる【NGKI2690】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，rot_rdq，irot_rdqをサポートしない【SSPS0131】．


[[API_mrot_rdq]]
----
mrot_rdq	プロセッサ指定でのタスクの優先順位の回転〔TM〕【NGKI2691】
imrot_rdq	プロセッサ指定でのタスクの優先順位の回転〔IM〕【NGKI2692】
----

【C言語API】
----
	ER ercd = mrot_rdq(PRI tskpri, ID prcid)
	ER ercd = imrot_rdq(PRI tskpri, ID prcid)
----

【パラメータ】
----
	PRI			tskpri		回転対象の優先度（対象優先度）
	ID			prcid		優先順位の回転対象とするプロセッサのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（mrot_rdqの場合）
				　【NGKI2693】
				・タスクコンテキストからの呼出し（imrot_rdqの場合）【NGKI2694】
				・CPUロック状態からの呼出し【NGKI2695】
	E_NOSPT		未サポート機能
				・条件については機能の項を参照
	E_ID		不正ID番号
				・prcidが有効範囲外【NGKI2696】
	E_PAR		パラメータエラー
				・tskpriが有効範囲外【NGKI2697】
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する通常操作1が許可されていない（mrot_rdq
				　の場合）〔P〕【NGKI2698】
----

【機能】

prcidで指定したプロセッサに割り付けられており，tskpriで指定した優先度
（対象優先度）を持つ実行できる状態のタスクの中で，最も優先順位が高いタ
スクを，同じ優先度のタスクの中で最も優先順位が低い状態にする【NGKI2699】．
対象優先度を持つ実行できる状態のタスクが無いか1つのみの場合には，何も行
われずに正常終了する【NGKI2700】．

mrot_rdqにおいて，tskpriにTPRI_SELF（＝0）を指定すると，自タスクのベー
ス優先度が対象優先度となる【NGKI2701】．

prcidで指定したプロセッサに割り付けられており，対象優先度を持つ実行でき
る状態のタスクの中で，最も優先順位が高いタスクが制約タスクの場合には，
E_NOSPTエラーとなる【NGKI2702】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，mrot_rdq，imrot_rdqをサポートしない【ASPS0188】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，mrot_rdq，imrot_rdqをサポートしない【HRPS0152】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，mrot_rdq，imrot_rdqをサポートしない【SSPS0132】．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていないサービスコールである．


[[API_get_tid]]
----
get_tid		実行状態のタスクIDの参照〔T〕【NGKI2703】
iget_tid	実行状態のタスクIDの参照〔I〕【NGKI2704】
----

【C言語API】
----
	ER ercd = get_tid(ID *p_tskid)
	ER ercd = iget_tid(ID *p_tskid)
----

【パラメータ】
----
	ID *		p_tskid		タスクIDを入れるメモリ領域へのポインタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
	ID			tskid		タスクID
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（get_tidの場合）【NGKI2705】
				・タスクコンテキストからの呼出し（iget_tidの場合）【NGKI2706】
				・CPUロック状態からの呼出し【NGKI2707】
	E_MACV		メモリアクセス違反
				・p_tskidが指すメモリ領域への書込みアクセスが許可されて
				　いない（get_tidの場合）〔P〕【NGKI2708】
----

【機能】

実行状態のタスク（get_tidの場合には自タスク）のID番号を参照する．参照し
たタスクIDは，p_tskidが指すメモリ領域に返される【NGKI2709】．

iget_tidにおいて，実行状態のタスクがない場合には，TSK_NONE（＝0）が返さ
れる【NGKI2710】．

マルチプロセッサ対応カーネルにおいては，サービスコールを呼び出した処理
単位を実行しているプロセッサにおいて実行状態のタスクのID番号を参照する
【NGKI2711】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，get_tidをサポートしない【SSPS0133】．

[[API_get_did]]
----
get_did		実行状態のタスクが属する保護ドメインIDの参照〔TP〕【NGKI2712】
----

【C言語API】
----
	ER ercd = get_did(ID *p_domid)
----

【パラメータ】
----
	ID *		p_domid		保護ドメインIDを入れるメモリ領域へのポインタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
	ID			domid		保護ドメインID
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2713】
				・CPUロック状態からの呼出し【NGKI2714】
	E_MACV		メモリアクセス違反
				・p_domidが指すメモリ領域への書込みアクセスが許可されて
				　いない【NGKI2715】
----

【機能】

実行状態のタスク（自タスク）が属する保護ドメインのID番号を参照する．参
照した保護ドメインIDは，p_domidが指すメモリ領域に返される【NGKI2716】．

マルチプロセッサ対応カーネルにおいては，サービスコールを呼び出した処理
単位を実行しているプロセッサにおいて実行状態のタスクが属する保護ドメイ
ンのID番号を参照する【NGKI2717】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，get_didをサポートしない【ASPS0189】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，get_didをサポートしない【FMPS0157】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，get_didをサポートしない【SSPS0134】．

[[API_get_pid]]
----
get_pid		割付けプロセッサのID番号の参照〔TM〕【NGKI2718】
iget_pid	割付けプロセッサのID番号の参照〔IM〕【NGKI2719】
----

【C言語API】
----
	ER ercd = get_pid(ID *p_prcid)
	ER ercd = iget_pid(ID *p_prcid)
----

【パラメータ】
----
	ID *		p_prcid		プロセッサIDを入れるメモリ領域へのポインタ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
	ID			prcid		プロセッサID
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（get_pidの場合）【NGKI2720】
				・タスクコンテキストからの呼出し（iget_pidの場合）【NGKI2721】
				・CPUロック状態からの呼出し【NGKI2722】
	E_MACV		メモリアクセス違反
				・p_prcidが指すメモリ領域への書込みアクセスが許可されて
				　いない（get_pidの場合）〔P〕【NGKI2723】
----

【機能】

サービスコールを呼び出した処理単位の割付けプロセッサのID番号を参照する．
参照したプロセッサIDは，p_prcidが指すメモリ領域に返される
【NGKI2724】．

【使用上の注意】

タスクは，get_pidを用いて，自タスクの割付けプロセッサを正しく参照できる
とは限らない．これは，get_pidを呼び出し，自タスクの割付けプロセッサの
ID番号を参照した直後に割込みが発生した場合，get_pidから戻ってきた時には
割付けプロセッサが変化している可能性があるためである．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，get_pid，iget_pidをサポートしない【ASPS0190】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，get_pid，iget_pidをサポートしない【HRPS0153】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，get_pid，iget_pidをサポートしない【SSPS0135】．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていないサービスコールである．


[[API_loc_cpu]]
----
loc_cpu		CPUロック状態への遷移〔T〕【NGKI2725】
iloc_cpu	CPUロック状態への遷移〔I〕【NGKI2726】
----

【C言語API】
----
	ER ercd = loc_cpu()
	ER ercd = iloc_cpu()
----

【パラメータ】
----
	なし
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（loc_cpuの場合）【NGKI2727】
				・タスクコンテキストからの呼出し（iloc_cpuの場合）【NGKI2728】
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する通常操作2が許可されていない
				　（loc_cpuの場合）〔P〕【NGKI2729】
----

【機能】

CPUロックフラグをセットし，CPUロック状態へ遷移する【NGKI2730】．CPUロッ
ク状態で呼び出した場合には，何も行われずに正常終了する【NGKI2731】．

[[API_unl_cpu]]
----
unl_cpu		CPUロック状態の解除〔T〕【NGKI2732】
iunl_cpu	CPUロック状態の解除〔I〕【NGKI2733】
----

【C言語API】
----
	ER ercd = unl_cpu()
	ER ercd = iunl_cpu()
----

【パラメータ】
----
	なし
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し（unl_cpuの場合）【NGKI2734】
				・タスクコンテキストからの呼出し（iunl_cpuの場合）【NGKI2735】
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する通常操作2が許可されていない
				　（unl_cpuの場合）〔P〕【NGKI2736】
----

【機能】

CPUロックフラグをクリアし，CPUロック解除状態へ遷移する【NGKI2737】．
CPUロック解除状態で呼び出した場合には，何も行われずに正常終了する
【NGKI2738】．

マルチプロセッサ対応カーネルにおいて，unl_cpu／iunl_cpuを呼び出したプロ
セッサによって取得されている状態となっているスピンロックがある場合には，
unl_cpu／iunl_cpuによってCPUロック解除状態に遷移しない（何も行われずに
正常終了する）【NGKI2739】．

【補足説明】

マルチプロセッサ対応カーネルでは，CPUロック解除状態へ遷移した結果，ディ
スパッチ保留状態が解除され，ディスパッチが起こる可能性がある．また，保
護機能対応カーネルとマルチプロセッサ対応カーネルでは，タスク例外処理ルー
チンの実行が開始される可能性がある．

[[API_dis_dsp]]
----
dis_dsp		ディスパッチの禁止〔T〕【NGKI2740】
----

【C言語API】
----
	ER ercd = dis_dsp()
----

【パラメータ】
----
	なし
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2741】
				・CPUロック状態からの呼出し【NGKI2742】
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する通常操作1が許可されていない〔P〕
				　【NGKI2743】
----

【機能】

ディスパッチ禁止フラグをセットし，ディスパッチ禁止状態へ遷移する
【NGKI2744】．ディスパッチ禁止状態で呼び出した場合には，何も行われずに
正常終了する【NGKI2745】．

[[API_ena_dsp]]
----
ena_dsp		ディスパッチの許可〔T〕【NGKI2746】
----

【C言語API】
----
	ER ercd = ena_dsp()
----

【パラメータ】
----
	なし
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2747】
				・CPUロック状態からの呼出し【NGKI2748】
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する通常操作1が許可されていない〔P〕
				　【NGKI2749】
----

【機能】

ディスパッチ禁止フラグをクリアし，ディスパッチ許可状態へ遷移する
【NGKI2750】．ディスパッチ許可状態で呼び出した場合には，何も行われずに
正常終了する【NGKI2751】．

【補足説明】

ディスパッチ許可状態へ遷移した結果，ディスパッチ保留状態が解除され，ディ
スパッチが起こる可能性がある．

[[API_sns_ctx]]
----
sns_ctx		コンテキストの参照〔TI〕【NGKI2752】
----

【C言語API】
----
	bool_t state = sns_ctx()
----

【パラメータ】
----
	なし
----

【リターンパラメータ】
----
	bool_t	state		コンテキスト
----

【機能】

実行中のコンテキストを参照する．具体的な振舞いは以下の通り．

sns_ctxを非タスクコンテキストから呼び出した場合にはtrue，タスクコンテキ
ストから呼び出した場合にはfalseが返る【NGKI2753】．


[[API_sns_loc]]
----
sns_loc		CPUロック状態の参照〔TI〕【NGKI2754】
----

【C言語API】
----
	bool_t state = sns_loc()
----

【パラメータ】
----
	なし
----

【リターンパラメータ】
----
	bool_t	state		CPUロックフラグ
----

【機能】

CPUロックフラグを参照する．具体的な振舞いは以下の通り．

sns_locをCPUロック状態で呼び出した場合にはtrue，CPUロック解除状態で呼び
出した場合にはfalseが返る【NGKI2755】．


[[API_sns_dsp]]
----
sns_dsp		ディスパッチ禁止状態の参照〔TI〕【NGKI2756】
----

【C言語API】
----
	bool_t state = sns_dsp()
----

【パラメータ】
----
	なし
----

【リターンパラメータ】
----
	bool_t	state		ディスパッチ禁止フラグ
----

【機能】

ディスパッチ禁止フラグを参照する．具体的な振舞いは以下の通り．

sns_dspをディスパッチ禁止状態で呼び出した場合にはtrue，ディスパッチ許可
状態で呼び出した場合にはfalseが返る【NGKI2757】．


[[API_sns_dpn]]
----
sns_dpn		ディスパッチ保留状態の参照〔TI〕【NGKI2758】
----

【C言語API】
----
	bool_t state = sns_dpn()
----

【パラメータ】
----
	なし
----

【リターンパラメータ】
----
	bool_t	state		ディスパッチ保留状態
----

【機能】

ディスパッチ保留状態であるか否かを参照する．具体的な振舞いは以下の通り．

sns_dpnをディスパッチ保留状態で呼び出した場合にはtrue，ディスパッチ保留
状態でない状態で呼び出した場合にはfalseが返る【NGKI2759】．


[[API_sns_ker]]
----
sns_ker		カーネル非動作状態の参照〔TI〕【NGKI2760】
----

【C言語API】
----
	bool_t state = sns_ker()
----

【パラメータ】
----
	なし
----

【リターンパラメータ】
----
	bool_t		state		カーネル非動作状態
----

【機能】

カーネルが動作中であるか否かを参照する．具体的な振舞いは以下の通り．

sns_kerをカーネルの初期化完了前（初期化ルーチン実行中を含む）または終了
処理開始後（終了処理ルーチン実行中を含む）に呼び出した場合にはtrue，カー
ネルの動作中に呼び出した場合にはfalseが返る【NGKI2761】．

【使用方法】

sns_kerは，カーネルが動作している時とそうでない時で，処理内容を変えたい
場合に使用する．sns_kerがtrueを返した場合，他のサービスコールを呼び出す
ことはできない．sns_kerがtrueを返す時に他のサービスコールを呼び出した場
合の動作は保証されない．

【使用上の注意】

どちらの条件でtrueが返るか間違いやすいので注意すること．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていないサービスコールである．


[[API_ext_ker]]
----
ext_ker		カーネルの終了〔TI〕【NGKI2762】
----

【C言語API】
----
	ER ercd = ext_ker()
----

【パラメータ】
----
	なし
----

【リターンパラメータ】
----
	ER			ercd		エラーコード
----

【エラーコード】
----
	E_SYS		システムエラー
				・カーネルの誤動作【NGKI2763】
	E_OACV		オブジェクトアクセス違反
				・カーネルドメイン以外からの呼出し〔P〕【NGKI2764】
----

【機能】

カーネルを終了する．具体的な振舞いについては，「2.9.2 システム終了手順」
の節を参照すること．

ext_kerが正常に処理された場合，ext_kerからはリターンしない【NGKI2765】．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていないサービスコールである．


[[API_ref_sys]]
----
ref_sys		システムの状態参照〔T〕
----

【C言語API】
----
	ER ercd = ref_sys(T_RSYS *pk_rsys)
----

☆未完成

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，ref_sysをサポートしない．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，ref_sysをサポートしない．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，ref_sysをサポートしない．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，ref_sysをサポートしない．


=== メモリオブジェクト管理機能

メモリオブジェクト管理機能は，保護機能対応カーネルでのみサポートされる
機能である．保護機能対応でないカーネルでは，メモリオブジェクト管理機能
をサポートしない．

〔メモリリージョン〕

メモリリージョンは，オブジェクトモジュールに含まれるセクションの配置対
象となる同じ性質を持った連続したメモリ領域である．メモリリージョンは，
メモリリージョン名によって識別する【NGKI2766】．

各メモリリージョンが持つ情報は次の通り【NGKI2767】．

* 先頭番地
* サイズ
* メモリリージョン属性

メモリリージョンの先頭番地とサイズには，ターゲット定義の制約が課せられ
る場合がある【NGKI2768】．

メモリリージョン属性には，次の属性を指定することができる【NGKI3256】．

	TA_NOWRITE	0x01U	書込みアクセス禁止

ターゲットによっては，ターゲット定義のメモリリージョン属性を指定できる
場合がある【NGKI2771】．

標準メモリリージョンとは，ATT_MOD／ATA_MODによって，オブジェクトモジュー
ルに含まれる標準のセクションが配置されるメモリリージョンである．標準メ
モリリージョンには，標準のセクションの中で，書込みアクセスを行わないも
のが配置される標準ROMリージョンと，書込みアクセスを行うものが配置される
標準RAMリージョンが含まれる．

マルチプロセッサ対応カーネルでは，ATT_MOD／ATA_MODがクラスの囲みの外に
記述された場合に適用される共通の標準メモリリージョンに加えて，クラス毎
の標準メモリリージョンを定義することができる【NGKI3257】．

標準メモリリージョン（マルチプロセッサ対応カーネルでは，共通の標準メモ
リリージョン）は，必ず定義しなければならない．定義しない場合には，コン
フィギュレータがエラーを報告する【NGKI3259】．

〔メモリオブジェクト〕

メモリオブジェクトは，保護機能対応カーネルにおいてアクセス保護の対象と
する連続したメモリ領域である．メモリオブジェクトは，その先頭番地によっ
て識別する【NGKI2772】．

各メモリオブジェクトが持つ情報は次の通り【NGKI2773】．

* 先頭番地
* サイズ
* メモリオブジェクト属性
* アクセス許可ベクタ
* 属する保護ドメイン
* 属するクラス（マルチプロセッサ対応カーネルの場合）

メモリオブジェクトの先頭番地とサイズには，ターゲット定義の制約が課せら
れる【NGKI2774】．

メモリオブジェクト属性には，次の属性を指定することができる【NGKI2775】．

	TA_NOWRITE	0x01U	書込みアクセス禁止
	TA_NOREAD	0x02U	読出しアクセス禁止
	TA_EXEC		0x04U	実行アクセス許可
	TA_MEMINI	0x08U	メモリの初期化を行う
	TA_MEMPRSV	0x10U	メモリの初期化を行わない
	TA_SDATA	0x20U	ショートデータ領域に配置
	TA_UNCACHE	0x40U	キャッシュ禁止
	TA_IODEV	0x80U	周辺デバイスの領域

メモリオブジェクトに対して書込みアクセスできるのは，メモリオブジェクト
属性に書込みアクセス禁止（TA_NOWRITE属性）が指定されておらず，アクセス
許可ベクタにより書込みアクセスが許可されている場合である【NGKI2776】．
また，読出しアクセスできるのは，メモリオブジェクト属性に読出しアクセス
禁止（TA_NOREAD属性）が指定されておらず，アクセス許可ベクタにより読出し・
実行アクセスが許可されている場合である【NGKI2777】．実行アクセスできる
のは，メモリオブジェクト属性に実行アクセス許可（TA_EXEC属性）が指定され
ており，アクセス許可ベクタにより読出し・実行アクセスが許可されている場
合である【NGKI2778】．

ただし，ターゲットハードウェアの制約によってこれらの属性を実現できない
場合には，次のように扱われる．書込みアクセス禁止が実現できない場合には，
TA_NOWRITEを指定しても無視される【NGKI2779】．また，読出しアクセス禁止
が実現できない場合には，TA_NOREADを指定しても無視される【NGKI2780】．実
行アクセス禁止が実現できない場合には，TA_EXECを指定しなくても実行アクセ
ス許可となり，TA_EXECは無視される【NGKI2781】．どのような場合にどの属性
の指定が無視されるかは，ターゲット定義である【NGKI2782】．

TA_MEMINI属性は，システム初期化時に初期化するメモリオブジェクトであるこ
とを，TA_MEMPRSV属性は，システム初期化時に初期化を行わないメモリオブジェ
クトであることを示す【NGKI2783】．いずれの属性も指定しない場合，そのメ
モリオブジェクトは，システム初期化時にクリア（言い換えると，0に初期化）
される【NGKI2784】．

TA_MEMINI属性を設定したメモリオブジェクトを初期化に用いる初期化データは，
標準ROMリージョン（マルチプロセッサ対応カーネルでは，共通の標準ROMリー
ジョン）に配置され，メモリオブジェクトとしては登録されない【NGKI2787】．

TA_SDATA属性は，メモリオブジェクトをショートデータ領域に配置することを
示す【NGKI2788】．具体的な扱いはターゲット定義であるが，ショートデータ
領域がサポートされていないターゲットでは，この属性は無視される
【NGKI2789】．また，ターゲットによっては，TA_NOWRITEを指定した場合に，
TA_SDATAが無視される場合がある【NGKI2790】．

TA_UNCACHE属性は，メモリオブジェクトをキャッシュ禁止に設定することを，
TA_IODEV属性は，メモリオブジェクトを周辺デバイスの領域として扱うことを
示す【NGKI2791】．具体的な扱いはターゲット定義であるが，これらの属性を
指定しても意味がないターゲット（例えば，キャッシュを持たないターゲット
プロセッサでのTA_UNCACHE）では，これらの属性は無視される【NGKI2792】．
逆に，キャッシュ禁止にできないメモリオブジェクトに対してTA_UNCACHEを指
定した場合や，周辺デバイスの領域として扱うことができないメモリオブジェ
クトに対してTA_IODEVを指定した場合には，E_RSATRエラーとなる【NGKI2793】．

ターゲットによっては，ターゲット定義のメモリオブジェクト属性を指定でき
る場合がある【NGKI2794】．ターゲット定義のメモリオブジェクト属性として，
次の属性を予約している【NGKI2795】．

	TA_WTHROUGH			ライトスルーキャッシュを用いる

〔カーネル構成マクロ〕

メモリオブジェクト管理機能に関連するカーネル構成マクロは次の通り．

	TOPPERS_SUPPORT_ATT_MOD		ATT_MOD／ATA_MODがサポートされている
								【NGKI2796】
	TOPPERS_SUPPORT_ATT_PMA		ATT_PMA／ATA_PMA／att_pmaがサポートさ
								れている【NGKI2797】

ただし，att_pmaは，動的生成対応カーネルのみでサポートされるAPIであるた
め，サポートされているかを判定するには，TOPPERS_SUPPORT_DYNAMIC_CREと
TOPPERS_SUPPORT_ATT_PMAの両方が定義されていることをチェックする必要があ
る【NGKI2798】．

【補足説明】

メモリオブジェクトが属するクラスは，ATT_MOD／ATA_MODにおいて，標準のセ
クションが配置されるメモリリージョンを決定するためのみに使用される．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，メモリオブジェクト管理機能をサポートしない【ASPS0191】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，メモリオブジェクト管理機能をサポートしない【FMPS0158】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，メモリオブジェクト管理機能をサポートする【HRPS0154】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，メモリオブジェクト管理機能をサポートしない【SSPS0136】．

【μITRON4.0/PX仕様との関係】

値が0のメモリオブジェクト属性（TA_RW，TA_CACHE）は，デフォルトの扱いに
して廃止した．TA_ROはTA_NOWRITEに改名し，TA_NOREAD，TA_EXEC，TA_MEMINI，
TA_MEMPRSV，TA_IODEVを追加した．また，TA_UNCACHEの値を変更し，ターゲッ
ト定義のメモリオブジェクト属性としてTA_WTHROUGHを予約した．

メモリリージョンは，μITRON4.0/PX仕様にはない概念である．

【仕様決定の理由】

TA_IODEV属性を導入したのは，ターゲットプロセッサによっては，周辺デバイ
スの領域として扱うためには，キャッシュ禁止に加えて，メモリのアクセス順
序を変更しないことを指定しなければならないためである．メモリのアクセス
順序を変更しないことを指定するメモリオブジェクト属性を，ターゲット定義
で用意してもよいが，それを使うとアプリケーションのポータビリティが下が
るため，TA_IODEV属性を用意することにした．


[[API_ATT_REG]]
----
ATT_REG		メモリリージョンの登録〔SP〕【NGKI2799】
----

【静的API】
----
	ATT_REG("メモリリージョン名", { ATR regatr, void *base, SIZE size })
----

【パラメータ】
----
	"メモリリージョン名"	登録するメモリリージョンを指定する文字列
	ATR			regatr		メモリリージョン属性
	void *		base		登録するメモリリージョンの先頭番地
	SIZE		size		登録するメモリリージョンのサイズ（バイト数）
----

【エラーコード】
----
	E_RSATR		予約属性
				・regatrが無効【NGKI2800】
				・保護ドメインの囲みの中に記述されている【NGKI2814】
				・クラスの囲みの中に記述されている〔M〕【NGKI3260】
	E_PAR		パラメータエラー
				・sizeが0以下【NGKI2816】
				・その他の条件については機能の項を参照
	E_OBJ		オブジェクト状態エラー
				・登録済みのメモリリージョンの再登録【NGKI2801】
				・その他の条件については機能の項を参照
----

【機能】

各パラメータで指定したメモリリージョン登録情報に従って，指定したメモリ
リージョンを登録する．具体的な振舞いは以下の通り．

baseとsizeで指定したメモリ領域が，メモリリージョンとして登録される
【NGKI2802】．登録されるメモリリージョンには，regatrで指定したメモリリー
ジョン属性が設定される【NGKI2803】．

メモリリージョン名は文字列パラメータ，regatr，base，sizeは整数定数式パ
ラメータである【NGKI2804】．

baseやsizeに，ターゲット定義の制約に合致しない先頭番地やサイズを指定し
た時には，E_PARエラーとなる【NGKI2815】．登録しようとしたメモリリージョ
ンが，登録済みのメモリリージョンとメモリ領域が重なる場合には，E_OBJエラー
となる【NGKI2817】．

【μITRON4.0/PX仕様との関係】

μITRON4.0/PX仕様に定義されていない静的APIである．


[[API_DEF_SRG]]
----
DEF_SRG		標準メモリリージョンの定義〔SP〕【NGKI3261】
----

【静的API】
----
	DEF_SRG("標準ROMリージョン名", "標準RAMリージョン名")
----

【パラメータ】
----
	"標準ROMリージョン名"	標準ROMリージョンとするメモリリージョンを
							指定する文字列
	"標準RAMリージョン名"	標準RAMリージョンとするメモリリージョンを
							指定する文字列
----

【エラーコード】
----
	E_RSATR		予約属性
				・保護ドメインの囲みの中に記述されている【NGKI3262】
	E_OBJ		オブジェクト状態エラー
				・標準メモリリージョンが定義済み【NGKI3263】
				・標準ROMリージョンに指定したメモリリージョンが未登録
				　【NGKI3264】
				・標準RAMリージョンに指定したメモリリージョンが未登録
				　【NGKI3272】
				・その他の条件については機能の項を参照
----

【機能】

各パラメータに従って，標準ROMリージョンと標準RAMリージョンを定義する
【NGKI3265】．

マルチプロセッサ対応カーネルでは，DEF_SRGをクラスの囲みの外に記述すると，
共通の標準ROMリージョンと標準RAMリージョンを定義し，クラスの囲みの中に
記述すると，そのクラスの標準ROMリージョンと標準RAMリージョンを定義する
【NGKI3266】．

標準ROMリージョンは，TA_NOWRITE属性のメモリリージョンでなければならない．
標準ROMリージョンとして指定したメモリリージョンが，TA_NOWRITE属性でない
場合には，E_OBJエラーとなる【NGKI3268】．また，標準RAMリージョンは，
TA_NOWRITE属性でないメモリリージョンでなければならない．標準RAMリージョ
ンとして指定したメモリリージョンが，TA_NOWRITE属性である場合には，
E_OBJエラーとなる【NGKI3270】．

【μITRON4.0/PX仕様との関係】

μITRON4.0/PX仕様に定義されていない静的APIである．


[[API_ATT_SEC]]
----
ATT_SEC		セクションの登録〔SP〕【NGKI2818】
ATA_SEC		セクションの登録（アクセス許可ベクタ付き）〔SP〕【NGKI2819】
----

【静的API】
----
	ATT_SEC("セクション名", { ATR mematr, "メモリリージョン名" })
	ATA_SEC("セクション名", { ATR mematr, "メモリリージョン名" },
				{ ACPTN acptn1, ACPTN acptn2, ACPTN acptn3, ACPTN acptn4 })
----

【パラメータ】
----
	"セクション名"			登録するセクションを指定する文字列
	ATR			mematr		メモリオブジェクト属性
	"メモリリージョン名"	セクションを配置するメモリリージョンを指定
							する文字列

　＊アクセス許可ベクタ（パケットの内容）
	ACPTN		acptn1		通常操作1のアクセス許可パターン
	ACPTN		acptn2		通常操作2のアクセス許可パターン
	ACPTN		acptn3		管理操作のアクセス許可パターン
	ACPTN		acptn4		参照操作のアクセス許可パターン
----

【エラーコード】
----
	E_RSATR		予約属性
				・mematrが無効【NGKI2820】
				・その他の条件については機能の項を参照
 	E_NOSPT		未サポート機能
				・条件については機能の項を参照
	E_PAR		パラメータエラー
				・条件については機能の項を参照
	E_OBJ		オブジェクト状態エラー
				・登録済みのセクションの再登録【NGKI2821】
				・指定したメモリリージョンが未登録【NGKI2822】
----

【機能】

各パラメータで指定した情報に従って，指定したセクションをカーネルに登録
する．具体的な振舞いは以下の通り．

各オブジェクトモジュールに含まれるセクション名で指定したセクションが，
メモリリージョン名で指定したメモリリージョンに配置され，メモリオブジェ
クトとして登録される【NGKI2823】．登録されるメモリオブジェクトには，
mematrで指定したメモリオブジェクト属性が設定される【NGKI2824】．
ATA_SECの場合には，登録されるメモリオブジェクトのアクセス許可ベクタ（4
つのアクセス許可パターンの組）が，acptn1〜acptn4で指定した値に設定され
る【NGKI2825】．

指定したメモリリージョンがTA_NOWRITE属性である場合には，メモリオブジェ
クト属性にTA_NOWRITE属性を指定したことになる（TA_NOWRITE属性を指定して
も指定しなくても，同じ振舞いとなる）【NGKI2826】．また，メモリオブジェ
クト属性のTA_MEMINIとTA_MEMPRSVは無視される（指定しても指定しなくても，
同じ振舞いとなる）【NGKI2786】．

mematrに，TA_MEMINIとTA_MEMPRSVを同時に指定することはできない．指定した
場合には，E_RSATRエラーとなる【NGKI2828】．

登録されるメモリオブジェクトと同じ保護ドメインに属し，メモリオブジェク
ト属性とアクセス許可ベクタがすべて一致するメモリオブジェクトがある場合
には，1つのメモリオブジェクトにまとめて登録される場合がある【NGKI2829】．

セクション名とメモリリージョン名は文字列パラメータ，mematr，acptn1〜
acptn4は整数定数式パラメータである【NGKI2830】．

ターゲット定義で，ATA_SECにより登録できるセクションが属する保護ドメイン
や登録できる数に制限がある場合がある【NGKI2831】．この制限に違反した場
合には，E_NOSPTエラーとなる【NGKI2832】．

ATT_MOD／ATA_MODがサポートされているターゲットでは，セクション名として，
標準のセクションを指定することはできない．指定した場合には，E_PARエラー
となる【NGKI2834】．

保護ドメイン毎の標準セクションは，コンフィギュレータによってカーネルに
登録されるため，ATT_SEC／ATA_SECで登録することはできない．セクション名
として指定した場合には，E_PARエラーとなる【NGKI2836】．

マルチプロセッサ対応カーネルにおいて，指定したメモリリージョンがあるク
ラス専用のメモリリージョンの場合で，ATT_SEC／ATA_SECをクラスの囲みの外
に記述するか，他のクラスの囲みの中に記述した場合には，E_RSATRエラーとな
る【NGKI2837】．

【μITRON4.0/PX仕様との関係】

μITRON4.0/PX仕様に定義されていない静的APIである．


[[API_LNK_SEC]]
----
LNK_SEC		セクションの配置〔SP〕【NGKI2838】
----

【静的API】
----
	LNK_SEC("セクション名", { "メモリリージョン名" })
----

【パラメータ】
----
	"セクション名"			配置するセクションを指定する文字列
	"メモリリージョン名"	セクションを配置するメモリリージョンを指定
							する文字列
----

【エラーコード】
----
	E_RSATR		予約属性
				・保護ドメインの囲みの中に記述されている【NGKI3685】
				・その他の条件については機能の項を参照
	E_PAR		パラメータエラー
				・条件については機能の項を参照
	E_OBJ		オブジェクト状態エラー
				・登録済みのセクションの再登録【NGKI2839】
				・指定したメモリリージョンが未登録【NGKI2840】
----

【機能】

各オブジェクトモジュールに含まれるセクション名で指定したセクションを，
メモリリージョン名で指定したメモリリージョンに配置する【NGKI2841】．

セクション名として，標準のセクションや保護ドメイン毎の標準セクションを
指定することはできない．指定した場合には，E_PARエラーとなる【NGKI2843】．

マルチプロセッサ対応カーネルにおいて，指定したメモリリージョンがあるク
ラス専用のメモリリージョンの場合で，LNK_SECをクラスの囲みの外に記述する
か，他のクラスの囲みの中に記述した場合には，E_RSATRエラーとなる
【NGKI2844】．

【使用上の注意】

LNK_SECにより配置されたセクションは，メモリオブジェクトとしてカーネルに
登録されず，メモリ保護が実現できる先頭番地とサイズになるとは限らない．

【μITRON4.0/PX仕様との関係】

μITRON4.0/PX仕様に定義されていない静的APIである．


[[API_ATT_MOD]]
----
ATT_MOD		オブジェクトモジュールの登録〔SP〕【NGKI2845】
ATA_MOD		オブジェクトモジュールの登録（アクセス許可ベクタ付き）〔SP〕
			【NGKI2846】
----

【静的API】
----
	ATT_MOD("オブジェクトモジュール名")
	ATA_MOD("オブジェクトモジュール名",
				{ ACPTN acptn1, ACPTN acptn2, ACPTN acptn3, ACPTN acptn4 })
----

【パラメータ】
----
	"オブジェクトモジュール名"		登録するオブジェクトモジュールを指
									定する文字列

　＊アクセス許可ベクタ（パケットの内容）
	ACPTN		acptn1		通常操作1のアクセス許可パターン
	ACPTN		acptn2		通常操作2のアクセス許可パターン
	ACPTN		acptn3		管理操作のアクセス許可パターン
	ACPTN		acptn4		参照操作のアクセス許可パターン
----

【エラーコード】
----
	E_RSATR		予約属性
				・mematrが無効【NGKI2847】
 	E_NOSPT		未サポート機能
				・条件については機能の項を参照
	E_OBJ		オブジェクト状態エラー
				・登録済みのオブジェクトモジュールの再登録【NGKI2848】
----

【機能】

各パラメータで指定した情報に従って，指定したオブジェクトモジュールをカー
ネルに登録する．具体的な振舞いは以下の通り．

オブジェクトモジュール名で指定したオブジェクトモジュールに含まれる標準
のセクションの内，書込みアクセスを行わないセクションは標準ROMリージョン
に，書込みアクセスを行うセクションは標準RAMリージョンに配置され，メモリ
オブジェクトとして登録される【NGKI2849】．登録されるメモリオブジェクト
には，ターゲット定義でセクション毎に定まるメモリオブジェクト属性が設定
される【NGKI2850】．ATA_MODの場合には，登録されるメモリオブジェクトのア
クセス許可ベクタ（4つのアクセス許可パターンの組）が，acptn1〜acptn4で指
定した値に設定される【NGKI2851】．

マルチプロセッサ対応カーネルでは，ATT_MOD／ATA_MODを，クラスの囲みの外
に記述することも，クラスの囲みの中に記述することもできる【NGKI2852】．
ATT_MOD／ATA_MODをクラスの囲みの外に記述した場合，標準のセクションは，
共通の標準メモリリージョンに配置される【NGKI2853】．クラスの囲みの中に
記述した場合，そのクラスの標準メモリリージョンが定義されていればそれら
のメモリリージョン，定義されていなければ共通の標準メモリリージョンに配
置される【NGKI2854】．ただし，セクションによっては，ターゲット定義で，
クラスの標準メモリリージョンが定義されている場合でも，共通の標準メモリ
リージョンに配置される場合がある【NGKI3271】．

登録されるメモリオブジェクトと同じ保護ドメインに属し，メモリオブジェク
ト属性とアクセス許可ベクタがすべて一致するメモリオブジェクトがある場合
には，1つのメモリオブジェクトにまとめて登録される場合がある【NGKI2855】．

オブジェクトモジュール名は文字列パラメータ，acptn1〜acptn4は整数定数式
パラメータである【NGKI2856】．

ターゲット定義で，ATA_MODにより登録できるオブジェクトモジュールが属する
保護ドメインや登録できる数に制限がある場合がある【NGKI2857】．この制限
に違反した場合には，E_NOSPTエラーとなる【NGKI2858】．

ターゲット定義で，ATT_MOD／ATA_MODがサポートされていない場合がある
【NGKI2859】．ATT_MOD／ATA_MODがサポートされている場合には，
TOPPERS_SUPPORT_ATT_MODがマクロ定義される【NGKI2860】．サポートされてい
ない場合にATT_MOD／ATA_MODを使用すると，コンフィギュレータがE_NOSPTエラー
を報告する【NGKI2861】．

【補足説明】

ATT_MOD／ATA_MODでは，標準のセクション以外は配置・登録されない．標準の
セクション以外のセクションを配置・登録するためには，ATT_SEC/ATA_SECを用
いる必要がある．

【μITRON4.0/PX仕様との関係】

オブジェクトモジュールに含まれるセクションの配置場所が，標準ROMリージョ
ンと標準RAMリージョンであることを明確化した．


[[API_ATT_MEM]]
----
ATT_MEM		メモリオブジェクトの登録〔SP〕【NGKI2862】
ATA_MEM		メモリオブジェクトの登録（アクセス許可ベクタ付き）〔SP〕【NGKI2863】
att_mem		メモリオブジェクトの登録〔TPD〕【NGKI2864】
----

【静的API】
----
	ATT_MEM({ ATR mematr, void *base, SIZE size })
	ATA_MEM({ ATR mematr, void *base, SIZE size },
				{ ACPTN acptn1, ACPTN acptn2, ACPTN acptn3, ACPTN acptn4 })
----

【C言語API】
----
	ER ercd = att_mem(const T_AMEM *pk_amem)
----

【パラメータ】
----
	T_AMEM *	pk_amem		メモリオブジェクトの登録情報を入れたパケッ
							トへのポインタ（静的APIを除く）

　＊メモリオブジェクトの登録情報（パケットの内容）
	ATR			mematr		メモリオブジェクト属性
	void *		base		登録するメモリ領域の先頭番地
	SIZE		size		登録するメモリ領域のサイズ（バイト数）

　＊アクセス許可ベクタ（パケットの内容）
	ACPTN		acptn1		通常操作1のアクセス許可パターン
	ACPTN		acptn2		通常操作2のアクセス許可パターン
	ACPTN		acptn3		管理操作のアクセス許可パターン
	ACPTN		acptn4		参照操作のアクセス許可パターン
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI2865】
				・CPUロック状態からの呼出し〔s〕【NGKI2866】
	E_RSATR		予約属性
				・mematrが無効【NGKI2867】
				・属する保護ドメインの指定が有効範囲外〔sP〕【NGKI2868】
				・属するクラスの指定が有効範囲外〔sM〕【NGKI2869】
				・その他の条件については機能の項を参照
 	E_NOSPT		未サポート機能
				・条件については機能の項を参照
	E_PAR		パラメータエラー
				・sizeが0以下【NGKI2881】
				・その他の条件については機能の項を参照
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する管理操作が許可されていない〔sP〕
				　【NGKI2870】
	E_MACV		メモリアクセス違反
				・pk_amemが指すメモリ領域への読出しアクセスが許可されて
				　いない〔sP〕【NGKI2871】
	E_OBJ		オブジェクト状態エラー
				・条件については機能の項を参照
----

【機能】

各パラメータで指定したメモリオブジェクト登録情報に従って，メモリオブジェ
クトを登録する．具体的な振舞いは以下の通り．

baseとsizeで指定したメモリ領域が，メモリオブジェクトとして登録される
【NGKI2872】．登録されるメモリオブジェクトには，mematrで指定したメモリ
オブジェクト属性が設定される【NGKI2873】．ATA_MEMの場合には，登録される
メモリオブジェクトのアクセス許可ベクタ（4つのアクセス許可パターンの組）
が，acptn1〜acptn4で指定した値に設定される【NGKI2874】．

mematrには，TA_MEMPRSVを指定しなければならず，TA_MEMINIを指定することは
できない．TA_MEMPRSVを指定しない場合や，TA_MEMINIを指定した場合には，
E_RSATRエラーとなる【NGKI2876】．また，mematrにTA_SDATAを指定することは
できない．TA_SDATAを指定した場合には，E_RSATRエラーとなる【NGKI3274】．

静的APIにおいては，mematr，size，acptn1〜acptn4は整数定数式パラメータ，
baseは一般定数式パラメータである【NGKI2877】．

ターゲット定義で，ATT_MEM／ATA_MEMにより登録できるメモリオブジェクトが
属する保護ドメインや登録できる数に制限がある場合がある【NGKI2878】．こ
の制限に違反した場合には，E_NOSPTエラーとなる【NGKI2879】．

baseやsizeに，ターゲット定義の制約に合致しない先頭番地やサイズを指定し
た時には，E_PARエラーとなる【NGKI2880】．登録しようとしたメモリオブジェ
クトが，登録済みのメモリオブジェクトとメモリ領域が重なる場合には，
E_OBJエラーとなる【NGKI2882】．

【使用上の注意】

ATT_MEM／ATA_MEMは，メモリ空間にマッピングされたI/O領域にアクセスできる
ようにするために使用することを想定した静的APIである．メモリ領域に対して
は，ATT_SEC／ATA_SECかATT_MOD／ATA_MODを使用することを推奨する．

ATT_MEM／ATA_MEMで登録したメモリオブジェクトのメモリ領域が，ATT_REGで登
録したメモリリージョンと重なっても，直ちにエラーとはならない．ただし，
メモリリージョン内に配置されたメモリオブジェクトと，ATT_MEM／ATA_MEMで
登録したメモリオブジェクトのメモリ領域が重なった場合には，E_OBJエラーと
なる．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，ATT_MEMとATA_MEMのみをサポートする【HRPS0155】．

【μITRON4.0/PX仕様との関係】

アクセス許可ベクタを指定してメモリオブジェクトを登録するサービスコール
（ata_mem）は廃止した．

baseやsizeがターゲット定義の制約に合致しない場合，μITRON4.0/PX仕様では
ターゲット定義の制約に合致するようにメモり領域を広げることとしていたが，
この仕様ではE_PARエラーとなることとした．


[[API_ATT_PMA]]
----
ATT_PMA		物理メモリ領域の登録〔SP〕【NGKI2883】
ATA_PMA		物理メモリ領域の登録（アクセス許可ベクタ付き）〔SP〕【NGKI2884】
att_pma		物理メモリ領域の登録〔TPD〕【NGKI2885】
----

【静的API】
----
	ATT_PMA({ ATR mematr, void *base, SIZE size, void *paddr })
	ATA_PMA({ ATR mematr, void *base, SIZE size, void *paddr  },
				{ ACPTN acptn1, ACPTN acptn2, ACPTN acptn3, ACPTN acptn4 })
----

【C言語API】
----
	ER ercd = att_pma(const T_APMA *pk_apma)
----

【パラメータ】
----
	T_APMA *	pk_apma		物理メモリ領域の登録情報を入れたパケットへ
							のポインタ（静的APIを除く）

　＊物理メモリ領域の登録情報（パケットの内容）
	ATR			mematr		メモリオブジェクト属性
	void *		base		登録するメモリ領域の先頭番地
	SIZE		size		登録するメモリ領域のサイズ（バイト数）
	void *		paddr		登録するメモリ領域の物理アドレス空間における
							先頭番地

　＊アクセス許可ベクタ（パケットの内容）
	ACPTN		acptn1		通常操作1のアクセス許可パターン
	ACPTN		acptn2		通常操作2のアクセス許可パターン
	ACPTN		acptn3		管理操作のアクセス許可パターン
	ACPTN		acptn4		参照操作のアクセス許可パターン
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI2886】
				・CPUロック状態からの呼出し〔s〕【NGKI2887】
	E_RSATR		予約属性
				・mematrが無効
				・属する保護ドメインの指定が有効範囲外〔sP〕【NGKI2888】
				・属するクラスの指定が有効範囲外〔sM〕【NGKI2889】
				・その他の条件については機能の項を参照
 	E_NOSPT		未サポート機能
				・条件については機能の項を参照
	E_PAR		パラメータエラー
				・sizeが0以下【NGKI2901】
				・その他の条件については機能の項を参照
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する管理操作が許可されていない〔sP〕
				　【NGKI2890】
	E_MACV		メモリアクセス違反
				・pk_apmaが指すメモリ領域への読出しアクセスが許可されて
				　いない〔sP〕【NGKI2891】
	E_OBJ		オブジェクト状態エラー
				・条件については機能の項を参照
----

【機能】

各パラメータで指定した物理メモリ領域の登録情報に従って，メモリオブジェ
クトを登録する．具体的な振舞いは以下の通り．

物理アドレス空間において先頭番地がpaddr，サイズがsizeのメモリ領域が，論
理アドレス空間においてbaseで指定した番地からアクセスできるように，メモ
リオブジェクトとして登録される【NGKI2892】．登録されるメモリオブジェク
トには，mematrで指定したメモリオブジェクト属性が設定される【NGKI2893】．
ATA_PMAの場合には，登録されるメモリオブジェクトのアクセス許可ベクタ（4
つのアクセス許可パターンの組）が，acptn1〜acptn4で指定した値に設定され
る【NGKI2894】．

mematrには，TA_MEMPRSVを指定しなければならず，TA_MEMINIを指定することは
できない．TA_MEMPRSVを指定しない場合や，TA_MEMINIを指定した場合には，
E_RSATRエラーとなる【NGKI2896】．

静的APIにおいては，mematr，size，paddr，acptn1〜acptn4は整数定数式パラ
メータ，baseは一般定数式パラメータである【NGKI2897】．

ターゲット定義で，ATT_PMA／ATA_PMAにより登録できるメモリオブジェクトが
属する保護ドメインや登録できる数に制限がある場合がある【NGKI2898】．こ
の制限に違反した場合には，E_NOSPTエラーとなる【NGKI2899】．

base，size，paddrに，ターゲット定義の制約に合致しない先頭番地やサイズを
指定した時には，E_PARエラーとなる【NGKI2900】．登録しようとしたメモリオ
ブジェクトが，登録済みのメモリオブジェクトと論理アドレス空間においてメ
モリ領域が重なる場合には，E_OBJエラーとなる【NGKI2902】．

ATT_PMA／ATA_PMA／att_pmaは，MMU（Memory Management Unit）を持つターゲッ
トシステムにおいて，ターゲット定義でサポートされる機能である【NGKI2903】．
ATT_PMA／ATA_PMA／att_pmaがサポートされている場合には，
TOPPERS_SUPPORT_ATT_PMAがマクロ定義される【NGKI2904】．ATT_PMA／ATA_PMA
がサポートされていない場合にこれらの静的APIを使用すると，コンフィギュレー
タがE_NOSPTエラーを報告する【NGKI2905】．また，att_pmaがサポートされて
いない場合にatt_pmaを呼び出すと，E_NOSPTエラーが返るか，リンク時にエラー
となる【NGKI2906】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，ターゲット定義で，ATT_PMAとATA_PMAのみをサポートする
【HRPS0156】．

【μITRON4.0/PX仕様との関係】

μITRON4.0/PX仕様に定義されていない静的APIおよびサービスコールである．


[[API_sac_mem]]
----
sac_mem		メモリオブジェクトのアクセス許可ベクタの設定〔TPD〕【NGKI2907】
----

【C言語API】
----
	ER ercd = sac_mem(const void *base, const ACVCT *p_acvct)
----

【パラメータ】
----
	void *		base		メモリオブジェクトの先頭番地
	ACVCT *		p_acvct		アクセス許可ベクタを入れたパケットへのポ
							インタ

　＊アクセス許可ベクタ（パケットの内容）
	ACPTN		acptn1		通常操作1のアクセス許可パターン
	ACPTN		acptn2		通常操作2のアクセス許可パターン
	ACPTN		acptn3		管理操作のアクセス許可パターン
	ACPTN		acptn4		参照操作のアクセス許可パターン
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2908】
				・CPUロック状態からの呼出し【NGKI2909】
	E_PAR		パラメータエラー
				・baseがメモリオブジェクトの先頭番地でない【NGKI2910】
	E_NOEXS		オブジェクト未登録
				・baseで指定した番地を含むメモリオブジェクトが登録され
				　ていない【NGKI2911】
	E_OACV		オブジェクトアクセス違反
				・対象メモリオブジェクトに対する管理操作が許可されてい
				　ない【NGKI2912】
	E_MACV		メモリアクセス違反
				・p_acvctが指すメモリ領域への読出しアクセスが許可されて
				　いない【NGKI2913】
	E_OBJ		オブジェクト状態エラー
				・対象メモリオブジェクトは静的APIで登録された【NGKI2914】
----

【機能】

baseで指定したメモリオブジェクト（対象メモリオブジェクト）のアクセス許
可ベクタ（4つのアクセス許可パターンの組）を，各パラメータで指定した値に
設定する【NGKI2915】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，sac_memをサポートしない【HRPS0157】．

【μITRON4.0/PX仕様との関係】

静的APIによって登録したメモリオブジェクトは，アクセス許可ベクタを設定す
ることができないこととした．

μITRON4.0/PX仕様では，baseはメモリオブジェクトに含まれる番地を指定する
ものとしていたが，この仕様では，メモリオブジェクトの先頭番地でなければ
ならないものとした．


[[API_det_mem]]
----
det_mem		メモリオブジェクトの登録解除〔TPD〕【NGKI2916】
----

【C言語API】
----
	ER ercd = det_mem(const void *base)
----

【パラメータ】
----
	void *		base		メモリオブジェクトの先頭番地
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2917】
				・CPUロック状態からの呼出し【NGKI2918】
	E_PAR		パラメータエラー
				・baseがメモリオブジェクトの先頭番地でない【NGKI2919】
	E_NOEXS		オブジェクト未登録
				・baseで指定した番地を含むメモリオブジェクトが登録され
				　ていない【NGKI2920】
	E_OACV		オブジェクトアクセス違反
				・対象メモリオブジェクトに対する管理操作が許可されてい
				　ない【NGKI2921】
	E_OBJ		オブジェクト状態エラー
				・対象メモリオブジェクトは静的APIで登録された【NGKI2922】
----

【機能】

baseで指定したメモリオブジェクト（対象メモリオブジェクト）を登録解除す
る【NGKI2923】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，det_memをサポートしない【HRPS0158】．

【μITRON4.0/PX仕様との関係】

静的APIによって登録したメモリオブジェクトは，登録を解除することができな
いこととした．

μITRON4.0/PX仕様では，baseはメモリオブジェクトに含まれる番地を指定する
ものとしていたが，この仕様では，メモリオブジェクトの先頭番地でなければ
ならないものとした．


[[API_prb_mem]]
----
prb_mem		メモリ領域に対するアクセス権のチェック〔TP〕【NGKI2924】
----

【C言語API】
----
	ER ercd = prb_mem(const void *base, SIZE size, ID tskid, MODE pmmode)
----

【パラメータ】
----
	void *		base		メモリ領域の先頭番地
	SIZE		size		メモリ領域のサイズ（バイト数）
	ID			tskid		アクセス元のタスクのID番号
	MODE		pmmode		アクセスモード
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI2925】
	E_ID		不正ID番号
				・tskidが有効範囲外【NGKI2927】
	E_PAR		パラメータエラー
				・sizeが0【NGKI2929】
				・その他の条件については機能の項を参照
	E_NOEXS		オブジェクト未登録
				・baseで指定した番地を含むメモリオブジェクトが登録され
				　ていない【NGKI2930】
				・tskidで指定したタスクが未登録〔D〕【NGKI3425】
	E_OACV		オブジェクトアクセス違反
				・対象メモリ領域を含むメモリオブジェクトに対する参照操
				　作が許可されていない【NGKI2931】
				・tskidで指定したタスクに対する参照操作が許可されていな
				　い【NGKI3426】
	E_MACV		メモリアクセス違反
				・条件については機能の項を参照
	E_OBJ		オブジェクト状態エラー
				・対象メモリ領域がメモリオブジェクトの境界を越えている
				　【NGKI2932】
----

【機能】

tskidで指定したタスクから，baseとsizeで指定したメモリ領域（対象メモリ領
域）に対して，pmmodeで指定した種別のアクセスが許可されているかをチェッ
クする．アクセスが許可されている場合にE_OK，そうでない場合にE_MACVが返
る【NGKI2933】．tskidで指定したタスクがカーネルドメインに属する場合，
E_MACVが返ることはない【NGKI2934】．

pmmodeには，TPM_WRITE（＝0x01U），TPM_READ（＝0x02U），TPM_EXEC（＝
0x04U）のいずれか，またはそれらの内のいくつかのビット毎論理和（C言語の
"|"）を指定することができる【NGKI2935】．TPM_WRITE，TPM_READ，TPM_EXEC
を指定した場合には，それぞれ，読出しアクセス，書込みアクセス，実行アク
セスが許可されているかをチェックする【NGKI2936】．また，いくつかのビッ
ト毎論理和を指定した場合には，それらに対応した種別のアクセスがすべて許
可されているかをチェックする【NGKI2937】．pmmodeにそれ以外の値を指定し
た場合には，E_PARエラーとなる【NGKI2938】．

tskidにTSK_SELF（＝0）を指定すると，自タスクから対象メモリ領域に対して
アクセスが許可されているかをチェックする【NGKI2939】．

【μITRON4.0/PX仕様との関係】

アクセスする主体の指定方法を，保護ドメインによる指定（domid）から，タス
クによる指定（tskid）に変更した．また，pmmodeに指定できるアクセス種別に
TPM_EXECを追加し，TPM_WRITEとTPM_READの値を入れ換えた．CPUロック状態か
らも呼び出せるものとした．

【仕様決定の理由】

prb_memを，CPUロック状態からも呼び出せるものとしたのは，次の理由による．
prb_memは，拡張サービスコールの中で，タスクから渡されたポインタが，その
タスクからアクセスできる領域であるかを調べるために用いることを想定して
いる．拡張サービスコールの中には，CPUロック状態でも呼び出せるものがあり，
そのような拡張サービスコールを実現するには，prb_memがCPUロック状態から
呼び出せることが必要である．

なお，prb_memを非タスクコンテキストから呼び出すことはできないが，非タス
クコンテキストで実行される処理単位は必ずカーネルドメインに属するために，
prb_memを使ってアクセス権を調べる必要がないことから，支障がない．


[[API_ref_mem]]
----
ref_mem		メモリオブジェクトの状態参照〔TP〕
----

【C言語API】
----
	ER ercd = ref_mem(const void *base, T_RMEM *pk_rmem)
----

☆未完成

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，ref_memをサポートしない．


=== 割込み管理機能

割込み処理のプログラムは，割込みサービスルーチン（ISR）として実現するこ
とを推奨する．割込みサービスルーチンをカーネルに登録する場合には，まず，
割込みサービスルーチンの登録対象となる割込み要求ラインの属性を設定して
おく必要がある【NGKI2940】．割込みサービスルーチンは，カーネル内の割込
みハンドラを経由して呼び出される【NGKI2941】．

ただし，カーネルが用意する割込みハンドラで対応できないケースに対応する
ために，アプリケーションで割込みハンドラを用意することも可能である
【NGKI2942】．この場合にも，割込みハンドラをカーネルに登録する前に，割
込みハンドラの登録対象となる割込みハンドラ番号に対応する割込み要求ライ
ンの属性を設定しておく必要がある【NGKI2943】．

割込み要求ラインの属性を設定する際に指定する割込み要求ライン属性には，
次の属性を指定することができる【NGKI2944】．

	TA_ENAINT	0x01U	割込み要求禁止フラグをクリア
	TA_EDGE		0x02U	エッジトリガ

ターゲットによっては，ターゲット定義の割込み要求ライン属性を指定できる
場合がある【NGKI2945】．ターゲット定義の割込み要求ライン属性として，次
の属性を予約している【NGKI2946】．

	TA_POSEDGE			ポジティブエッジトリガ
	TA_NEGEDGE			ネガティブエッジトリガ
	TA_BOTHEDGE			両エッジトリガ
	TA_LOWLEVEL			ローレベルトリガ
	TA_HIGHLEVEL		ハイレベルトリガ
	TA_BROADCAST		すべてのプロセッサで割込みを処理（マルチプロセッ
						サ対応カーネルの場合）

割込みサービスルーチンは，カーネルが実行を制御する処理単位である．割込
みサービスルーチンは，割込みサービスルーチンIDと呼ぶID番号によって識別
する【NGKI2947】．

1つの割込み要求ラインに対して複数の割込みサービスルーチンを登録した場合，
それらの割込みサービスルーチンは，割込みサービスルーチン優先度の高い順
にすべて呼び出される【NGKI2948】．割込みサービスルーチン優先度が同じ場
合には，登録した順（静的APIにより登録した場合には，割込みサービスルーチ
ンを生成するAPIをコンフィギュレーションファイル中に記述した順）で呼び出
される【NGKI2949】．

保護機能対応カーネルにおいて，割込みサービスルーチンが属することのでき
る保護ドメインは，カーネルドメインに限られる【NGKI2950】．

割込みサービスルーチン属性に指定できる属性はない【NGKI2951】．そのため
割込みサービスルーチン属性には，TA_NULLを指定しなければならない
【NGKI2952】．

C言語による割込みサービスルーチンの記述形式は次の通り【NGKI2953】．

[source,c]
----
	void interrupt_service_routine(intptr_t exinf)
	{
		割込みサービスルーチン本体
	}
----

exinfには，割込みサービスルーチンの拡張情報が渡される【NGKI2954】．

割込みハンドラは，カーネルが実行を制御する処理単位である．割込みハンド
ラは，割込みハンドラ番号と呼ぶオブジェクト番号によって識別する
【NGKI2955】．

保護機能対応カーネルにおいて，割込みハンドラは，カーネルドメインに属す
る【NGKI2956】．

割込みハンドラを登録する際に指定する割込みハンドラ属性には，ターゲット
定義で，次の属性を指定することができる【NGKI2957】．

	TA_NONKERNEL	0x02U	カーネル管理外の割込み

TA_NONKERNELを指定しない場合，カーネル管理の割込みとなる【NGKI2958】．
また，ターゲットによっては，その他のターゲット定義の割込みハンドラ属性
を指定できる場合がある【NGKI2959】．

C言語による割込みハンドラの記述形式は次の通り【NGKI2960】．

[source,c]
----
	void interrupt_handler(void)
	{
		割込みハンドラ本体
	}
----

割込み管理機能に関連するカーネル構成マクロは次の通り．

	TMIN_INTPRI		割込み優先度の最小値（最高値）	【NGKI2961】
	TMAX_INTPRI		割込み優先度の最大値（最低値，＝-1）

	TMIN_ISRPRI		割込みサービスルーチン優先度の最小値（＝1）【NGKI2962】
	TMAX_ISRPRI		割込みサービスルーチン優先度の最大値

	TOPPERS_SUPPORT_DIS_INT		dis_intがサポートされている【NGKI2963】
	TOPPERS_SUPPORT_ENA_INT		ena_intがサポートされている【NGKI2964】

【使用上の注意】

1つの割込み要求ラインに複数のデバイスからの割込み要求が接続されている場
合に対応するために，割込みサービスルーチンは，それが処理する割込み要求
が発生しているかをチェックし，割込み要求が発生していない場合には何もせ
ずにリターンするように実装すべきである．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，割込みサービスルーチン優先度の最大値（＝TMAX_ISRPRI）
は16に固定されている【ASPS0192】．ただし，タスク優先度拡張パッケージで
は，TMAX_ISRPRIを256に拡張する【ASPS0193】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，割込みサービスルーチン優先度の最大値（＝TMAX_ISRPRI）
は16に固定されている【FMPS0159】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，割込みサービスルーチン優先度の最大値（＝TMAX_ISRPRI）
は16に固定されている【HRPS0159】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，割込みサービスルーチン優先度の最大値（＝TMAX_ISRPRI）
は16に固定されている【SSPS0137】．

【μITRON4.0仕様との関係】

割込み要求ラインの属性，割込み優先度，割込みサービスルーチン優先度は，
μITRON4.0仕様にない概念であり，TMIN_INTPRI，TMAX_INTPRI，TMIN_ISRPRI，
TMAX_ISRPRIは，μITRON4.0仕様に定義のないカーネル構成マクロである．また，
TA_NONKERNELは，μITRON4.0仕様に定義のない割込みハンドラ属性である．


[[API_CFG_INT]]
----
CFG_INT		割込み要求ラインの属性の設定〔S〕【NGKI2965】
cfg_int		割込み要求ラインの属性の設定〔TD〕【NGKI2966】
----

【静的API】
----
	CFG_INT(INTNO intno, { ATR intatr, PRI intpri })
----

【C言語API】
----
	ER ercd = cfg_int(INTNO intno, const T_CINT *pk_cint)
----

【パラメータ】
----
	INTNO		intno		割込み番号
	T_CINT *	pk_cint		割込み要求ラインの属性の設定情報を入れたパ
							ケットへのポインタ（静的APIを除く）

　＊割込み要求ラインの属性の設定情報（パケットの内容）
	ATR			intatr		割込み要求ライン属性
	PRI			intpri		割込み優先度
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI2967】
				・CPUロック状態からの呼出し〔s〕【NGKI2968】
	E_RSATR		予約属性
				・intatrが無効【NGKI2969】
				・属するクラスの指定が有効範囲外〔sM〕【NGKI2970】
				・クラスの囲みの中に記述されていない〔SM〕【NGKI2971】
				・その他の条件については機能の項を参照
	E_PAR		パラメータエラー
				・intnoが有効範囲外【NGKI2972】
				・intpriが有効範囲外【NGKI2973】
				・その他の条件については機能の項を参照
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する管理操作が許可されていない〔sP〕
				　【NGKI2974】
	E_MACV		メモリアクセス違反
				・pk_cintが指すメモリ領域への読出しアクセスが許可されて
				　いない〔sP〕【NGKI2975】
	E_OBJ		オブジェクト状態エラー
				・対象割込み要求ラインに対して属性が設定済み〔S〕【NGKI2976】
				・その他の条件については機能の項を参照
----

【機能】

intnoで指定した割込み要求ライン（対象割込み要求ライン）に対して，各パラ
メータで指定した属性を設定する【NGKI2977】．

対象割込み要求ラインの割込み要求禁止フラグは，intatrにTA_ENAINTを指定し
た場合にクリアされ，指定しない場合にセットされる【NGKI2978】．

静的APIにおいては，intno，intatr，intpriは整数定数式パラメータである
【NGKI2979】．

cfg_intにおいて，ターゲット定義で，複数の割込み要求ラインの割込み優先度
が連動して設定される場合がある【NGKI2980】．

intpriに指定できる値は，基本的には，TMIN_INTPRI以上，TMAX_INTPRI以下の
値である【NGKI2981】．ターゲット定義の拡張で，カーネル管理外の割込み要
求ラインに対しても属性を設定できる場合には，TMIN_INTPRIよりも小さい値を
指定することができる【NGKI2982】．このように拡張されている場合，カーネ
ル管理外の割込み要求ラインを対象として，intpriにTMIN_INTPRI以上の値を指
定した場合には，E_OBJエラーとなる【NGKI2983】．逆に，カーネル管理の割込
み要求ラインを対象として，intpriがTMIN_INTPRIよりも小さい値である場合に
も，E_OBJエラーとなる【NGKI2984】．

対象割込み要求ラインに対して，設定できない割込み要求ライン属性をintatr
に指定した場合にはE_RSATRエラー，設定できない割込み優先度をintpriに指定
した場合にはE_PARエラーとなる【NGKI2985】．ここで，設定できない割込み要
求ライン属性／割込み優先度には，ターゲット定義の制限によって設定できな
い値も含む【NGKI2986】．また，マルチプロセッサ対応カーネルにおいて，
cfg_intを呼び出したタスクが割り付けられているプロセッサから，対象割込み
要求ラインの属性を設定できない場合も，これに該当する【NGKI2987】．

保護機能対応カーネルにおいて，CFG_INTは，カーネルドメインの囲みの中に記
述しなければならない．そうでない場合には，E_RSATRエラーとなる
【NGKI2989】．また，cfg_intはカーネルオブジェクトを登録するサービスコー
ルではないため，割込み要求ライン属性にTA_DOM(domid)を指定した場合には
E_RSATRエラーとなる【NGKI2990】．ただし，TA_DOM(TDOM_SELF)を指定した場
合には，指定が無視され，E_RSATRエラーは検出されない【NGKI2991】．

マルチプロセッサ対応カーネルで，CFG_INTの記述が，対象割込み要求ラインに
対して登録された割込みサービスルーチン（または対象割込み番号に対応する
割込みハンドラ番号に対して登録された割込みハンドラ）と異なるクラスの囲
み中にある場合には，E_RSATRエラーとなる【NGKI2992】．

【補足説明】

ターゲット定義の制限によって設定できない割込み要求ライン属性／割込み優
先度は，主にターゲットハードウェアの制限から来るものである．例えば，対
象割込み要求ラインに対して，トリガモードや割込み優先度が固定されていて，
変更できないケースが考えられる．

cfg_intにおいて，ターゲット定義で，複数の割込み要求ラインの割込み優先度
が連動して設定されるのは，ターゲットハードウェアの制限により，異なる割
込み要求ラインに対して，同一の割込み優先度しか設定できないケースに対応
するための仕様である．この場合，CFG_INTにおいては，同一の割込み優先度し
か設定できない割込み要求ラインに対して異なる割込み優先度を設定した場合
には，E_PARエラーとなる．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，CFG_INTのみをサポートする【ASPS0194】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，CFG_INTのみをサポートする【FMPS0160】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，CFG_INTのみをサポートする【HRPS0160】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，CFG_INTのみをサポートする【SSPS0138】．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていない静的APIおよびサービスコールである．


[[API_CRE_ISR]]
----
CRE_ISR		割込みサービスルーチンの生成〔S〕【NGKI2993】
ATT_ISR		割込みサービスルーチンの追加〔S〕【NGKI2994】
acre_isr	割込みサービスルーチンの生成〔TD〕【NGKI2995】
----

【静的API】
----
	CRE_ISR(ID isrid, { ATR isratr, intptr_t exinf,
										INTNO intno, ISR isr, PRI isrpri })
	ATT_ISR({ ATR isratr, intptr_t exinf, INTNO intno, ISR isr, PRI isrpri })
----

【C言語API】
----
	ER_ID isrid = acre_isr(const T_CISR *pk_cisr)
----

【パラメータ】
----
	ID			isrid		対象割込みサービスルーチンのID番号（CRE_ISR
							の場合）
	T_CISR *	pk_cisr		割込みサービスルーチンの生成情報を入れたパ
							ケットへのポインタ（静的APIを除く）

　＊割込みサービスルーチンの生成情報（パケットの内容）
	ATR			isratr		割込みサービスルーチン属性
	intptr_t	exinf		割込みサービスルーチンの拡張情報
	INTNO		intno		割込みサービスルーチンを登録する割込み番号
	ISR			isr			割込みサービスルーチンの先頭番地
	PRI			isrpri		割込みサービスルーチン優先度
----

【リターンパラメータ】
----
	ER_ID		isrid		生成された割込みサービスルーチンのID番号（正
							の値）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI2996】
				・CPUロック状態からの呼出し〔s〕【NGKI2997】
	E_RSATR		予約属性
				・isratrが無効【NGKI2998】
				・属する保護ドメインの指定が有効範囲外またはカーネルド
				　メイン以外〔sP〕【NGKI2999】
				・カーネルドメインの囲みの中に記述されていない〔SP〕
				　【NGKI3000】
				・属するクラスの指定が有効範囲外〔sM〕【NGKI3001】
				・クラスの囲みの中に記述されていない〔SM〕【NGKI3002】
				・その他の条件については機能の項を参照
	E_PAR		パラメータエラー
				・intnoが有効範囲外【NGKI3003】
				・isrがプログラムの先頭番地として正しくない【NGKI3004】
				・isrpriが有効範囲外【NGKI3005】
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する管理操作が許可されていない〔sP〕
				　【NGKI3006】
	E_MACV		メモリアクセス違反
				・pk_cisrが指すメモリ領域への読出しアクセスが許可されて
				　いない〔sP〕【NGKI3007】
	E_NOID		ID番号不足
				・割り付けられる割込みサービスルーチンIDがない〔sD〕
				　【NGKI3008】
	E_OBJ		オブジェクト状態エラー
				・isridで指定した割込みサービスルーチンが登録済み
				　（CRE_ISRの場合）【NGKI3009】
				・その他の条件については機能の項を参照
----

【機能】

各パラメータで指定した割込みサービスルーチン生成情報に従って，割込みサー
ビスルーチンを生成する【NGKI3010】．

ATT_ISRによって生成された割込みサービスルーチンは，ID番号を持たない
【NGKI3011】．

intnoで指定した割込み要求ラインの属性が設定されていない場合には，E_OBJ
エラーとなる【NGKI3012】．また，intnoで指定した割込み番号に対応する割込
みハンドラ番号に対して，割込みハンドラを定義する機能（DEF_INH，def_inh）
によって割込みハンドラが定義されている場合にも，E_OBJエラーとなる
【NGKI3013】．さらに，intno でカーネル管理外の割込みを指定した場合にも，
E_OBJエラーとなる【NGKI3014】．

静的APIにおいては，isridはオブジェクト識別名，isratr，intno，isrpriは整
数定数式パラメータ，exinfとisrは一般定数式パラメータである【NGKI3015】．

マルチプロセッサ対応カーネルで，生成する割込みサービスルーチンの属する
クラスの割付け可能プロセッサが，intnoで指定した割込み要求ラインが接続さ
れたプロセッサの集合に含まれていない場合には，E_RSATRエラーとなる
【NGKI3016】．また，intnoで指定した割込み要求ラインに対して登録済みの割
込みサービスルーチンがある場合に，生成する割込みサービスルーチンがそれ
と異なるクラスに属する場合にも，E_RSATRエラーとなる【NGKI3017】．さらに，
ターゲット定義で，割込みサービスルーチンが属することができるクラスに制
限がある場合がある【NGKI3018】．生成する割込みサービスルーチンの属する
クラスが，ターゲット定義の制限に合致しない場合にも，E_RSATRエラーとなる
【NGKI3019】．

静的APIにおいて，isrが不正である場合にE_PARエラーが検出されるか否かは，
ターゲット定義である【NGKI3020】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，ATT_ISRのみをサポートする【ASPS0209】．ただし，動的生
成機能拡張パッケージでは，acre_isrもサポートする【ASPS0195】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，ATT_ISRのみをサポートする【FMPS0161】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，ATT_ISRのみをサポートする【HRPS0161】．ただし，動的生
成機能拡張パッケージでは，acre_isrもサポートする【HRPS0208】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，ATT_ISRのみをサポートする【SSPS0139】．

【μITRON4.0仕様との関係】

割込みサービスルーチンの生成情報に，isrpri（割込みサービスルーチンの割
込み優先度）を追加した．CRE_ISRは，μITRON4.0仕様に定義されていない静的
APIである．

[[API_AID_ISR]]
----
AID_ISR		割付け可能な割込みサービスルーチンIDの数の指定〔SD〕【NGKI3021】
----

【静的API】
----
	AID_ISR(uint_t noisr)
----

【パラメータ】
----
	uint_t		noisr		割付け可能な割込みサービスルーチンIDの数
----

【エラーコード】
----
	E_RSATR		予約属性
				・保護ドメインの囲みの中に記述されている〔P〕【NGKI3439】
				・クラスの囲みの中に記述されていない〔M〕【NGKI3022】
	E_PAR		パラメータエラー
				・noisrが負の値【NGKI3287】
----

【機能】

noisrで指定した数の割込みサービスルーチンIDを，割込みサービスルーチンを
生成するサービスコールによって割付け可能な割込みサービスルーチンIDとし
て確保する【NGKI3024】．

noisrは整数定数式パラメータである【NGKI3025】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルの動的生成機能拡張パッケージでは，AID_ISRをサポートする
【ASPS0219】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルの動的生成機能拡張パッケージでは，AID_ISRをサポートする
【HRPS0220】．


[[API_SAC_ISR]]
----
SAC_ISR		割込みサービスルーチンのアクセス許可ベクタの設定〔SP〕【NGKI3026】
sac_isr		割込みサービスルーチンのアクセス許可ベクタの設定〔TPD〕【NGKI3027】
----

【静的API】
----
	SAC_ISR(ID isrid, { ACPTN acptn1, ACPTN acptn2,
										ACPTN acptn3, ACPTN acptn4 })
----

【C言語API】
----
	ER ercd = sac_isr(ID isrid, const ACVCT *p_acvct)
----


【パラメータ】
----
	ID			isrid		対象割込みサービスルーチンのID番号
	ACVCT *		p_acvct		アクセス許可ベクタを入れたパケットへのポ
							インタ（静的APIを除く）

　＊アクセス許可ベクタ（パケットの内容）
	ACPTN		acptn1		通常操作1のアクセス許可パターン
	ACPTN		acptn2		通常操作2のアクセス許可パターン
	ACPTN		acptn3		管理操作のアクセス許可パターン
	ACPTN		acptn4		参照操作のアクセス許可パターン
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI3028】
				・CPUロック状態からの呼出し〔s〕【NGKI3029】
	E_ID		不正ID番号
				・isridが有効範囲外〔s〕【NGKI3030】
	E_RSATR		予約属性
				・カーネルドメインの囲みの中に記述されていない〔S〕【NGKI3031】
				・対象割込みサービスルーチンが属するクラスの囲みの中に
				　記述されていない〔SM〕【NGKI3032】
	E_NOEXS		オブジェクト未登録
				・対象割込みサービスルーチンが未登録【NGKI3033】
	E_OACV		オブジェクトアクセス違反
				・対象割込みサービスルーチンに対する管理操作が許可され
				　ていない）〔s〕【NGKI3034】
	E_MACV		メモリアクセス違反
				・p_acvctが指すメモリ領域への読出しアクセスが許可されて
				　いない）〔s〕【NGKI3035】
	E_OBJ		オブジェクト状態エラー
				・対象割込みサービスルーチンは静的APIで生成された〔s〕
				　【NGKI3036】
				・対象割込みサービスルーチンに対してアクセス許可ベクタ
				　が設定済み〔S〕【NGKI3037】
----

【機能】

isridで指定した割込みサービスルーチン（対象割込みサービスルーチン）のア
クセス許可ベクタ（4つのアクセス許可パターンの組）を，各パラメータで指定
した値に設定する【NGKI3038】．

静的APIにおいては，isridはオブジェクト識別名，acptn1〜acptn4は整数定数
式パラメータである【NGKI3039】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，SAC_ISR，sac_isrをサポートしない【HRPS0162】．ただし，
動的生成機能拡張パッケージでは，sac_isrをサポートする【HRPS0209】．

【未決定事項】

割込みサービスルーチンのアクセス許可ベクタを設けず，システム状態のアク
セス許可ベクタでアクセス保護する方法も考えられる．


[[API_del_isr]]
----
del_isr		割込みサービスルーチンの削除〔TD〕【NGKI3040】
----

【C言語API】
----
	ER ercd = del_isr(ID isrid)
----

【パラメータ】
----
	ID			isrid		対象割込みサービスルーチンのID番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI3041】
				・CPUロック状態からの呼出し【NGKI3042】
	E_ID		不正ID番号
				・isridが有効範囲外【NGKI3043】
	E_NOEXS		オブジェクト未登録
				・対象割込みサービスルーチンが未登録【NGKI3044】
	E_OACV		オブジェクトアクセス違反
				・対象割込みサービスルーチンに対する管理操作が許可され
				　ていない〔P〕【NGKI3045】
	E_OBJ		オブジェクト状態エラー
				・対象割込みサービスルーチンは静的APIで生成された【NGKI3046】
----

【機能】

isridで指定した割込みサービスルーチン（対象割込みサービスルーチン）を削
除する．具体的な振舞いは以下の通り．

対象割込みサービスルーチンの登録が解除され，その割込みサービスルーチン
IDが未使用の状態に戻される【NGKI3047】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，del_isrをサポートしない【ASPS0197】．ただし，動的生成
機能拡張パッケージでは，del_isrをサポートする【ASPS0198】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，del_isrをサポートしない【FMPS0163】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，del_isrをサポートしない【HRPS0163】．ただし，動的生成
機能拡張パッケージでは，del_isrをサポートする【HRPS0210】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，del_isrをサポートしない【SSPS0141】．

[[API_ref_isr]]
----
ref_isr		割込みサービスルーチンの状態参照〔T〕
----

【C言語API】
----
	ER ercd = ref_isr(ID isrid, T_RISR *pk_risr)
----

☆未完成

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，ref_isrをサポートしない．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，ref_isrをサポートしない．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，ref_isrをサポートしない．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，ref_isrをサポートしない．


[[API_DEF_INH]]
----
DEF_INH		割込みハンドラの定義〔S〕【NGKI3048】
def_inh		割込みハンドラの定義〔TD〕【NGKI3049】
----

【静的API】
----
	DEF_INH(INHNO inhno, { ATR inhatr, INTHDR inthdr })
----

【C言語API】
----
	ER ercd = def_inh(INHNO inhno, const T_DINH *pk_dinh)
----

【パラメータ】
----
	INHNO		inhno		割込みハンドラ番号
	T_DINH *	pk_dinh		割込みハンドラの定義情報を入れたパケットへ
							のポインタ（静的APIを除く）

　＊割込みハンドラの定義情報（パケットの内容）
	ATR			inhatr		割込みハンドラ属性
	INTHDR		inthdr		割込みハンドラの先頭番地
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI3050】
				・CPUロック状態からの呼出し〔s〕【NGKI3051】
	E_RSATR		予約属性
				・inhatrが無効【NGKI3052】
				・属するクラスの指定が有効範囲外〔sM〕【NGKI3053】
				・クラスの囲みの中に記述されていない〔SM〕【NGKI3054】
				・その他の条件については機能の項を参照
	E_PAR		パラメータエラー
				・inhnoが有効範囲外【NGKI3055】
				・inthdrがプログラムの先頭番地として正しくない【NGKI3056】
				・その他の条件については機能の項を参照
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する管理操作が許可されていない〔sP〕
				　【NGKI3057】
	E_MACV		メモリアクセス違反
				・pk_dinhが指すメモリ領域への読出しアクセスが許可されて
				　いない〔sP〕【NGKI3058】
	E_OBJ		オブジェクト状態エラー
				・条件については機能の項を参照
----

【機能】

inhnoで指定した割込みハンドラ番号（対象割込みハンドラ番号）に対して，各
パラメータで指定した割込みハンドラ定義情報に従って，割込みハンドラを定
義する【NGKI3059】．ただし，def_inhにおいてpk_dinhをNULLにした場合には，
対象割込みハンドラ番号に対する割込みハンドラの定義を解除する【NGKI3060】．

静的APIにおいては，inhnoとinhatrは整数定数式パラメータ，inthdrは一般定
数式パラメータである【NGKI3061】．

割込みハンドラを定義する場合（DEF_INHの場合およびdef_inhにおいて
pk_dinhをNULL以外にした場合）には，次のエラーが検出される．

対象割込みハンドラ番号に対応する割込み要求ラインの属性が設定されていな
い場合には，E_OBJエラーとなる【NGKI3062】．また，対象割込みハンドラ番号
に対してすでに割込みハンドラが定義されている場合と，対象割込みハンドラ
番号に対応する割込み番号を対象に割込みサービスルーチンが登録されている
場合にも，E_OBJエラーとなる【NGKI3063】．

ターゲット定義の拡張で，カーネル管理外の割込みに対しても割込みハンドラ
を定義できる場合には，次のエラーが検出される【NGKI3064】．カーネル管理
外の割込みハンドラを対象として，inhatrにTA_NONKERNELを指定しない場合に
は，E_OBJエラーとなる【NGKI3065】．逆に，カーネル管理の割込みハンドラを
対象として，inhatrにTA_NONKERNELを指定した場合にも，E_OBJエラーとなる
【NGKI3066】．また，ターゲット定義でカーネル管理外に固定されている割込
みハンドラがある場合には，それを対象割込みハンドラに指定して，inhatrに
TA_NONKERNELを指定しない場合には，E_RSATRエラーとなる【NGKI3067】．逆に，
ターゲット定義でカーネル管理に固定されている割込みハンドラがある場合に
は，それを対象割込みハンドラに指定して，inhatrにTA_NONKERNELを指定した
場合には，E_RSATRエラーとなる【NGKI3068】．

保護機能対応カーネルにおいて，DEF_INHは，カーネルドメインの囲みの中に記
述しなければならない．そうでない場合には，E_RSATRエラーとなる
【NGKI3070】．また，def_inhで割込みハンドラを定義する場合には，割込みハ
ンドラの属する保護ドメインを設定する必要はなく，割込みハンドラ属性に
TA_DOM(domid)を指定した場合にはE_RSATRエラーとなる【NGKI3071】．ただし，
TA_DOM(TDOM_SELF)を指定した場合には，指定が無視され，E_RSATRエラーは検
出されない【NGKI3072】．

マルチプロセッサ対応カーネルで，登録する割込みハンドラの属するクラスの
初期割付けプロセッサが，その割込みが要求されるプロセッサでない場合には，
E_RSATRエラーとなる【NGKI3073】．また，ターゲット定義で，割込みハンドラ
が属することができるクラスに制限がある場合がある【NGKI3074】．登録する
割込みハンドラの属するクラスが，ターゲット定義の制限に合致しない場合に
も，E_RSATRエラーとなる【NGKI3075】．

割込みハンドラの定義を解除する場合（def_inhにおいてpk_dinhをNULLにした
場合）で，対象割込みハンドラ番号に対して割込みハンドラが定義されていな
い場合には，E_OBJエラーとなる【NGKI3076】．また，対象割込みハンドラ番号
に対して定義された割込みハンドラが，静的APIで定義されたものである場合に
は，ターゲット定義でE_OBJエラーとなる場合がある【NGKI3077】．

ターゲット定義で，対象割込みハンドラを定義（または定義解除）できない場
合には，E_PARエラーとなる【NGKI3078】．具体的には，マルチプロセッサ対応
カーネルにおいて，def_inhを呼び出したタスクが割り付けられているプロセッ
サから，対象割込みハンドラを定義（または定義解除）できない場合が，これ
に該当する【NGKI3079】．

静的APIにおいて，inthdrが不正である場合にE_PARエラーが検出されるか否か
は，ターゲット定義である【NGKI3080】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，DEF_INHのみをサポートする【ASPS0199】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，DEF_INHのみをサポートする【FMPS0164】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，DEF_INHのみをサポートする【HRPS0164】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，DEF_INHのみをサポートする【SSPS0142】．

【μITRON4.0仕様との関係】

inthdrのデータ型をINTHDRに変更した．

def_inhによって定義済みの割込みハンドラを再定義しようとした場合に，
E_OBJエラーとすることにした．割込みハンドラの定義を変更するには，一度定
義を解除してから，再度定義する必要がある．


[[API_dis_int]]
----
dis_int		割込みの禁止〔T〕【NGKI3081】
----

【C言語API】
----
	ER ercd = dis_int(INTNO intno)
----

【パラメータ】
----
	INTNO		intno		割込み番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI3082】
	E_NOSPT		未サポートエラー
				・条件については機能の項を参照
	E_PAR		パラメータエラー
				・intnoが有効範囲外【NGKI3083】
				・その他の条件については機能の項を参照
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する通常操作2が許可されていない〔P〕
				　【NGKI3084】
	E_OBJ		オブジェクト状態エラー
				・対象割込み要求ラインに対して割込み要求ライン属性が設
				　定されていない【NGKI3085】
----

【機能】

intnoで指定した割込み要求ライン（対象割込み要求ライン）の割込み要求禁止
フラグをセットする【NGKI3086】．

ターゲット定義で，対象割込み要求ラインの割込み要求禁止フラグをセットで
きない場合には，E_PARエラーとなる【NGKI3087】．具体的には，対象割込み要
求ラインに対して割込み要求禁止フラグがサポートされていない場合や，マル
チプロセッサ対応カーネルにおいて，dis_intを呼び出したタスクが割り付けら
れているプロセッサから，対象割込み要求ラインの割込み要求禁止フラグが操
作できない場合が，これに該当する．

ターゲット定義で，割込み要求禁止フラグの振舞いが，この仕様の規定と異な
る場合がある【NGKI3089】．特にマルチプロセッサ対応カーネルでは，あるプ
ロセッサからdis_intを呼び出して割込み要求禁止フラグをセットしても，他の
プロセッサに対しては割込みがマスクされない場合がある．

ターゲット定義で，dis_intがサポートされていない場合がある【NGKI3091】．
dis_intがサポートされている場合には，TOPPERS_SUPPORT_DIS_INTがマクロ定
義される【NGKI3092】．サポートされていない場合にdis_intを呼び出すと，
E_NOSPTエラーが返るか，リンク時にエラーとなる【NGKI3093】．

【μITRON4.0仕様との関係】

μITRON4.0仕様で実装定義としていたintnoの意味を標準化した．

CPUロック状態でも呼び出せるものとした．


[[API_ena_int]]
----
ena_int		割込みの許可〔T〕【NGKI3094】
----

【C言語API】
----
	ER ercd = ena_int(INTNO intno)
----

【パラメータ】
----
	INTNO		intno		割込み番号
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI3095】
	E_NOSPT		未サポートエラー
				・条件については機能の項を参照
	E_PAR		パラメータエラー
				・intnoが有効範囲外【NGKI3096】
				・その他の条件については機能の項を参照
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する通常操作2が許可されていない〔P〕
				　【NGKI3097】
	E_OBJ		オブジェクト状態エラー
				・対象割込み要求ラインに対して割込み要求ライン属性が設
				　定されていない【NGKI3098】
----

【機能】

intnoで指定した割込み要求ライン（対象割込み要求ライン）の割込み要求禁止
フラグをクリアする【NGKI3099】．

ターゲット定義で，対象割込み要求ラインの割込み要求禁止フラグをクリアで
きない場合には，E_PARエラーとなる【NGKI3100】．具体的には，対象割込み要
求ラインに対して割込み要求禁止フラグがサポートされていない場合や，マル
チプロセッサ対応カーネルにおいて，ena_intを呼び出したタスクが割り付けら
れているプロセッサから，対象割込み要求ラインの割込み要求禁止フラグが操
作できない場合が，これに該当する．

ターゲット定義で，割込み要求禁止フラグの振舞いが，この仕様の規定と異な
る場合がある【NGKI3102】．特にマルチプロセッサ対応カーネルでは，あるプ
ロセッサからena_intを呼び出して割込み要求禁止フラグをクリアしても，他の
プロセッサに対しては割込みがマスク解除されない場合がある．

ターゲット定義で，ena_intがサポートされていない場合がある【NGKI3104】．
ena_intがサポートされている場合には，TOPPERS_SUPPORT_ENA_INTがマクロ定
義される【NGKI3105】．サポートされていない場合にena_intを呼び出すと，
E_NOSPTエラーが返るか，リンク時にエラーとなる【NGKI3106】．

【μITRON4.0仕様との関係】

μITRON4.0仕様で実装定義としていたintnoの意味を標準化した．

CPUロック状態でも呼び出せるものとした．

[[API_ref_int]]
----
ref_int		割込み要求ラインの参照〔T〕
----

【C言語API】
----
	ER ercd = ref_int(INTNO intno, T_RINT *pk_rint)
----

☆未完成

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，ref_intをサポートしない．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，ref_intをサポートしない．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，ref_intをサポートしない．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，ref_intをサポートしない．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていないサービスコールである．


[[API_chg_ipm]]
----
chg_ipm		割込み優先度マスクの変更〔T〕【NGKI3107】
----

【C言語API】
----
	ER ercd = chg_ipm(PRI intpri)
----

【パラメータ】
----
	PRI			intpri		割込み優先度マスク
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI3108】
				・CPUロック状態からの呼出し【NGKI3109】
	E_PAR		パラメータエラー
				・条件については機能の項を参照
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する通常操作2が許可されていない〔P〕
				　【NGKI3110】
----

【機能】

割込み優先度マスクを，intpriで指定した値に変更する【NGKI3111】．

intpriは，TMIN_INTPRI以上，TIPM_ENAALL以下でなければならない．そうでな
い場合には，E_PARエラーとなる【NGKI3113】．ただし，ターゲット定義の拡張
として，TMIN_INTPRIよりも小さい値を指定できる場合がある【NGKI3114】．

【補足説明】

割込み優先度マスクをTIPM_ENAALLに変更した場合，ディスパッチ保留状態が解
除され，ディスパッチが起こる可能性がある．また，タスク例外処理ルーチン
の実行が開始される可能性がある．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，chg_ipmをサポートしない【SSPS0143】．

【μITRON4.0仕様との関係】

μITRON4.0仕様では，サービスコールの名称およびパラメータの名称が実装定
義となっているサービスコールである．

[[API_get_ipm]]
----
get_ipm		割込み優先度マスクの参照〔T〕【NGKI3115】
----

【C言語API】
----
	ER ercd = get_ipm(PRI *p_intpri)
----

【パラメータ】
----
	PRI *		p_intpri	割込み優先度マスクを入れるメモリ領域へのポ
							インタ
----

【リターンパラメータ】
----
	ER			ercd		エラーコード
	PRI			intpri		割込み優先度マスク
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し【NGKI3116】
				・CPUロック状態からの呼出し【NGKI3117】
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する参照操作が許可されていない〔P〕
				　【NGKI3118】
	E_MACV		メモリアクセス違反
				・p_intpriが指すメモリ領域への書込みアクセスが許可され
				　ていない〔P〕【NGKI3119】
----

【機能】

割込み優先度マスクの現在値を参照する．参照した割込み優先度マスクは，
p_intpriが指すメモリ領域に返される【NGKI3120】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，get_ipmをサポートしない【SSPS0144】．

【μITRON4.0仕様との関係】

μITRON4.0仕様では，サービスコールの名称およびパラメータの名称が実装定
義となっているサービスコールである．

=== CPU例外管理機能

CPU例外ハンドラは，カーネルが実行を制御する処理単位である．CPU例外ハン
ドラは，CPU例外ハンドラ番号と呼ぶオブジェクト番号によって識別する
【NGKI3121】．

保護機能対応カーネルにおいて，CPU例外ハンドラは，カーネルドメインに属す
る【NGKI3122】．

CPU例外ハンドラ属性に標準で指定できる属性はないが，ターゲットによっては，
ターゲット定義のCPU例外ハンドラ属性を指定できる場合がある【NGKI3123】．
ターゲット定義のCPU例外ハンドラ属性として，次の属性を予約している
【NGKI3124】．

	TA_DIRECT			CPU例外ハンドラを直接呼び出す

C言語によるCPU例外ハンドラの記述形式は次の通り【NGKI3125】．

[source,c]
----
	void cpu_exception_handler(void *p_excinf)
	{
		CPU例外ハンドラ本体
	}
----

p_excinfには，CPU例外の情報を記憶しているメモリ領域の先頭番地が渡される
【NGKI3126】．これは，CPU例外ハンドラ内で，CPU例外発生時の状態を参照す
る際に必要となる．

[[API_DEF_EXC]]
----
DEF_EXC		CPU例外ハンドラの定義〔S〕【NGKI3127】
def_exc		CPU例外ハンドラの定義〔TD〕【NGKI3128】
----

【静的API】
----
	DEF_EXC(EXCNO excno, { ATR excatr, EXCHDR exchdr })
----

【C言語API】
----
	ER ercd = def_exc(EXCNO excno, const T_DEXC *pk_dexc)
----

【パラメータ】
----
	EXCNO		excno		CPU例外ハンドラ番号
	T_DEXC *	pk_dexc		CPU例外ハンドラの定義情報を入れたパケットへ
							のポインタ（静的APIを除く）

　＊CPU例外ハンドラの定義情報（パケットの内容）
	ATR			excatr		CPU例外ハンドラ属性
	EXCHDR		exchdr		CPU例外ハンドラの先頭番地
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI3129】
				・CPUロック状態からの呼出し〔s〕【NGKI3130】
	E_RSATR		予約属性
				・excatrが無効【NGKI3131】
				・属するクラスの指定が有効範囲外〔sM〕【NGKI3132】
				・クラスの囲みの中に記述されていない〔SM〕【NGKI3133】
				・その他の条件については機能の項を参照
	E_PAR		パラメータエラー
				・excnoが有効範囲外【NGKI3134】
				・exchdrがプログラムの先頭番地として正しくない【NGKI3135】
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する管理操作が許可されていない〔sP〕
				　【NGKI3136】
	E_MACV		メモリアクセス違反
				・pk_dexcが指すメモリ領域への読出しアクセスが許可されて
				　いない〔sP〕【NGKI3137】
	E_OBJ		オブジェクト状態エラー
				・条件については機能の項を参照
----

【機能】

excnoで指定したCPU例外ハンドラ番号（対象CPU例外ハンドラ番号）に対して，
各パラメータで指定したCPU例外ハンドラ定義情報に従って，CPU例外ハンドラ
を定義する【NGKI3138】．ただし，def_excにおいてpk_dexcをNULLにした場合
には，対象CPU例外ハンドラ番号に対するCPU例外ハンドラの定義を解除する
【NGKI3139】．

静的APIにおいては，excnoとexcatrは整数定数式パラメータ，exchdrは一般定
数式パラメータである【NGKI3140】．

CPU例外ハンドラを定義する場合（DEF_EXCの場合およびdef_excにおいて
pk_dexcをNULL以外にした場合）で，対象CPU例外ハンドラ番号に対してすでに
CPU例外ハンドラが定義されている場合には，E_OBJエラーとなる【NGKI3141】．

保護機能対応カーネルにおいて，DEF_EXCは，カーネルドメインの囲みの中に記
述しなければならない．そうでない場合には，E_RSATRエラーとなる
【NGKI3143】．また，def_excでCPU例外ハンドラを定義する場合には，CPU例外
ハンドラの属する保護ドメインを設定する必要はなく，CPU例外ハンドラ属性に
TA_DOM(domid)を指定した場合にはE_RSATRエラーとなる【NGKI3144】．ただし，
TA_DOM(TDOM_SELF)を指定した場合には，指定が無視され，E_RSATRエラーは検
出されない【NGKI3145】．

マルチプロセッサ対応カーネルで，登録するCPU例外ハンドラの属するクラスの
初期割付けプロセッサが，そのCPU例外が発生するプロセッサでない場合には，
E_RSATRエラーとなる【NGKI3146】．

CPU例外ハンドラの定義を解除する場合（def_excにおいてpk_dexcをNULLにした
場合）で，対象CPU例外ハンドラ番号に対してCPU例外ハンドラが定義されてい
ない場合には，E_OBJエラーとなる【NGKI3147】．また，対象CPU例外ハンドラ
番号に対して定義されたCPU例外ハンドラが，静的APIで定義されたものである
場合には，ターゲット定義でE_OBJエラーとなる場合がある【NGKI3148】．

静的APIにおいて，exchdrが不正である場合にE_PARエラーが検出されるか否か
は，ターゲット定義である【NGKI3149】．

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，DEF_EXCのみをサポートする【ASPS0200】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，DEF_EXCのみをサポートする【FMPS0165】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，DEF_EXCのみをサポートする【HRPS0165】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，DEF_EXCのみをサポートする【SSPS0145】．

【μITRON4.0仕様との関係】

def_excによって，定義済みのCPU例外ハンドラを再定義しようとした場合に，
E_OBJエラーとすることにした．

[[API_xsns_dpn]]
----
xsns_dpn	CPU例外発生時のディスパッチ保留状態の参照〔TI〕【NGKI3150】
----

【C言語API】
----
	bool_t stat = xsns_dpn(void *p_excinf)
----

【パラメータ】
----
	void *		p_excinf	CPU例外の情報を記憶しているメモリ領域の先頭
							番地
----

【リターンパラメータ】
----
	bool_t		state		ディスパッチ保留状態
----

【機能】

CPU例外発生時のディスパッチ保留状態を参照する．具体的な振舞いは以下の通
り．

実行中のCPU例外ハンドラの起動原因となったCPU例外が，カーネル管理外の
CPU例外でなく，タスクコンテキストで発生し，そのタスクがディスパッチ保留
状態でなかった場合にfalse，そうでない場合にtrueが返る【NGKI3151】．

保護機能対応のカーネルにおいて，xsns_dpnをタスクコンテキストから呼び出
した場合には，trueが返る【NGKI3152】．

p_excinfには，CPU例外ハンドラに渡されるp_excinfパラメータをそのまま渡す
【NGKI3153】．それ以外の値を渡した場合の動作は保証されない【NGKI3552】．

【使用方法】

xsns_dpnは，CPU例外ハンドラの中で，どのようなリカバリ処理が可能かを判別
したい場合に使用する．xsns_dpnがfalseを返した場合（trueを返した場合では
ないので注意すること），非タスクコンテキスト用のサービスコールを用いて
CPU例外を起こしたタスクよりも優先度の高いタスクを起動または待ち解除し，
そのタスクでリカバリ処理を行うことができる．ただし，CPU例外を起こしたタ
スクが最高優先度の場合には，この方法でリカバリ処理を行うことはできない．

【使用上の注意】

xsns_dpnは，E_CTXエラーを返すことがないために〔TI〕となっているが，CPU
例外ハンドラから呼び出すためのものである．CPU例外ハンドラ以外から呼び出
した場合や，p_excinfに正しい値を渡さなかった場合，xsns_dpnが返す値は意
味を持たない．

どちらの条件でtrueが返るか間違いやすいので注意すること．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，xsns_dpnをサポートしない【SSPS0146】．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていないサービスコールである．

【仕様決定の理由】

保護機能対応のカーネルにおいては，xsns_dpnをユーザドメインから呼び出す
ことは禁止すべきである．ユーザドメインの実行中は，必ずタスクコンテキス
トであるため，xsns_dpnをタスクコンテキストから呼び出した場合に必ずtrue
を返す仕様とすることで，xsns_dpnをユーザドメインから呼び出すことを実質
的に禁止している．


[[APIxsns_xpn]]
----
xsns_xpn	CPU例外発生時のタスク例外処理保留状態の参照〔TI〕【NGKI3154】
----

【C言語API】
----
	bool_t stat = xsns_xpn(void *p_excinf)
----

【パラメータ】
----
	void *		p_excinf	CPU例外の情報を記憶しているメモリ領域の先頭
							番地
----

【リターンパラメータ】
----
	bool_t		state		タスク例外処理保留状態
----

【機能】

CPU例外発生時にタスク例外処理ルーチンを実行開始できない状態であったかを
参照する．具体的な振舞いは以下の通り．

実行中のCPU例外ハンドラの起動原因となったCPU例外が，カーネル管理外の
CPU例外でなく，タスクコンテキストで発生し，そのタスクがタスク例外処理ルー
チンを実行開始できる状態であった場合にfalse，そうでない場合にtrueが返る
【NGKI3155】．

保護機能対応カーネルにおいて，CPU例外が発生したタスクがユーザタスクの場
合には，ユーザスタック領域の残りが少なく，タスク例外処理ルーチンを実行
開始できない（タスク例外処理ルーチンを実行開始しようとすると，タスク例
外実行開始時スタック不正例外が発生する）場合にも，trueを返す【NGKI3156】．

保護機能対応のカーネルにおいて，xsns_xpnをタスクコンテキストから呼び出
した場合には，trueが返る【NGKI3157】．

p_excinfには，CPU例外ハンドラに渡されるp_excinfパラメータをそのまま渡す
【NGKI3158】．

【使用方法】

xsns_xpnは，CPU例外ハンドラの中で，どのようなリカバリ処理が可能かを判別
したい場合に使用する．xsns_xpnがfalseを返した場合（trueを返した場合では
ないので注意すること），非タスクコンテキスト用のサービスコールを用いて
CPU例外を起こしたタスクにタスク例外を要求し，タスク例外処理ルーチンでリ
カバリ処理を行うことができる．

【使用上の注意】

xsns_xpnは，E_CTXエラーを返すことがないために〔TI〕となっているが，CPU
例外ハンドラから呼び出すためのものである．CPU例外ハンドラ以外から呼び出
した場合や，p_excinfに正しい値を渡さなかった場合，xsns_xpnが返す値は意
味を持たない．

どちらの条件でtrueが返るか間違いやすいので注意すること．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，xsns_xpnをサポートしない【SSPS0147】．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていないサービスコールである．

【仕様決定の理由】

保護機能対応のカーネルにおいては，xsns_xpnをユーザドメインから呼び出す
ことは禁止すべきである．ユーザドメインの実行中は，必ずタスクコンテキス
トであるため，xsns_xpnをタスクコンテキストから呼び出した場合に必ずtrue
を返す仕様とすることで，xsns_xpnをユーザドメインから呼び出すことを実質
的に禁止している．


=== 拡張サービスコール管理機能

拡張サービスコールは，非特権モードで実行される処理単位から，特権モード
で実行すべきルーチンを呼び出すための機能である【NGKI3159】．特権モード
で実行するルーチンを，拡張サービスコールと呼ぶ．拡張サービスコールは，
特権モードで実行される処理単位からも呼び出すことができる【NGKI3160】．

保護機能対応カーネルにおいて，拡張サービスコールは，カーネルドメインに
属する【NGKI3161】．拡張サービスコールは，それを呼び出す処理単位とは別
の処理単位であり，拡張サービスコールからカーネルオブジェクトをアクセス
する場合には，拡張サービスコールがアクセスの主体となる【NGKI3162】．そ
のため，拡張サービスコールからは，すべてのカーネルオブジェクトに対して，
すべての種別のアクセスを行うことが許可される．

保護機能対応でないカーネルでは，非特権モードと特権モードの区別がないた
め，拡張サービスコール管理機能をサポートしない【NGKI3163】．

拡張サービスコール属性に指定できる属性はない【NGKI3686】．そのため拡張
サービスコール属性には，TA_NULLを指定しなければならない【NGKI3687】．

C言語による拡張サービスコールの記述形式は次の通り【NGKI3164】．

[source,c]
----
	ER_UINT extended_svc(intptr_t par1, intptr_t par2, intptr_t par3,
								intptr_t par4, intptr_t par5, ID cdmid)
	{
		拡張サービスコール本体
	}
----

cdmidには，拡張サービスコールを呼び出した処理単位が属する保護ドメインの
ID番号が渡される【NGKI3165】．すなわち，拡張サービスコールから呼び出し
た場合にはTDOM_KERNEL（＝-1）が，タスク本体（拡張サービスコールを除く）
から呼び出した場合にはそのタスク（自タスク）の属する保護ドメインIDが渡
される．

par1〜par5には，拡張サービスコールに対するパラメータが渡される
【NGKI3166】．

拡張サービスコール管理機能に関連するカーネル構成マクロは次の通り．

	TMAX_FNCD		拡張サービスコールの機能番号の最大値（動的生成対応
					カーネルでは，登録できる拡張サービスコールの数に一
					致）【NGKI3167】

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，拡張サービスコール管理機能をサポートしない【ASPS0201】．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，拡張サービスコール管理機能をサポートしない【FMPS0166】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，拡張サービスコール管理機能をサポートする【HRPS0166】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，拡張サービスコール管理機能をサポートしない【SSPS0148】．

【未決定事項】

動的生成対応カーネルにおいてTMAX_FNCDを設定する方法については，現時点で
は未決定である．

【μITRON4.0仕様との関係】

この仕様では，拡張サービスコールに対するパラメータを，intptr_t型のパラ
メータ5個に固定した．

拡張サービスコールに，それを呼び出した処理単位が属する保護ドメインのID
番号を渡す機能を追加した．

TMAX_FNCDは，μITRON4.0仕様に規定されていないカーネル構成マクロである．


[[API_DEF_SVC]]
----
DEF_SVC		拡張サービスコールの定義〔SP〕【NGKI3168】
def_svc		拡張サービスコールの定義〔TPD〕【NGKI3169】
----

【静的API】
----
	DEF_SVC(FN fncd, { ATR svcatr, EXTSVC extsvc, SIZE stksz })
----

【C言語API】
----
	ER ercd = def_svc(FN fncd, const T_DSVC *pk_dsvc)
----

【パラメータ】
----
	FN			fncd		拡張サービスコールの機能コード
	T_DSVC *	pk_dsvc		拡張サービスコールの定義情報を入れたパケッ
							トへのポインタ（静的APIを除く）

　＊拡張サービスコールの定義情報（パケットの内容）
	ATR			svcatr		拡張サービスコール属性
	EXTSVC		extsvc		拡張サービスコールの先頭番地
	SIZE		stksz		拡張サービスコールで使用するスタックサイズ
----

【リターンパラメータ】
----
	ER			ercd		正常終了（E_OK）またはエラーコード
----

【エラーコード】
----
	E_CTX		コンテキストエラー
				・非タスクコンテキストからの呼出し〔s〕【NGKI3170】
				・CPUロック状態からの呼出し〔s〕【NGKI3171】
	E_RSATR		予約属性
				・svcatrが無効【NGKI3172】
				・その他の条件については機能の項を参照
	E_PAR		パラメータエラー
				・fncdが0または負の値【NGKI3173】
				・fncdがTMAX_FNCDよりも大きい〔s〕【NGKI3174】
				・extsvcがプログラムの先頭番地として正しくない【NGKI3175】
				・stkszが負の値〔S〕【NGKI3290】
	E_OACV		オブジェクトアクセス違反
				・システム状態に対する管理操作が許可されていない〔s〕
				　【NGKI3176】
	E_MACV		メモリアクセス違反
				・pk_dsvcが指すメモリ領域への読出しアクセスが許可されて
				　いない〔s〕【NGKI3177】
	E_OBJ		オブジェクト状態エラー
				・条件については機能の項を参照
----

【機能】

fncdで指定した機能コード（対象機能コード）に対して，各パラメータで指定
した拡張サービスコール定義情報に従って，拡張サービスコールを定義する
【NGKI3178】．ただし，def_svcにおいてpk_dsvcをNULLにした場合には，対象
機能コードに対する拡張サービスコールの定義を解除する【NGKI3179】．

静的APIにおいては，fncd，svcatr，stkszは整数定数式パラメータ，svchdrは
一般定数式パラメータである【NGKI3180】．

拡張サービスコールを定義する場合（DEF_SVCの場合およびdef_svcにおいて
pk_dsvcをNULL以外にした場合）で，対象機能コードに対してすでに拡張サービ
スコールが定義されている場合には，E_OBJエラーとなる【NGKI3181】．

DEF_SVCは，カーネルドメインの囲みの中に記述しなければならない．そうでな
い場合には，E_RSATRエラーとなる【NGKI3183】．また，def_svcで拡張サービ
スコールを定義する場合には，拡張サービスコールの属する保護ドメインを設
定する必要はなく，拡張サービスコール属性にTA_DOM(domid)を指定した場合に
はE_RSATRエラーとなる【NGKI3184】．ただし，TA_DOM(TDOM_SELF)を指定した
場合には，指定が無視され，E_RSATRエラーは検出されない【NGKI3185】．

マルチプロセッサ対応カーネルでは，DEF_SVCは，クラスの囲みの外に記述しな
ければならない．そうでない場合には，E_RSATRエラーとなる【NGKI3187】．ま
た，def_svcで拡張サービスコールを定義する場合には，拡張サービスコールの
属するクラスを設定する必要はなく，拡張サービスコール属性に
TA_CLS(clsid)を指定した場合にはE_RSATRエラーとなる【NGKI3188】．ただし，
TA_CLS(TCLS_SELF)を指定した場合には，指定が無視され，E_RSATRエラーは検
出されない【NGKI3189】．

拡張サービスコールの定義を解除する場合（def_svcにおいてpk_dsvcをNULLに
した場合）で，対象機能コードに対して拡張サービスコールが定義されていな
い場合には，E_OBJエラーとなる【NGKI3190】．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，DEF_SVCのみをサポートする【HRPS0167】．

【μITRON4.0仕様との関係】

拡張サービスコールの定義情報に，stksz（拡張サービスコールで使用するスタッ
クサイズ）を追加した．

extsvcのデータ型を，EXTSVCに変更した．

[[API_cal_svc]]
----
cal_svc		拡張サービスコールの呼出し〔TIP〕【NGKI3191】
----

【C言語API】
----
	ER_UINT ercd = cal_svc(FN fncd, intptr_t par1, intptr_t par2,
						intptr_t par3, intptr_t par4, intptr_t par5)
----

【パラメータ】
----
	FN			fncd		呼び出す拡張サービスコールの機能コード
	intptr_t	par1		拡張サービスコールへの第1パラメータ
	intptr_t	par2		拡張サービスコールへの第2パラメータ
	intptr_t	par3		拡張サービスコールへの第3パラメータ
	intptr_t	par4		拡張サービスコールへの第4パラメータ
	intptr_t	par5		拡張サービスコールへの第5パラメータ
----

【リターンパラメータ】
----
	ER_UINT		ercd		正常終了（正の値または0）またはエラーコード
----

【エラーコード】
----
	E_SYS		システムエラー
				・条件については機能の項を参照
	E_RSFN		予約機能コード
				・fncdが0または負の値【NGKI3192】
				・fncdがTMAX_FNCDよりも大きい【NGKI3193】
				・fncdで指定した機能コードに対して拡張サービスコールが
				　定義されていない【NGKI3194】
	E_NOMEM		メモリ不足
				・条件については機能の項を参照
　＊その他，拡張サービスコールが返すエラーコードがそのまま返る．
----

【機能】

fncdで指定した機能コードの拡張サービスコールを，par1，par2，…，par5を
パラメータとして呼び出し，拡張サービスコールの返値を返す【NGKI3195】．

また，タスクコンテキストから呼び出した場合には，次のエラーが検出される
【NGKI3196】．スタック（ユーザタスクの場合はシステムスタック）の残り領
域が，拡張サービスコールで使用するスタックサイズよりも小さい場合には，
E_NOMEMエラーとなる【NGKI3197】．また，拡張サービスコールのネストレベル
が上限（＝255）を超える場合には，E_SYSエラーが返る【NGKI3198】．

【μITRON4.0仕様との関係】

μITRON4.0仕様では，cal_svcでカーネルのサービスコールを呼び出せるかどう
かは実装定義としているが，この仕様では，カーネルのサービスコールを呼び
出せないこととした．

拡張サービスコールが呼び出される時に，スタックの残り領域のサイズをチェッ
クする機能を追加した．

拡張サービスコールに対するパラメータを，intptr_t型のパラメータ5個に固定
し，cal_svcから返るエラー（E_SYS，E_RSFN，E_NOMEM）について規定した．

【仕様決定の理由】

パラメータの型と数を固定したのは，型チェックを厳密にできるようにし，パ
ラメータをコンパイラやコーリングコンベンションによらずに正しく渡せるよ
うにするためである．


=== システム構成管理機能

システム構成管理機能には，非タスクコンテキスト用スタック領域を設定する
機能，初期化ルーチンと終了処理ルーチンを登録する機能，カーネルのコンフィ
ギュレーション情報やバージョン情報を参照する機能が含まれる．

非タスクコンテキスト用スタック領域は，非タスクコンテキストで実行される
処理単位が用いるスタック領域である．

保護機能対応カーネルにおいて，非タスクコンテキスト用のスタック領域は，
カーネルの用いるオブジェクト管理領域と同様に扱われる【NGKI3199】．

初期化ルーチンは，カーネルが実行を制御する処理単位で，カーネルの動作開
始の直前に，カーネル非動作状態で実行される【NGKI3200】．

保護機能対応カーネルにおいて，初期化ルーチンは，カーネルドメインに属す
る【NGKI3201】．

初期化ルーチン属性に指定できる属性はない【NGKI3202】．そのため初期化ルー
チン属性には，TA_NULLを指定しなければならない【NGKI3203】．

C言語による初期化ルーチンの記述形式は次の通り【NGKI3204】．

[source,c]
----
	void initialization_routine(intptr_t exinf)
	{
		初期化ルーチン本体
	}
----

exinfには，初期化ルーチンの拡張情報が渡される【NGKI3205】．

終了処理ルーチンは，カーネルが実行を制御する処理単位で，カーネルの動作
終了の直後に，カーネル非動作状態で実行される【NGKI3206】．

保護機能対応カーネルにおいて，終了処理ルーチンは，カーネルドメインに属
する【NGKI3207】．

終了処理ルーチン属性に指定できる属性はない【NGKI3208】．そのため終了処
理ルーチン属性には，TA_NULLを指定しなければならない【NGKI3209】．

C言語による終了処理ルーチンの記述形式は次の通り【NGKI3210】．

[source,c]
----
	void termination_routine(intptr_t exinf)
	{
		終了処理ルーチン本体
	}
----

exinfには，終了処理ルーチンの拡張情報が渡される【NGKI3211】．

【μITRON4.0仕様との関係】

非タスクコンテキスト用スタック領域の設定と，終了処理ルーチンは，
μITRON4.0仕様に規定されていない機能である．


[[API_LMT_DOM]]
----
LMT_DOM		保護ドメインに対する制限の設定〔SP〕【NGKI3441】
----

【静的API】
----
	LMT_DOM({ PRI mintpri })
----

【パラメータ】
----
　＊保護ドメインに対する制限の設定情報
	PRI			mintpri		指定できる最高のタスク優先度
----

【エラーコード】
----
	E_RSATR		予約属性
				・ユーザドメインの囲みの中に記述されていない【NGKI3442】
				・クラスの囲みの中に記述されている〔M〕【NGKI3443】
	E_OBJ		オブジェクト状態エラー
				・保護ドメインに対する制限が設定済み【NGKI3444】
	E_PAR		パラメータエラー
				・mintpriが有効範囲外【NGKI3445】
----

【機能】

パラメータで指定した保護ドメインに対する制限の設定情報に従って，ユーザ
ドメインに対する制限を設定する【NGKI3446】．

mintpriは整数定数式パラメータである【NGKI3447】．

LMT_DOMにより保護ドメインに対する制限を設定しないユーザドメインに対して
は，指定できる最高のタスク優先度はTMIN_TPRI＋1に設定される【NGKI3448】．

【μITRON4.0/PX仕様との関係】

μITRON4.0/PX仕様に定義されていない静的APIである．


[[API_DEF_ICS]]
----
DEF_ICS		非タスクコンテキスト用スタック領域の設定〔S〕【NGKI3212】
----

【静的API】
----
	DEF_ICS({ SIZE istksz, STK_T *istk })
----

【パラメータ】
----
　＊非タスクコンテキスト用スタック領域の設定情報
	SIZE		istksz		非タスクコンテキスト用スタック領域のサイズ
							（バイト数）
	STK_T		istk		非タスクコンテキスト用スタック領域の先頭番地
----

【エラーコード】
----
	E_RSATR		予約属性
				・カーネルドメインの囲みの中に記述されていない〔P〕【NGKI3213】
				・クラスの囲みの中に記述されていない〔M〕【NGKI3214】
	E_PAR		パラメータエラー
				・条件については機能の項を参照
	E_NOMEM		メモリ不足
				・非タスクコンテキスト用スタック領域が確保できない【NGKI3215】
	E_OBJ		オブジェクト状態エラー
				・非タスクコンテキスト用スタック領域が設定済み【NGKI3216】
				・その他の条件については機能の項を参照
----

【機能】

各パラメータで指定した非タスクコンテキスト用スタック領域の設定情報に従っ
て，非タスクコンテキスト用スタック領域を設定する【NGKI3217】．istkszに
0以下の値を指定した時や，ターゲット定義の最小値よりも小さい値を指定した
時には，E_PARエラーとなる【NGKI3254】．

istkszは整数定数式パラメータ，istkは一般定数式パラメータである．コンフィ
ギュレータは，静的APIのメモリ不足（E_NOMEM）エラーを検出することができ
ない【NGKI3218】．

istkをNULLとした場合，istkszで指定したサイズのスタック領域が，コンフィ
ギュレータにより確保される【NGKI3219】．istkszにターゲット定義の制約に
合致しないサイズを指定した時には，ターゲット定義の制約に合致するように
大きい方に丸めたサイズで確保される【NGKI3220】．

istkにNULL以外を指定した場合，istkとistkszで指定したスタック領域は，ア
プリケーションで確保しておく必要がある【NGKI3221】．スタック領域をアプ
リケーションで確保する方法については，「2.15.3 カーネル共通マクロ」の節
を参照すること．その方法に従わず，istkやistkszにターゲット定義の制約に
合致しない先頭番地やサイズを指定した時には，E_PARエラーとなる
【NGKI3222】．

保護機能対応カーネルでは，istkとistkszで指定した非タスクコンテキスト用
のスタック領域がカーネル専用のメモリオブジェクトに含まれない場合，
E_OBJエラーとなる【NGKI3223】．

DEF_ICSにより非タスクコンテキスト用スタック領域を設定しない場合，ターゲッ
ト定義のデフォルトのサイズのスタック領域が，コンフィギュレータにより確
保される【NGKI3224】．

マルチプロセッサ対応カーネルでは，非タスクコンテキスト用スタック領域は
プロセッサ毎に確保する必要がある【NGKI3225】．DEF_ICSにより設定する非タ
スクコンテキスト用スタック領域は，DEF_ICSの記述をその囲みの中に含むクラ
スの初期割付けプロセッサが使用する【NGKI3226】．そのプロセッサに対して
すでに非タスクコンテキスト用スタック領域が設定されている場合には，
E_OBJエラーとなる【NGKI3227】．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，istkにはNULLを指定しなくてはならず，その場合でも，コン
フィギュレータは非タスクコンテキスト用のスタック領域を確保しない
【SSPS0149】．これは，SSPカーネルでは，すべての処理単位が共有スタック領
域を使用し，非タスクコンテキストのみが用いるスタック領域を持たないため
である．そのため，DEF_ICSの役割は，非タスクコンテキストが用いるスタック
領域のサイズを指定することのみとなる．itskにNULL以外を指定した場合には，
E_PARエラーとなる【SSPS0150】．

共有スタック領域の設定方法については，DEF_STKの項を参照すること．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていない静的APIである．


[[API_DEF_STK]]
----
DEF_STK		共有スタック領域の設定〔S〕【NGKI3228】
----

【静的API】
----
	DEF_STK({ SIZE stksz, STK_T *stk })
----

【パラメータ】
----
　＊共有スタック領域の設定情報
	SIZE		stksz		共有スタック領域のサイズ（バイト数）
	STK_T		stk			共有スタック領域の先頭番地
----

【エラーコード】
----
	E_PAR		パラメータエラー
				・条件については機能の項を参照
	E_NOMEM		メモリ不足
				・共有スタック領域が確保できない【NGKI3229】
	E_OBJ		オブジェクト状態エラー
				・共有スタック領域が設定済み
----

【サポートするカーネル】

DEF_STKは，TOPPERS/SSPカーネルのみがサポートする静的APIである．他のカー
ネルは，DEF_STKをサポートしない【NGKI3230】．

【機能】

各パラメータで指定した共有スタック領域の設定情報に従って，共有スタック
領域を設定する【NGKI3231】．stkszに0以下の値を指定した時や，ターゲット
定義の最小値よりも小さい値を指定した時には，E_PARエラーとなる【NGKI3255】．

stkszは整数定数式パラメータ，stkは一般定数式パラメータである．コンフィ
ギュレータは，静的APIのメモリ不足（E_NOMEM）エラーを検出することができ
ない【NGKI3232】．

stkをNULLとした場合，stkszで指定したサイズのスタック領域が，コンフィギュ
レータにより確保される【NGKI3233】．stkszにターゲット定義の制約に合致し
ないサイズを指定した時には，ターゲット定義の制約に合致するように大きい
方に丸めたサイズで確保される【NGKI3234】．

stkにNULL以外を指定した場合，stkとstkszで指定したスタック領域は，アプリ
ケーションで確保しておく必要がある【NGKI3235】．スタック領域をアプリケー
ションで確保する方法については，「2.15.3 カーネル共通マクロ」の節を参照
すること．その方法に従わず，stkやstkszにターゲット定義の制約に合致しな
い先頭番地やサイズを指定した時には，E_PARエラーとなる【NGKI3236】．

コンフィギュレータは，各タスクのスタック領域のサイズと，非タスクコンテ
キスト用のスタック領域のサイズから，共有スタック領域に必要なサイズを計
算する【NGKI3237】．DEF_STKにより共有スタック領域を設定しない場合，必要
なサイズの共有スタック領域が，コンフィギュレータにより確保される
【NGKI3238】．

stkszに指定したスタック領域のサイズが，共有スタック領域に必要なサイズよ
りも小さい場合，コンフィギュレータは警告メッセージを出力する【NGKI3239】．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていない静的APIである．

[[API_ATT_INI]]
----
ATT_INI		初期化ルーチンの追加〔S〕【NGKI3240】
----

【静的API】
----
	ATT_INI({ ATR iniatr, intptr_t exinf, INIRTN inirtn })
----

【パラメータ】
----
　＊初期化ルーチンの追加情報
	ATR			iniatr		初期化ルーチン属性
	intptr_t	exinf		初期化ルーチンの拡張情報
	INIRTN		inirtn		初期化ルーチンの先頭番地
----

【エラーコード】
----
	E_RSATR		予約属性
				・iniatrが無効【NGKI3241】
				・カーネルドメインの囲みの中に記述されていない〔P〕【NGKI3242】
	E_PAR		パラメータエラー
				・inirtnがプログラムの先頭番地として正しくない【NGKI3243】
----

【機能】

各パラメータで指定した初期化ルーチン追加情報に従って，初期化ルーチンを
追加する【NGKI3244】．

iniatrは整数定数式パラメータ，exinfとinirtnは一般定数式パラメータである
【NGKI3245】．

inirtnが不正である場合にE_PARエラーが検出されるか否かは，ターゲット定義
である【NGKI3246】．

【補足説明】

マルチプロセッサ対応カーネルでは，クラスに属さないグローバル初期化ルー
チンはマスタプロセッサで実行され，クラスに属するローカル初期化ルーチン
はそのクラスの初期割付けプロセッサにより実行される．

[[API_ATT_TER]]
----
ATT_TER		終了処理ルーチンの追加〔S〕【NGKI3247】
----

【静的API】
----
	ATT_TER({ ATR teratr, intptr_t exinf, TERRTN terrtn })
----

【パラメータ】
----
　＊終了処理ルーチンの追加情報
	ATR			teratr		終了処理ルーチン属性
	intptr_t	exinf		終了処理ルーチンの拡張情報
	TERRTN		terrtn		終了処理ルーチンの先頭番地
----

【エラーコード】
----
	E_RSATR		予約属性
				・teratrが無効【NGKI3248】
				・カーネルドメインの囲みの中に記述されていない〔P〕【NGKI3249】
	E_PAR		パラメータエラー
				・terrtnがプログラムの先頭番地として正しくない【NGKI3250】
----

【機能】

各パラメータで指定した終了処理ルーチン追加情報に従って，終了処理ルーチ
ンを追加する【NGKI3251】．

teratrは整数定数式パラメータ，exinfとterrtnは一般定数式パラメータである
【NGKI3252】．

terrtnが不正である場合にE_PARエラーが検出されるか否かは，ターゲット定義
である【NGKI3253】．

【補足説明】

マルチプロセッサ対応カーネルでは，クラスに属さないグローバル終了処理ルー
チンはマスタプロセッサで実行され，クラスに属するローカル終了処理ルーチ
ンはそのクラスの初期割付けプロセッサにより実行される．

【μITRON4.0仕様との関係】

μITRON4.0仕様に定義されていない静的APIである．

[[API_ref_cfg]]
----
ref_cfg		コンフィギュレーション情報の参照〔T〕
----

【C言語API】
----
	ER ercd = ref_cfg(T_RCFG *pk_rcfg)
----

☆未完成

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，ref_cfgをサポートしない．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，ref_cfgをサポートしない．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，ref_cfgをサポートしない．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，ref_cfgをサポートしない．

[[API_ref_ver]]
----
ref_ver		バージョン情報の参照〔T〕
----

【C言語API】
----
	ER ercd = ref_ver(T_RVER *pk_rver)
----

☆未完成

【TOPPERS/ASPカーネルにおける規定】

ASPカーネルでは，ref_verをサポートしない．

【TOPPERS/FMPカーネルにおける規定】

FMPカーネルでは，ref_verをサポートしない．

【TOPPERS/HRP2カーネルにおける規定】

HRP2カーネルでは，ref_verをサポートしない．

【TOPPERS/SSPカーネルにおける規定】

SSPカーネルでは，ref_verをサポートしない．

